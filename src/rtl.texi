@c Copyright (C) 1988-2015 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node RTL
@chapter RTL Representation
@cindex RTL representation
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

GCC の仕事の大半は、レジスタ転送言語(RTL)と呼ばれる中間表現に対して
なされる。このレジスタ転送言語では、出力すべき命令を一つづつ、
その命令が行う操作を代数的な形式で記述する。

RTL は、Lisp 言語のリストにヒントを得たものである。RTL は、
他の構造体を指す構造体からなる内部形式と、マシン記述とデバッグ用ダンプ出力
で用いられるテキスト形式の二種類の形式を持つ。テキスト形式では、
内部形式でのポインタを示すのに多重の括弧を使う。

@menu
* RTL Objects::       式、ベクトル、文字列、整数
* RTL Classes::       RTL 式オブジェクトのカテゴリとその構造
* Accessors::         式オペランドやベクトルの要素へのアクセスマクロ群
* Flags::             RTL 式中のフラグ
* Machine Modes::     データの大きさと形式の記述
* Constants::         定数値を持つ式
* Regs and Memory::   レジスタの内容やメモリを表現する式
* Arithmetic::        算術演算を表す式
* Comparisons::       比較演算式を表す式
* Bit-Fields::        メモリまたはレジスタ中のビットフィールドを表す式
* Conversions::       拡張、打切、浮動小数点／固定小数点への変換
* RTL Declarations::  RTL 宣言
* Side Effects::      副作用のある式
* Incdec::            自動インクリメントアドレッシングに含まれる副作用
* Assembler::         オペランドを伴う @code{asm} の表現
* Insns::             insn 全体の式タイプ
* Calls::             関数呼び出し insn の RTL 表現
* Sharing::           式の共有
* Reading RTL::       ファイルからのRTLテキスト形式の読み込み
@end menu

@node RTL Objects
@section RTL Object Types
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
RTL は5種類のオブジェクトを使う。式、整数、幅広整数、文字列、ベクトル
である。式が最も重要である。ある RTL 式(省略形は``RTX'') は、C 言語の
構造体だが、普通はポインタで参照される。RTL 式の型は typedef 名
@code{rtx} で与えられる。

整数は、単に @code{int} である。10進数を使って表記する。
幅広整数は、整数型のオブジェクトのうちで、その型が @code{HOST_WIDE_INT} の
ものである(@pxref{Host Config})。やはり、10進数を使って表記する。

文字列は文字の連なりである。メモリ中では、通常の C 言語の形式である、
@code{char *} で表現され、C 言語と同じ文法にしたがって表記する。
ただし、RTL での文字列は決してヌルにはならない。マシン記述中で
空文字列を書いた場合、メモリ中ではヌルポインタではなく、ヌル文字への
ポインタとして表現される。文脈によっては、文字列の代わりにヌルポインタ
を使っても有効である。RTL のコード内では、文字列は @code{symbol_ref} 式
の中で最も良く使われる。しかし、マシン記述を構成する RTL 式の他の
文脈にも現れる。

ベクトルは、式を指す任意個数のポインタから成る。ベクトルの要素数は
ベクトルの中で明示的に表現される。ベクトルは、
空白で区切られた要素を順番に並べたものを、鍵括弧(@samp{[@dots{}]})で
囲んで表記する。長さ 0 のベクトルは作成されない。代わりに
ヌルポインタが使われる。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
式は@dfn{式コード}(または RTX コードと呼ばれる) で分類される。
式コードは @file{rtl.def} で定義される名前であり、大文字で記述した
C の列挙型定数でもある。許される式コードとその意味は機種には依存しない。
ある RTX のコードはマクロ @code{GET_CODE (@var{x})} によって
取り出すことができ、また、マクロ @code{PUT_CODE (@var{x}, @var{newcode})}
で変更することができる。

式コードは、式の中にオペランドが幾つあるか、およびオペランドがどんな種類の
オブジェクトかを決定する。
Lisp と違って RTL では、オペランドを見てもどんな種類の
オブジェクトか知ることはできない。代わりに、文脈から知る必要がある。
つまり、オペランドを含む式の式コードから知る必要がある。
例えば、式コードが @code{subreg} である式の中では、最初のオペランドが
式と見なされ、二番目のオペランドが整数とみなされる。式コード @code{plus}
の式では、二つのオペランドがあり、どちらも式としてみなされる。
式コード @code{symbol_ref} の式では、オペランドは一つであり、
文字列としてみなされる。

式は、式のタイプ名と、そのフラグとあればマシンモード、式のオペランドを
空白で区切り、括弧で囲んで表記する。

式コード名は、@samp{md} ファイル中では小文字で書くが、
C のコードとしては大文字となって現れる。このマニュアルでは、
@code{const_int} のように書くことにする。

@cindex (nil)
@cindex nil
通常、式が要求される場合でも、ヌルポインタが有効なコンテキストが
二、三存在する。その場合には、@code{(nil)} と表記する。

@node RTL Classes
@section RTL Classes and Formats
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

様々な式コードは幾つかの@dfn{クラス}に分類される。そのクラスは
一文字で表現される。ある RTX コードのクラスは、マクロ
@code{GET_RTX_CLASS (@var{code})} を使って知ることができる。
現在、@file{rtx.def} では以下のクラスを定義している。

@table @code
@item RTX_OBJ
実際のオブジェクト、例えば、レジスタ(@code{REG})やメモリ位置
(@code{MEM}、@code{SYMBOL_REF})等の実際のオブジェクトを表す
RTX コードである。定数やオブジェクトに基本的な変換を施したもの
(@code{ADDRESSOF}、@code{HIGH}、@code{LO_SUM})も含まれる。
@code{SUBREG} や @code{STRICT_LOW_PART} はこのクラスには
含まれず、クラス @code{x} に含まれることに注意

@item RTX_COMPARE
@code{NE} や @code{LT} 等の比較用の RTX コードである。

@item RTX_COMM_COMPARE
An RTX code for a symmetric (commutative) comparison, such as @code{EQ}
or @code{ORDERED}.

@item RTX_UNARY
@code{NEG} や @code{NOT}、@code{ABS} 等の単項算術演算用の
RTX コードである。このカテゴリには、値の拡張(符号付きも符号無しも)や
整数と浮動小数点の間の変換も含まれる。

@item RTX_COMM_ARITH
@code{PLUS} や @code{AND} 等の交換可能な二項演算の RTX コードである。
@code{NE} と @code{EQ} は比較なので、@code{<} クラスになる。

@item RTX_BIN_ARITH
@code{MINUS} や @code{DIV}、@code{ASHIFTRT} 等の交換可能でない
二項演算の RTX コードである

@item RTX_BITFIELD_OPS
ビットフィールド演算の RTX コードである。現時点では、
@code{ZERO_EXTRACT} と @code{SIGN_EXTRACT} だけである。
これらは入力が三つあり、左辺値である(そのため、挿入にも同じように
使える)。@xref{Bit-Fields}。

@item 3
その他の3入力演算の RTX コードである。現時点では、
@code{IF_THEN_ELSE} のみでる。

@item RTX_INSN
命令全体を表す RTX コードである。@code{INSN}、@code{JUMP_INSN}、
@code{CALL_INSN} がある。@xref{Insns}。

@item RTX_MATCH
@code{MATCH_DUP} 等の、insn にマッチする何かを表す RTX コードである。
マシン記述にのみ現れる。

@item RTX_EXTRA
その他の全ての RTX コードである。このカテゴリには、マシン記述でしか
使われない(@code{DEFINE_*} 等)残りのコードが含まれる。
副作用を記述する全てのコードと insn の連鎖に現れる、@code{NOTE}、
@code{BARRIER}、@code{CODE_LABEL} 等の非 insn が含まれる。
@end table

@cindex RTL format
@file{rtl.def} には、式のタイプ毎に、その式が含むオブジェクトの数と
その性質が@dfn{フォーマット}と呼ぶ式 コードを表す文字の連なりで記述されている。
例えば、@code{subreg} のフォーマットは @samp{ei} となる。

@cindex RTL format characters
以下のフォーマット指定文字列がよく使われる。

@table @code
@item e
式(実際には式へのポインタ)

@item i
整数

@item w
幅広整数

@item s
文字列

@item E
式のベクトル
@end table

その他に以下のフォーマット指定文字が使われる。

@table @code
@item u
@samp{u} は、デバッグ用ダンプで異なった表示がなされる以外は
@samp{e} に同じである。insn へのポインタで使われる。

@item n
@samp{n} は、デバッグ用ダンプで異なった表示がなされる以外は @samp{i} に
同じである。@code{note} insn で行番号やコード番号のために使われる。

@item S
@samp{S} は省略可能な文字列を示す。メモリ中での RTL オブジェクトでは、
@samp{S} は @samp{s} に同じであるが、@samp{md} ファイルからオブジェクトを
読み込む場合には、このオペランドの文字列値は省かれる。省かれた文字列は
ヌル文字列であるとして扱われる。

@item V
@samp{V} は省略可能なベクトルを示す。メモリ中での RTL オブジェクトでは、
@samp{V} は @samp{E} に同じであるが、@samp{md} ファイルからオブジェクトを
読み込む場合には、このオペランドのベクトル値は省かれる。省かれたベクトルは、
実質的には要素が一つもないベクトルと同じである。

@item 0
@samp{0} は、通常のカテゴリには収まらないものを入れるためのスロット
であることを意味する。@samp{0} のスロットは、どのダンプにも表示されず、
gcc の極く一部で特別な使われ方をする。
@end table

以下は、オペランド数、式コードのフォーマットを得るためのマクロである。

@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
コードが @var{code} である RTX のオペランド数。

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
コードが @var{code} である RTX のフォーマットを C の文字列で
表したもの。
@end table

RTX コードの幾つかのクラスは常に同じフォーマットである。
例えば、全ての比較演算のフォーマットは @code{ee} であると想定しても
安全である。

@table @code
@item 1
このクラスのコードのフォーマットは全て @code{e} である。

@item <
@itemx c
@itemx 2
このクラスのコードのフォーマットは全て @code{ee} である。

@item b
@itemx 3
このクラスのコードのフォーマットは全て @code{eee} である。

@item i
このクラスのコードのフォーマットは全て @code{iuueiee} で始まる。
ある insn の連鎖にリンクされた RTL オブジェクトのクラスが全て
@code{i} ではないことに注意。

@item o
@itemx m
@itemx x
これらのコードのフォーマットについては何ら想定を置くことはできない。
@end table

@node Accessors
@section Access to Operands
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
式中のオペランドは、@code{XEXP} や @code{XINT}、@code{XWINT}、それに
@code{XSTR} というマクロを使って参照することができる。これらのマクロは
それぞれ引数を二つ取る。RTL式のポインタ(RTX) とオペランドの番号である。
オペランドの番号は 0 からはじまる。例えば、

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
とあれば、式 @var{x} の二番目のオペランドを式として参照する。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
こちらは、同じオペランドを整数として参照する。同様に、@code{XSTR} を
使うと文字列として参照する。

どんなオペランドも整数として、あるいは式として、また文字列として
参照できる。ユーザは、オペランドに実際貯えられている値の種類に
応じて、正しい参照方法を選ばなければならない。これは、
オペランドを含んでいる式の式コードを見て判断するのが良い。
また、オペランド数を調べるのも式コードで調べることができる。

例えば、@var{x} が @code{subreg} 式なら、オペランドは二つあり、
それぞれ @code{XEXP (@var{x}, 0)} と @code{XINT (@var{x}, 0)} として
正しく参照できる。@code{XINT (@var{x}, 0)} とすると、
オペランド 0 の式のアドレスを整数にキャストしたものが得られる。
こういう参照の仕方が有効な場合は滅多にないと思うが、もし書くなら
@code{(int) XEXP (@var{x}, 0)} としたほうがきれいである。
また @code{XEXP (@var{x}, 1)} という書き方もエラー無しでコンパイル
できて、二番目の整数オペランドを式のポインタにキャストした結果を
返す。しかし、それを参照したときに恐らくプログラムが落ちてしまう。
さらには、@code{XEXP (@var{x}, 28)} のように書くこともできるが、
式の終りを越えたメモリをアクセスし、予期できない結果に終わるだろう。

オペランドがベクトルの場合の参照方法はもっと複雑である。
マクロ @code{XVEC} を使うとベクトルへのポインタそのものが得られ、
@code{XVECEXP} と @code{XVECLEN} を使うとそれぞれ、ベクトルの要素と
長さを得ることができる。

@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドを
ベクトルへのポインタとして参照する。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの長さを返す。
この値は @code{int} 型である。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの @var{eltnum}
番目の要素を参照する。この値は RTX である。

@var{eltnum} が負でないことおよび @code{XVECLEN (@var{exp}, @var{idx})}
より小さいことを保証するのはユーザの責任である。
@end table

このセクションで定義したマクロは全て左辺値として展開されるので、
単に参照するだけでなく、オペランドや長さやベクトルの要素を代入する
ことができる。

@node Flags
@section Flags in an RTL Expression
@cindex flags in RTL expression

RTL 式は、ある種の型の式で使われる色々なフラグ(一ビットのビットフィールド)と
その他の値を含んでいる。ほとんどの場合、フラグは以下のマクロで
参照される。

@table @code
@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
@code{mem} 式において、揮発性のメモリ参照の場合に非 0 となる。
@code{volatil} フィールドに格納され、@samp{/v} と出力される。

@findex MEM_IN_STRUCT_P
@cindex @code{mem} and @samp{/s}
@cindex @code{in_struct}, in @code{mem}
@cindex @samp{/s} in RTL dump
@item MEM_IN_STRUCT_P (@var{x})
@code{mem} 式において、構造体や共用体、配列全体かそれらの成分を
参照するときに非0となる。スカラ変数への、あるいは
ポインタを通してのスカラ変数への参照の場合は 0 となる。
@code{in_struct} フィールドに格納され、@samp{/s} と出力される。
このフラグと @code{MEM_SCALAR_P} がどちらもクリアされていると、
この MEM が構造体の中にあるのかどうかがわからない。
両方のフラグが同時に設定されることがあってはならない。

@findex MEM_SCALAR_P
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in@code{mem}
@cindex @samp{/f} in RTL dump
@item MEM_SCALAR_P (@var{x})
@code{mem} 式において、構造体や共用体、配列のメンバでないことが
知られているスカラに対する参照の場合はゼロでない値となる。
構造体や共用体、配列のメンバに対する参照や、ポインタを経由しての
間接参照に対しては、たとえそのポインタがスカラ型を指していても
ゼロとなる。このフラグと @code{MEM_STRUCT_P} が両方ともクリアされていると、
この MEM が構造体の中にあるのかどうか分からない。
両方のフラグを同時にセットしてはならない。

@findex MEM_ALIAS_SET
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_ALIAS_SET (@var{x})
@code{mem} 式において、@var{x} が属する別名のセットを表す。
これがゼロであれば、@var{x} どの別名のセットにも入っておらず、
任意のものの別名になりうる。ゼロでない場合は、@var{x} は、同じ
別名セットに入っているオブジェとの別名にしかならない。
この値は、言語フロントエンドにより(言語固有の方法で)設定される。
このフィールドはビットフィールドではない。整数であり、@code{mem} の
第二引数に現れるものである。

@findex REG_LOOP_TEST_P
@cindex @code{reg} and @samp{/s}
@cindex @code{in_struct}, in @code{reg}
@item REG_LOOP_TEST_P
@code{reg} 式において、レジスタの生存期間がループの脱出条件の
テストに含まれるなら、非0となる。
@code{in_struct} フィールドに格納され、@samp{/s} と出力される。

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
@code{reg} 式において、ユーザのソースコード中に存在する変数に
対応するなら非0となる。コンパイラ内部で一時的に生成されたものなら
0となる。
@code{volatil} フィールドに格納され、@samp{/v} と出力される。

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
@code{reg} 式において、このレジスタに現在の関数の戻り値が置かれるなら
非 0 である。(これは物理レジスタの場合にのみ発生する。)
@code{integrated} フィールドに格納され、@samp{/i} と出力される。

同じ物理レジスタが現在の関数が呼び出した関数の戻り値を置くのに
使われても良いが、そういう使い方の場合には @code{REG_FUNCTION_VALUE_P} は
 0 である。

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
それが、マシン記述マクロ @code{PROMOTED_MODE} (@pxref{Storage Layout})に
従って、より幅の広いモードに拡張されたオブジェクトを参照した際に
作られたものなら、非ゼロである。この場合、@code{subreg} のモードは
そのオブジェクトの宣言されたモードであり、@code{SUBREG_REG} のモードは
そのオブジェクトを保持するレジスタのモードである。
拡張された変数は、それぞれの代入の際に、常に、より幅の広いモードへ
符号拡張またゼロ拡張される。
@code{in_struct} フィールドに格納され、@samp{/s} として出力される。

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
@code{SUBREG_PROMOTED_VAR_P} が、参照されているオブジェクトがゼロ拡張
され続ける場合はゼロでなく、符号拡張され続ける場合はゼロとなるような、
@code{subreg} の中では、非ゼロである。
@code{unchanging} フィールドに格納され、@samp{/u} と出力される。

@findex RTX_UNCHANGING_P
@cindex @code{reg} and @samp{/u}
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{reg} and @code{mem}
@cindex @samp{/u} in RTL dump
@item RTX_UNCHANGING_P (@var{x})
@code{reg} または @code{mem} では、その値が変化しないのであれば、
非 0 である。
(このフラグは、ポインタを経由しての定数へのメモリ参照では設定されない。
そういうポインタは、現在の関数ではオブジェクトは明示的には変化しない
ということを保証するだけである。オブジェクトは、他の関数やエイリアシング
により変化し得るのである。)
@code{unchanging} フィールドに格納され、@samp{/u} と出力される。

@findex RTX_INTEGRATED_P
@cindex @code{integrated}, in @code{insn}
@item RTX_INTEGRATED_P (@var{insn})
インライン関数呼び出しの結果生じる insn 中では非 0 である。
@code{integrated} フィールドに格納され、@samp{/i} と出力される。

@findex RTX_FRAME_RELATED_P
@item RTX_FRAME_RELATED_P (@var{x})
一個の insn また式で、関数プロローグの一部であり、かつ、スタックポインタを
設定しているか、フレームポインタを設定しているか、レジスタをセーブしている
ものの中であれば、ゼロでない値となる。このフラグは、RTL プロローグを
持つターゲットで例外処理をサポートするのに必要となる。

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
一個の insn また式で、関数プロローグの一部であり、かつ、スタックポインタを
設定しているか、フレームポインタを設定しているか、レジスタをセーブしている
ものの中であれば、ゼロでない値となる。

このフラグは、RTL プロローグを
持つターゲットで例外処理をサポートするのに必要となる。

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
@code{symbol_ref} 中で、@var{x} が使われていることを指示する。
通常は、@var{x} が external として一度だけ宣言されていることを保証する
のに使われるだけである。@code{used} フィールドに格納される。

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
@code{symbol_ref} 中で、機種に固有な目的のためのフラグとして使われる。
@code{volatil} フィールドに格納され、@samp{/v} として出力される。
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
@code{symbol_ref} の中で、現在の関数の「定数プール」の一部を参照
しているなら、非ゼロとなる。これらは、関数の先頭に近いアドレスであり、
GNU CC は、直接的にアクセスが可能であると仮定する(恐らく、ベースレジスタ
の助けを借りて)。
@code{unchanging} フィールドに格納され、@samp{/u} と出力される。

@findex LABEL_OUTSIDE_LOOP_P
@cindex @code{label_ref} and @samp{/s}
@cindex @code{in_struct}, in @code{label_ref}
@item LABEL_OUTSIDE_LOOP_P
@code{label_ref} 式の中で、ラベルへの参照がある場合、そのラベルが、
ラベルへの参照を含む最も内側のループの外側にあるなら、非ゼロとなる。
@code{in_struct} フィールドに格納され、@samp{/s} として出力される。

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{jump_table_data} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{jump_table_data}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
insn の中で、その insn が削除済であれば非 0 である。
@code{volatil} フィールドに格納され、@samp{/v} と出力される。

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
遅延スロット中の insn には @code{INSN_ANNULLED_BRANCH_P} が設定され、
遅延スロット中の insn の効果を条件により無効化するような
分岐 insn を使うべきであることを指示する。
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
分岐命令の遅延スロット中の @code{insn} の中で、その insn が
分岐命令のターゲットから来たものであることを示す。
分岐 insn の @code{INSN_ANNULLED_BRANCH_P} ビットが立っていれば、
この insn は、分岐が成立したときにのみ実行される。
@code{INSN_FROM_TARGET_P}ビットが立っていない無効化された分岐命令の場合は、
insn は、分岐が成立しなかったときにのみ実行される。
@code{INSN_ANNULLED_BRANCH_P} が設定されていない場合は、
この insn は常に実行される。
@code{in_struct} フィールドに格納され、@samp{/s} と出力される。

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
遅延スロット中の insn には @code{INSN_ANNULLED_BRANCH_P} が設定され、
遅延スロット中の insn の効果を条件により無効化するような
分岐 insn を使うべきであることを指示する。
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
分岐命令の遅延スロット中の @code{insn} の中で、その insn が
分岐命令のターゲットから来たものであることを示す。
分岐 insn の @code{INSN_ANNULLED_BRANCH_P} ビットが立っていれば、
この insn は、分岐が成立したときにのみ実行される。
@code{INSN_FROM_TARGET_P}ビットが立っていない無効化された分岐命令の場合は、
insn は、分岐が成立しなかったときにのみ実行される。
@code{INSN_ANNULLED_BRANCH_P} が設定されていない場合は、
この insn は常に実行される。
@code{in_struct} フィールドに格納され、@samp{/s} と出力される。

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
@code{call_insn} の中で、insn が定数関数への呼び出しを表しているか
どうかを示す。@code{unchanging} フィールドに格納され、@samp{/u} と
出力される。

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
@code{code_label} の中で、そのラベルが削除不可であることを示す。
非局所的 goto によるラベルの参照でこのビットがセットされる。
@code{in_struct} フィールドに格納され、@samp{/s} と出力される。

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{jump_table_data} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{call_insn}, @code{jump_insn} and @code{jump_table_data}
@item SCHED_GROUP_P (@var{x})
命令スケジューリング中、ある insn において、直前の insn はこの insn と
同時にスケジューリングされなければならないことを示す。
これを使って、ある命令のグループが命令スケジューリングのパスによって、
分割されないことを保証する。例えば、@code{call_insn} の直前の
@code{use} insn は、@code{call_insn} から分離されることはない。
@code{in_struct} フィールドに格納され、@samp{/s} として出力される。
@end table

以下に、上述のマクロが参照するフィールドを挙げる。

@table @code
@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
@code{mem}式の中では、その式が参照するメモリデータが、
構造体または配列の全体あるいは一部であれば、1 となる。
スカラ変数であれば、0 になる。
C 言語のポインタを通しての参照は 0 となる。ポインタはスカラ変数を
指すからである。この情報により、GCC が、エイリアシングが起こる場合に
ついて何らかの決定を下すことができるようになる。

分岐命令の遅延スロットの insn の中では、1 であれば、この insn が
分岐先から来たものであることを意味する。

命令のスケジューリングの間では、insn の中では、1 であれば、
この insn は、直前の insn と共に構成するグループの一部として
スケジュールされなければならないことを意味する。

@code{reg} 式の中では、その式が示すレジスタの生存範囲が、
あるループの条件式の中に完全に収まるのであれば、1 である。

@code{subreg} 式の中では、1 であれば、その @code{subreg} が、
より広いモードから格上げされたモードを持っていたオブジェクトを
参照していることを示す。

@code{label_ref} 式の中では、1 であれば、参照しているラベルが、
その @code{label_ref} 式のある insn を含む最も内側のループの
外にあることを示す。

@code{code_label} 式の中では、そのラベルが削除されることが決してありえない
のなら、1 である。これは、非局所的な goto の目的先であるラベルで
使われる。

RTL ダンプの中では、このフラグは @samp{/s} と表記される

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
@code{reg} 式と @code{mem} 式の中では、1 であれば、その式の値が
決して変化しないことを意味する。

@code{subreg} 式の中では、その @code{subreg} 式が、より広いモードへ
格上げされたモードを持つ符号無しのオブジェクトを参照しているのであれば、
1 である。

insn の中では、1 であれば、無効化付きの分岐であることを意味する。

@code{symbol_ref} 式の中では、1 であれば、このシンボルが、関数毎の
定数プール中の何かを参照していることを示す。

@code{call_insn} の中では、1 であれば、この命令が定数関数への呼び出しで
あることを意味する。

RTL ダンプ中では、このフラグは @samp{/u} と表示される。

@findex used
@item used
通常は、このフラグは、関数の RTL 生成の最後で、ある式が insn の中に何回
現れたかを数えるために、一時的に使われるだけである。
二回以上現れた式は、共有構造の規則に従ってコピーされる(@pxref{Sharing})。

@code{reg} では、リーフレジスタの番号付け替えのコード部分で、
各レジスタの番号付け替えが一回だけ行われることを保証するのに
使われる。

@code{symbol_ref} では、そのシンボルに対する外部宣言が既に書き込み済で
あることを意味する。

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
このフラグは、@code{mem}式、@code{symbol_ref}式、@code{reg}式および
insn の中で使われる。RTL ダンプファイルでは、@samp{/v} と表記される。

@code{mem} 式の中では、メモリ参照が揮発性(volatile)であれば 1 である。
揮発性メモリ参照は、削除や並べかえや結合は出来ない。

@code{symbol_ref} 式の中では、機種固有の目的で使われる。

@code{reg} 式の中では、その値がユーザレベルの変数であれば、1 である。
0 であれば、コンパイラが内部的に使う一時的なものであること示す。

insn の中では、1 であればその insn が既に削除された事を意味する。

@findex integrated
@item integrated
insnを含む、ある種の式の中では、このフラグは、この RTL が手続き統合
(procedure integration)により生成されたことを意味する。

@code{reg} 式の中では、このフラグは、このレジスタが、現在の関数に
より返されるはずの値を含んでいることを示す。
引数をレジスタで渡す機種では、同じ番号のレジスタが引数としても
使われるが、その様に使用される場合にはこのフラグはセットされない。
@end table

@node Machine Modes
@section Machine Modes
@cindex machine modes

@findex machine_mode
マシンモードは、データオブジェクトの大きさ、その表現方法を記述する。
C のコード中では、マシンモードは列挙型 @code{enum machine_mode} で
表現される。この列挙型は、@file{machmode.def} で定義されている。
各 RTL 式にはマシンモードを格納する場所があり、そのため、ある種のツリー式
(正確には、宣言と型である)を格納する場所も持っている。

デバッグダンプとマシン記述のなかでは、RTL 式のマシンモードは、式コードの
後ろにコロンで区切って書く。各マシンモード名に付く@samp{mode}は、
省略される。例えば、@code{(reg:SI 38)} は、@code{reg} 式で、マシンモードは
@code{SImode} である。モードが @code{VOIDmode} の場合は、モードとしては
何も出力されない。

以下にマシンモードの表を示す。以下では、「バイト」とは、@code{BITS_PER_UNIT}
ビットのオブジェクトを指す(@pxref{Storage Layout})。

@table @code
@findex QImode
@item QImode
「1/4 精度整数」(Quarter-Integer)モードは、整数として扱われる1バイトを
表現する。

@findex HImode
@item HImode
「1/2 精度整数」(Half-Integer)モードは、2バイト整数を表す。

@findex PSImode
@item PSImode
「部分単精度整数」(Partial Single Integer)モードは、4バイトを占有するが、
実際に4バイト全てを使うことはないような整数を表す。
マシンによっては、これがポインタ用の正しいモードになる。

@findex SImode
@item SImode
「単精度整数」(Single Integer)モードは、四バイト整数を表す。

@findex PDImode
@item PDImode
「部分倍精度整数」(Partial Double Integer)モードは、8バイトを占有するが、
実際に8バイト全てを使うことはないような整数を表す。
マシンによっては、これがある種のポインタ用の正しいモードになる。

@findex DImode
@item DImode
「倍精度整数」モードは八バイト整数を表す。

@findex TImode
@item TImode
「4倍精度整数」(Tetra Integer)モードは、16バイト整数を表す。

@findex SFmode
@item SFmode
「単精度浮動小数点数」(Single Floating)モードは、単精度(四バイト)浮動小数点数
を表す。

@findex DFmode
@item DFmode
「倍精度浮動小数点数」(Double Floating)モードは、倍精度(八バイト)浮動小数点数
を表す。

@findex XFmode
@item XFmode
「拡張精度浮動小数点数」(Extended Floating)モードは、3倍精度(12バイト)
浮動小数点数を表す。このモードは、IEEE 拡張浮動小数点数に使う。
システムによっては、12バイトの中には実際に使われないビットがある。

@findex TFmode
@item TFmode
「4倍精度浮動小数点数」(Tetra Floating)モードは、4倍精度(16バイト)
浮動小数点数を表す。

@findex CCmode
@item CCmode
「条件コード」(Condition Code)モードは、条件コードの値を表す。
条件コードは、機種に固有のビットの一群で、比較演算の結果を表す。
これ以外の機種固有のモードが条件コードに対して使われることもある。
これらのモードは、@code{cc0} を使う機種では使われない。
(@pxref{Condition Code}。)

@findex BLKmode
@item BLKmode
「ブロック」(Block)モードは、他のどのモードも適用できないような集合体の
値を表す。RTL では、メモリへの参照のみがこのモードを取りうる。
しかも、それが文字列移動またはベクトル命令中に現れたときだけに限られる。
このような命令を持たない機種では、@code{BLKmode} が RTL に現れることは
ない。

@findex VOIDmode
@item VOIDmode
「ボイド」(Void)モードは、モードがないこと、あるいはモードを指定しないこと
を意味する。例えば、コードが @code{const_int} である RTL 式は
@code{VOIDmode} になる。何故なら、文脈が要求するどんなモードとしても
取ることが出来るからである。RTL のデバッグダンプ中では、@code{VOIDmode} は、
モードが一切無いことにより表現される。

@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item SCmode, DCmode, XCmode, TCmode
これらのモードは、浮動小数点数値の対として表現された複素数を表す。
浮動小数点数値は、それぞれ、@code{SFmode}, @code{DFmode}, @code{XFmode},
@code{TFmode} になる。

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
これらのモードは、整数値の対として表現された複素数を表す。
整数値は、それぞれ、@code{QImode}, @code{HImode}, @code{SImode},
@code{DImode}, @code{TImode}, @code{OImode} である。

@end table

マシン記述では、@code{Pmode} を C のマクロとして定義し、このマクロは
アドレス向けのマシンモードに展開される。普通は、これは @code{BITS_PER_WORD}
の大きさのモードであり、32ビットのマシンでは @code{SImode} になる。

マシン記述に必ず記述が必要なのは、@code{QImode} と、それぞれ
@code{BITS_PER_WORD}、@code{FLOAT_TYPE_SIZE}、@code{DOUBLE_TYPE_SIZE}
に対応するモードである。
GCC は、8バイトの構造体と共用体に対して @code{DImode} を使うことを
試みるが、@code{MAX_FIXED_MODE_SIZE} の定義を書き換えることにより、
抑止することができる。
また、16バイトの構造体と共用体向けに @code{TImode} を使わせることも
可能である。同様に、C の @code{short int} 型に、@code{HImode} を
使うのを避けるように設定することも可能である。

@cindex mode classes
現在では、GCC の中でマシンモードを明示的に参照しているコードはほとんどなく、
あっても早々に削除してしまう予定である。その代わり、マシンモードを
モードのクラスに分割している。マシンモードのクラスは、列挙型
@code{enum mode_class} で表される。この列挙型は @file{machmode.h} で
定義されている。取りうるモードクラスは以下の通りである。

@table @code
@findex MODE_INT
@item MODE_INT
整数モード。デフォルトでは、@code{QImode}, @code{HImode}, @code{SImode},
@code{DImode}, @code{TImode} が該当する。

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
「部分整数モード」を表す。@code{PSImode} と @code{PDImode} が
該当する。

@findex MODE_FLOAT
@item MODE_FLOAT
浮動小数点モード。デフォルトでは、@code{SFmode}, @code{DFmode}, @code{XFmode},
@code{TFmode} である。

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
整数複素数モード。(現時点では実装されていない。)

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
浮動小数点複素数モード。デフォルトでは、@code{SCmode}、
@code{DCmode}, @code{XCmode}, and @code{TCmode} である。

@findex MODE_FUNCTION
@item MODE_FUNCTION
静的チェーンを含む、Algol や Pascal の関数変数である。
(現時点では実装されていない。)

@findex MODE_CC
@item MODE_CC
条件コード値を表すモード。これには、@code{CCmode} と、
@code{EXTRA_CC_MODES} マクロに示された全てのモードが含まれる。
@xref{Jump Patterns}、@ref{Condition Code} を参照のこと。

@findex MODE_RANDOM
@item MODE_RANDOM
これは、上記のどのクラスにも当てはまらないモードのための受皿モードである。
現時点では、@code{VOIDmode} と @code{BLKmode} が @code{MODE_RANDOM} に
該当する。
@end table

以下にマシンモード関連の C マクロを示す。

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
RTX @var{x} のマシンモードを返す。

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
RTX @var{x} のマシンモードを @var{newmode} にする。

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
ターゲット機種で利用可能なマシンモードの数を表す。
これは、マシンモード値のうち最大のものに 1 を足したものになる。

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
モード @var{m} の名前を文字列で返す。

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
モード @var{m} のモードクラスを返す。

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
指定したモードの次に広い自然なモードを返す。
例えば、@code{GET_MODE_WIDER_MODE (QImode)} という式は、
@code{HImode} を返す。

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
モード @var{m} のデータの大きさをバイト数で返す。

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
モード @var{m} のデータの大きさをビット数で返す。

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
一語中のビットのうち、モード @var{m} の範囲内に収まる全てのビットを
表すビットマスクを返す。
このマクロは、ビット数が @code{HOST_BITS_PER_INT} 以下であるモードに
対してのみ使うことができる。

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
モード @var{m} のオブジェクトに必要なアラインメントをビット数で
返す。

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
モード @var{m} のデータの部分単位の大きさをバイト数で返す。
これは、複素数のモードの場合以外は、@code{GET_MODE_SIZE} と同じである。
複素数のモードの場合は、部分単位の大きさは、実数部また虚数部の大きさである。

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
あるモードに含まれる単位の数を返す。
すなわち、@code{GET_MODE_SIZE} を @code{GET_MODE_UNIT_SIZE} で
割ったものを返す。

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
モードクラス @var{c} の中で最も幅の狭いモードを返す。
@end table

@findex byte_mode
@findex word_mode
グローバル変数 @code{byte_mode} と @code{word_mode} は、
モードクラスが @code{MODE_INT} であり、ビット数が
それぞれ @code{BITS_PER_UNIT} と @code{BITS_PER_WORD} のモードを保持している。
32ビットマシンでは、それぞれ @code{QImode} と @code{SImode} になる。

@node Constants
@section Constant Expression Types
@cindex RTL constants
@cindex RTL constant expression types

最も簡単な RTL 式は、定数値を表すものである。

@table @code
@findex const_int
@item (const_int @var{i})
この型の式は、整数値 @var{i} を表す。@var{i} は、マクロ @code{INTVAL} を
使って @code{INTVAL (@var{exp})} のように参照するのが良く行われる。
これは、@code{XWINT (@var{exp}, 0)} と書くのと同じである。

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
整数値 0 を表す式オブジェクトは唯一つしかなく、変数 @code{const0_rtx}
の値だけである。
同じく、整数値 1 に対する式は、@code{const1_rtx} だけであり、
整数値 2 に対する式は、@code{const2_rtx} だけである。
さらに、整数値 -1 に対する式は @code{constm1_rtx} だけである。
コードが @code{const_int} で、値が 0, 1, 2, -1 のどれかの
式を作ろうとすると、それぞれ、@code{const0_rtx}、@code{const1_rtx}、
@code{const2_rtx}、@code{constm1_rtx} が返される。

@findex const_true_rtx
同様に、値が @code{STORE_FLAG_VALUE} である整数に対するオブジェクトは
唯一つだけで、@code{const_true_rtx} になる。@code{STORE_FLAG_VALUE} が
1 であれば、@code{const_true_rtx} と @code{const1_rtx} は同じオブジェクトを
指す。@code{STORE_FLAG_VALUE} が -1 なら、@code{const_true_rtx} と
@code{constm1_rtx} は同じオブジェクトを指すことになる。

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
モード @var{m} の浮動小数点定数か、@code{HOST_BITS_PER_WIDE_INT} ビット
には収まらないが @code{HOST_BITS_PER_WIDE_INT} の二倍のビット数になら
収まるような整数定数を表す(GNU CC は、それ以上に大きい定数を表現する
機能は提供していない)。後者の場合は、@var{m} は @code{VOIDmode} になる。

@findex CONST_DOUBLE_MEM
@findex CONST_DOUBLE_CHAIN
@var{addr} は、定数が置かれているメモリ上の位置に対応する @code{mem} 式を
保持する。メモリ上の位置は確保されていないが、現在のコンパイル
(表示されないフィールドを使い維持されている)の全ての @code{const_double}
式の連鎖上には存在するなら、@var{addr} は @code{const0_rtx} を含む。
その連鎖に存在しなければ、@var{addr} は @code{cc0_rtx} を含む。
@var{addr} は、マクロ @code{CONST_DOUBLE_MEM} と
@code{CONST_DOUBLE_CHAIN} を経由した連鎖フィールドを使って
アクセスするようになっている。

@findex CONST_DOUBLE_LOW
@var{m} が @code{VOIDmode} なら、値を表すビット群は @var{i0} と @var{i1}
に格納される。@var{i0} はマクロ @code{CONST_DOUBLE_LOW} で、@var{i1} は
@code{CONST_DOUBLE_HIGH} で参照するのが通例となっている。

定数が浮動小数点数なら(精度に関わらず)、その値を格納するのに必要な
整数の個数は、@code{REAL_VALUE_TYPE} に依存する。
その整数群は浮動小数点数を表現するが、厳密にはターゲットマシンまた
ホストマシンの浮動小数点数形式ではない。ターゲットマシンで使われる
正確なビットパターンに変換するには、マクロ @code{REAL_VALUE_TO_TARGET_DOUBLE}
と関連マクロを使用すること(@pxref{Data Output})。

@findex const_string
@item (const_string @var{str})
値が @var{str} である文字列定数を表す。
現時点では、この式は insn の属性(@pxref{Insn Attributes})についてのみ
使われている。というのは、C 言語の文字列定数はメモリ中に置かれるからである。

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
アセンブラのデータに対するラベルの値を表現する。
@var{symbol} は、アセンブララベル名を記述する文字列である。
この文字列が @samp{*} で始まるなら、ラベル名は、@var{symbol} から
@samp{*} を除いたものになる。それ以外の場合は、@var{symbol} そのものが
ラベル名となり、通常は @samp{_} というプレフィックスが付く。

@code{symbol_ref} にはモードがあり、普通は @code{Pmode} になる。
普通は、このモードがシンボルに対して直接有効になる唯一のモードである。

@findex label_ref
@item (label_ref:@var{mode} @var{label})
コードに対するアセンブラ・ラベルの値を表現する。
オペランドは一つであり、それは式となる。この式は、ラベルの置かれるべき
位置を特定するための命令列に現れる @code{code_label} でなければならない。

コードラベルの参照に異なる式のタイプを使用するのは、
ジャンプ最適化で区別できるようにするためである。


@findex const
@item (const:@var{m} @var{exp})
アセンブル時の代数計算の結果として生じる定数を表現する。
オペランド @var{exp} は、定数(@code{const_int}、@code{symbol_ref}、
@code{label_ref} 式)に @code{plus} と @code{minus} を組み合わせたもののみ
からなる式である。ただし、全ての組合せが有効とは限らない。
アセンブラは、再配置可能なシンボルについては勝手な計算は出来ないからである。

@var{m} は @code{Pmode} でなければならない。

@findex high
@item (high:@var{m} @var{exp})
@var{exp}、普通は @code{symbol_ref} の上位ビット群を表現する。
ビット数は機種依存であり、通常はレジスタの上位ビットを初期化する
命令で指定されるビット数になる。
@code{lo_sum} と共に使って、RISC で良く使われる、グローバルなメモリ位置を
参照する典型的な二命令の列を表現する。

@var{m} は @code{Pmode} でなければならない。
@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
マクロ @code{CONST0_RTX (@var{mode})} は、値が 0 でモードが @var{mode} の
式を参照する。モード @var{mode} が、@code{MODE_INT} のクラスのモードであれば、
@code{const0_rtx} を返す。そうでなければ、モード @var{mode} の
@code{CONST_DOUBLE} 式を返す。
同様に、マクロ @code{CONST1_RTX (@var{mode})} は、値が 1 でモード @var{mode}
の式を参照する。@code{CONST2_RTX} についても同様である。

@node Regs and Memory
@section Registers and Memory
@cindex RTL register expressions
@cindex RTL memory expressions

以下に、レジスタとメモリへのアクセスを記述する、RTL 式のタイプを示す。

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
小さな整数 @var{n} (@code{FIRST_PSEUDO_REGISTER} より小さい)に対して、
マシンのレジスタ番号 @var{n}、すなわち@dfn{ハードレジスタ}の
参照であることを意味する。@var{n} が大きな値の場合は、
一時的な値か @dfn{仮想レジスタ}を表す。
GCC の戦略としては、まず、このような仮想レジスタが無限個あると仮定して
コード生成を行ない、後で、ハードレジスタかメモリ参照への置き換えを行なう。

@var{m} は、この参照のマシンモードである。
モードの指定が必要なのは、一般に複数のモードで各レジスタを参照する
ことが可能だからである。
例えば、レジスタを一つ取ってみると、そこには全語を入れることができるが、
それを半語やバイトとして参照する命令や、色々な精度の浮動小数点数として
参照する命令もありうるのである。

レジスタをアクセスするモードが一つしかないマシンの場合でも、
モードは常に指定しなければならない。

@code{FIRST_PSEUDO_REGISTER} というシンボルはマシン記述により
定義される。というのは、あるマシンのハードレジスタの数は
そのマシンの不変の特徴だからである。ただ、マシンのレジスタが全て
汎用レジスタである必要はない。
データの格納に使える全てのマシンレジスタは、ハードレジスタ番号が
与えられる。たとえ、それらのレジスタが特定の命令でしか使えなかったり、
特定の型のデータしか保持できなくても。

ハードレジスタは一つの関数の中でも色々なモードでアクセスされる。
しかし、疑似レジスタにはそれぞれ自然なモードが与えられており、
そのモードでしかアクセスされない。
疑似レジスタを自然なモード以外のモードでアクセスするのを記述する
必要があるときは、@code{subreg} 式が使われる。

1ワードより多くのデータを指定するマシンモードを持つ @code{reg} 式は、
実際には幾つかの連続するレジスタを表す事がある。
そのレジスタ番号が、ある一個のハードウェアレジスタを指定するだけでなく、
実際には、その指定されたレジスタから始まる、幾つかの連続した
ハードウェアレジスタ群を表している。

関数 RTL コードで使われている疑似レジスタ番号はそれぞれ、
一意的な @code{reg} 式で表現される。

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
@code{FIRST_VIRTUAL_REGISTER} から @code{LAST_VIRTUAL_REGISTER} までの
範囲の疑似レジスタ番号のうちいくつかは、
RTL 生成過程にしか現れず、最適化過程の前に削除される。
こういう疑似レジスタ番号は、それを含む関数についての RTL 生成が
完了するまでは決定できないスタックフレーム中の位置を表す。
以下の仮想レジスタ番号が定義されている。

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
スタック渡しされた入力引数の先頭のワードを指し示す。
通常、これらの引数は呼びだし側によって置かれるが、
呼び出された側が、以前にレジスタで渡された引数の幾つかを
プッシュすることもありうる。

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
RTL が完了した時点で、この仮想レジスタは、 @code{ARG_POINTER_REGNUM} で
指定されるレジスタと @code{FIRST_PARM_OFFSET} の値の和に置き換えられる。

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
@code{FRAME_GROWS_DOWNWARD} が定義されていれば、このマクロは
スタック上の先頭の変数のすぐ上を指す。
@code{FRAME_GROWS_DOWNWARD} が定義されていない場合は、
スタック上の先頭の変数そのものを指す。

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM} は、@code{FRAME_POINTER_REGNUM} で
指定されるレジスタと @code{STARTING_FRAME_OFFSET} の値の和で置き換えられる。

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
これは、必要とするメモリ量の分だけスタックポインタの調整が行なわれた直後の、
スタック上に動的に確保されたメモリの位置を指す。

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
この仮想レジスタは、@code{STACK_POINTER_REGNUM} で指定されるレジスタと
@code{STACK_DYNAMIC_OFFSET} の値の和に置き換えられる。

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
スタックが前もってプッシュされたときに、出力引数が書き込まれるべき
スタック上の位置を指す。
(push insn を使ってプッシュされる引数は常に @code{STACK_POINTER_REGNUM} を
使うべきである。)

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
この仮想レジスタは、@code{STACK_POINTER_REGNUM} で指定されるレジスタと
@code{STACK_POINTER_OFFSET} の値の和に置き換えられる。
@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})

@code{subreg} 式は、マシンに取って自然なモード以外のモードにある
レジスタ、あるいは実際には複数のレジスタを参照する複数ワードの @code{reg}
のうちの一つのレジスタを参照するのに使われる。

疑似レジスタにはそれぞれ自然なモードがある。
その自然なモードとは異なるモードでの操作が必要な場合、例えば、
一個のバイトを保持している疑似レジスタに対してフルワードの移動命令を
行なう場合は、その疑似レジスタは @code{subreg} の中に収まって
いなければならない。この例の場合は、@var{wordnum} は 0 である。

@var{m} は普通は少なくとも @var{reg} のモードの幅しかなく、
その場合、@var{reg} のビットのうち @var{m} に入っているものだけを
考えれば良い。

場合によっては、@var{m} は @var{reg} のモードよりも広い。
そういう @code{subreg} 式は、@dfn{病的}と呼ばれることがある。
このような式は、より広いモードのオブジェクトを参照したいが、
付加的なビットがどういう値を持っているかは気にしないという場合に
使われる。
再ロードパスは、病的な参照はハードレジスタに対してのみ作られることを
保証する。

@code{subreg} の別の使い方は、複数のレジスタからなる値から個々のレジスタを
取り出すことである。@code{DImode} や @code{TImode} の様なマシンモードは、
一語より長い値、つまり通常二つ以上のレジスタを必要とする値である可能性が
ある。こういうレジスタの一つを参照するには、@code{subreg} をモード
@code{SImode} で使い、@var{wordnum} でどのレジスタかを指定する。

病的でない @code{subreg} に格納すると、@code{subreg} と同じワードに
属するビットに予期できない結果を生ずる。
この手抜きにより、そういう命令に対して効率の良いコードを生成するのが
用意になる。
@code{subreg} の外側の全ビットを保存する命令を表現するには、
@code{subreg} を @code{strict_low_part} で囲めば良い。

コンパイル時のパラメータである @code{WORDS_BIG_ENDIAN} が 1 に設定
されていれば、ワード番号 0 が最上位部であることを指示する。
1 でなければ、ワード番号 0 は最下位部を指示する。

ターゲットによっては、@code{FLOAT_WORDS_BIG_ENDIAN} と
@code{WORDS_BIG_ENDIAN} が一致しないものが 2、3ある。
だが、GCC のほとんどの部分は、浮動小数点値を、整数値と同じエンディアン
であるとして取り扱っている。これがうまく働くのは、単に、それらを
整数値の集まりとして扱っているからである。@file{real.c} と
実行時ライブラリだけが、@code{FLOAT_WORDS_BIG_ENDIAN} に注意している。

結合パスと再ロードパスの間で、第一引数が @code{reg} ではなく
@code{mem} になっている、病的な @code{subreg} が発生する可能性がある。
また、再ロードパスの後では、@code{mem} を含む病的な @code{subreg} が
発生する可能性があり、通常、@code{mem} が疑似レジスタを置き換えたスタック
スロットである場合に起きる。

@code{DFmode} の値を @code{subreg} を使って @code{SFmode} で参照するのは
正しくないことに注意。
マシンによっては、@code{DFmode} の値の上位部分が
単精度浮動小数点数値と同じフォーマットでない場合がある。

また、一個のハードレジスタにある複数ワードの値のうちの一ワードを
アクセスすることは、その値が大きさから期待されるよりも少ないレジスタで
保持できるときは、正しくない。
例えば、32ビットマシンでは、浮動小数点レジスタは一個の @code{DFmode} の
値全体を保持できる。レジスタ 10 がそのようなレジスタなら、
@code{(subreg:SI (reg:DF 10) 1)} は正しくない。なぜなら、
そのような参照を一個のマシンレジスタに変換する方法がないからである。
再ロードパスは、@code{subreg} 式がこのような形式になるのを抑止する。

@findex SUBREG_REG
@findex SUBREG_WORD
@code{subreg} 式の先頭のオペランドは @code{SUBREG_REG} マクロで、
第二オペランドは @code{SUBREG_WORD} マクロで参照する。

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
一個の命令の実行に必要とされ、それ以降は使われないスクラッチレジスタを
表す。
局所レジスタ確保か再ロードパスのどちらかにより、@code{reg} に変換される。

@code{scratch} は、普通は @code{clobber} 演算中に存在する
(@pxref{Side Effects}).

@findex cc0
@cindex condition code register
@item (cc0)
条件コードレジスタを参照する。オペランドは無く、マシンモードも持たない。
使い方は以下の二通りがある。

@itemize @bullet
@item
条件コードフラグの完全なセットを表すために使う。
ほとんどのマシンでは、それぞれの比較が一連のフラグ全体を設定するので、
これが最善である。

このテクニックを使うと、@code{(cc0)} が正しく使える文脈は
二つだけである。
代入における代入先(テストおよび比較命令において)として、
および 0 (値がゼロの @code{const_int}、すなわち @code{const0_rtx} である)
との比較を行なう比較演算においてである。

@item
一個の条件の結果である一個のフラグを表すために使う。
これは、一個のフラグビットしか持たないマシン上で、そして
比較命令がテストすべき条件を指定しなければならない場合に
役にたつ。

この手法を使う場合、@code{(cc0)} が有効なのは次の二つの文脈だけである。
ソースオペランドが比較演算子である(テストと比較命令では)
代入の目的オペランドとして、もう一つは
(条件分岐の) @code{if_then_else} の最初のオペランドとしてである。
@end itemize

@findex cc0_rtx
コード @code{cc0} の式オブジェクトはただ一つだけ存在する。
変数 @code{cc0_rtx} の値である。
コード @code{cc0} の式を作りだそうとすると必ず @code{cc0_rtx} が
返ってくる。

命令が暗黙のうちに条件コードを設定する可能性がある。
多くのマシンでは、ほぼ全ての命令が計算したり、格納した値に基づいて
条件コードを設定する。こういう動作を RTL に明示的に記録する必要は
ない。というのは、マシン記述に、その命令が条件コードを設定することを
認識するための指示が含まれているからである(マクロ @code{NOTICE_UPDATE_CC}
を使う)。@xref{Condition Code}。
条件コードを設定することだけを目的とする命令、そして
条件コードを使用する命令だけが、@code{(cc0)} を書く必要がある

マシンによっては、条件コードレジスタにレジスタ番号が与えられ、
@code{reg} が @code{(cc0)} の代わりに使われる。
条件コードを書き換える命令がほんの一部の命令に限られるなら、
このアプローチが望ましい。
また別のマシンでは、条件コードを汎用レジスタに格納する。
その場合は疑似レジスタを使うべきである。

Sparc や RS/6000 のようなマシンでは、二種類の算術演算命令のセットがある。
一つのセットは条件コードを設定し、もう一つは設定しない。
このような場合を扱う最も良い方法は、通常は、条件コードを設定しない
命令を生成し、算術演算の実行と条件コードレジスタ(この場合は
@code{(cc0)} ではない)の設定の両方を行なうパターンを作ることである。
例としては、@file{sparc.md} で @samp{addcc} や @samp{andcc} を
探してみて欲しい

@findex pc
@item (pc)
@cindex program counter
プログラムカウンタを表す。
オペランドは取らず、マシンモードも持たなくて良い。
@code{(pc)} が使えるのは、分岐命令の特定の文脈においてだけである。

@findex pc_rtx
コードが @code{pc} である式オブジェクトはただ一つである。
変数 @code{pc_rtx} の値である。
コードが @code{pc} の式を作ろうとすると返ってくるのは
@code{pc_rtx} になる。

分岐を行なわない命令は全て、プログラムカウンタをインクリメントすることに
より暗黙のうちに変更する。しかし、このことを RTL に記述する必要はない。

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
この RTX は、式 @var{addr} で表されるアドレスの主記憶への参照を
表す。@var{m} はメモリの、アクセスされる単位の大きさを表す。

@findex addressof
@item (addressof:@var{m} @var{reg})
この RTX はレジスタ @var{reg} のアドレスを要求することを表す。
モードは常に @code{Pmode} である。
CSE のフェーズの後で関数内に @code{addressof} 式がどんなものであれ
残っていれば、@var{reg} は強制的にスタックに置かれ、@code{addressof} 式は、
そのスタックスロットのアドレスを表す @code{plus} 式で置き換えられる。
@end table

@node Arithmetic
@section RTL Expressions for Arithmetic
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

指定されない限り、代数演算式の全てのオペランドはモード @var{m} に対して
有効でなければならない。あるオペランドがモード @var{m} に対して有効なのは、
オペランド自身のモードが @var{m} の場合か、オペランドが @code{const_int}
または @code{const_double} で @var{m} が @code{MODE_INT} クラスのモード
の時である。

交換可能な二項演算の場合には、定数は二番目のオペランドに置くべきである。

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})

マシンモード @var{m} で実行される、@var{x} と @var{y} で表される値の
加算を表す。

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})

@code{plus} にほぼ同じだが、@var{x} と、@var{y} の下位ビットの和を
表す点が異なる。下位ビット数は機種により異なるが、一般には、
@code{Pmode} のビット数から、コード @code{high} によってセットされる
ビット数を引いたものになる(@pxref{Constants})。

@var{m} は、@code{Pmode} でなければならない。

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

減算を表す以外は @code{plus} と同じである。

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
比較目的の @var{y} から @var{x} を引く減算の結果を表す。
無限の精度があるかのように、計算は桁溢れなしで行われる。

当然のことだが、実際に無限の精度で引き算を行える機械は存在しない。
だが、引き算の結果の符号だけが使われる場合は、無限の精度で引き算が
できるような振りをすることができる。その場合、引き算の結果は条件コードに
格納される。そして、この種類の式が正しく使えるのはこういう場合、
すなわち、条件コードに格納される値としてだけである。

モード @var{m} は、@var{x} や @var{y} のモードには関係なく、
条件コードの値のモードになる。@code{(cc0)} が使われるのなら、
@code{VOIDmode} になる。それ以外の場合は、@code{MODE_CC} クラスの
中のあるモードになる。良く使われるのは @code{CCmode} である。
@xref{Condition Code}.

普通は、@var{x} と @var{y} は同じモードでなければならない。
それ以外で @code{compare} が有効なのは、@var{x} のモードが、
@code{MODE_INT} のクラスに属し、かつ、@var{y} が @code{VOIDmode} モード
の @code{const_int} か @code{const_double} の場合のみである。
@var{x} のモードによって、比較が行われるモードが決まるので、
@var{x} のモードは @code{VOIDmode} であってはならない。

オペランドの一方が定数であるなら、それは第二オペランドに
置くべきであり、そうすることによって比較のためのコードが
適切に調整される。

@code{compare} で、@code{VOIDmode} の定数を二つ指定するのは
無効である。というのは、どのモードで比較を実行すべきか知りようがないから
である。比較は、コンパイル中に畳み込まれるか、先頭のオペランドが
そのモードがわかっているレジスタにロードされるかしなければならない。

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
@var{x} で表現される値の符号を反転した(0 から引いた)値を表現する。
@var{m} のモードで演算が行われる。

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値の符号付きの積を表現する。
積は、モード @var{m} で行われる。

機種によっては、オペランドよりも大きな積を生成する乗算をサポート
している。その場合には、次のようにパターンを書くこと。

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

ここで、@var{m} は、@var{x} と @var{y} のモードよりも大きいモードである。
@var{x} と @var{y} のモードは同じでなくても良い

符号無しの、大きな積を生じる乗算の場合には、
@code{zero_extend} を使って同じように書けば良い。

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
マシンモード @var{m} で @var{x} を @var{y} で割った、符号付きの商を表す。
@var{m} が浮動小数点モードなら、厳密な商を表す。そうでなければ、
整数化した商を表す。

マシンによっては、オペランドと商の幅が全部同じではない場合の除算命令を
持っていることがある。そういう命令を表現するには、以下のように、
@code{truncate} と @code{sign_extend} を使う。

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
@code{div} とほぼ同じだが、符号無しの除算を表す。

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
@code{div} や @code{udiv} と似ているが、商の代わりに剰余を表す。

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
@var{x} と @var{y} の小さいほう(@code{smin}の場合)または大きいほう
(@code{smax} の場合)を表す。この場合、
モード @var{m} の符号付き整数として解釈が行なわれる。

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
@code{smin} や @code{smax} とほぼ同じだが、符号無しの整数として解釈が
行なわれる。


@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
@var{x} で表される値のビット毎の補数を表現する。
この演算はモード @var{m} で行なわれる。
@var{m} は、固定小数点モードでなければならない。

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の論理積を表現する。
ビット毎の論理積はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の論理和を表現する。
ビット毎の論理和はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の排他的論理和を表現する。
ビット毎の排他的論理和はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
@var{x} を左に @var{c} 回算術シフトした結果を表現する。
@var{x} のモードは @var{m} であり、固定少数点数のモードである。
@var{c} は、固定小数点数モードか、モードが @code{VOIDmode} の定数である。
@var{c} のモードがどちらになるかは、
マシン記述中の左シフト命令のエントリに対して
呼び出されるモードにより決定される。
例えば、Vax では、@var{c} のモードは、@var{m} に関わらず、
@code{QImode} である。

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
右シフトである点を除いて、@code{ashift} と同じである。
左シフトの場合と違って、この二つの演算は異なる物である。

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
同様に、左右のローテーションを表す。@var{c} が定数なら、
@code{rotate} の方を使うこと。

@findex abs
@findex ss_abs
@cindex absolute value
@item (abs:@var{m} @var{x})
@item (ss_abs:@var{m} @var{x})
モード @var{m} で計算した、@var{x}の絶対値を表現する。

@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
モード @var{m} で計算した、@var{x} の平方根を表現する。
ほとんどの場合、@var{m} は浮動小数点モードになる。

@findex ffs
@item (ffs:@var{m} @var{x})
@var{x} の、 1 であるビットのうちの最下位のビットの位置に 1 を足したものを、
モード @var{m} の整数として表現する。(@var{x} がゼロであれば、この値は
0 になる。)
@var{x} のモードは @var{m} でなくても良い。
ターゲットの機種により、色々なモードの組合せが有効である。
@end table

@node Comparisons
@section Comparison Operations
@cindex RTL comparison operations

比較演算子は、二つのオペランドについてある関係が成り立つかどうかを調べ、
その関係が成り立つなら 0 でない値、成り立たないなら 0 を表す。
0 でない値の方は、機種依存であり、 @code{STORE_FLAG_VALUE}
(@pxref{Misc})で記述されるが、この値に等しくなる必要はない。
比較演算のモードは、比較対象のデータのモードには関係ない。
比較演算が、条件判定に使われる(例えば、@code{if_then_else} の
第一オペランドとして使われる)場合は、モードは @code{VOIDmode} で
なければならない。あるいは、比較演算の結果、変数に格納すべきなんらかのデータを
生じるなら、モードは @code{MODE_INT} のクラスに入っていなければならない。
データを生成する全ての比較演算は同じモードを使わなければならない。
どのモードになるかは機種依存である。

@cindex condition codes
比較演算の使われ方には二通りある。
比較演算子を使って、条件コード @code{(cc0)} をゼロと比較することが
できる。例えば、@code{(eq (cc0) (const_int 0))} のようにである。
こういう構文では、条件コードを設定する先行命令の結果を
実際に参照している。
条件コードを設定する命令は、条件コードを使用する命令の直前に
なければならない。これらの命令の間に置いて良いのは、
@code{note} insn だけである。

あるいは、比較演算は二つのデータオブジェクトを直接比較しても良い。
比較のモードはオペランドにより決定される。どちらのオペランドも
ある共通のマシンモードに対して有効でなければならない。
両方のオペランドが定数である比較は、モードを決めることができないので
無効である。しかし、そのような比較は、定数畳み込みにより、RTL 中には
決して存在しないはずである。

上の例だと、@code{(cc0)} が直前で @code{(compare @var{x} @var{y})} に
設定されているなら、比較演算は @code{(eq @var{x} @var{y})} に
等価である。普通は、ある特定のマシンでは、どちらか一方の形式のだけの
比較がサポートされている。しかし、組合せパスは演算をマージして、
特定の insn が含まれている文脈に存在するなら、
このような @code{eq} 式を生成することを試みる。

不等比較は、符号付きと符号なしの二種類がある。
このため、符号付きと符号なしの「大なり」に対応して、
@code{gt} と @code{gtu} の異なる式コードがある。
これらは、同じ整数値の組合せに対して異なる結果を生じることもある。
例えば、1 は符号付きでは -1 より「大なり」であるが、
符号なしでは「大なり」ではない。-1 は符号なしとして扱われると、
実際には @code{0xffffffff} となり、 1 より大きいからである。

符号付き比較はまた浮動小数点値にも使われる。
浮動小数点比較は、オペランドのマシンモードにより区別される。

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表現される値が等しければ 1 で、
等しくなければ 0 である。

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表現される値が等しくなければ 1 で、
等しければ 0 である。

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
@var{x} が @var{y} より大きければ 1 である。
両者とも固定小数点であれば、符号付きで比較が行なわれる。

@findex gtu
@cindex greater than
@cindex unsigned greater than
符号無しで比較が行なわれ、そのため固定小数点数についてのみ使われるという
点を除いて、@code{gt} と同じである。

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
@code{gt} や @code{gtu} と同様だが、「より小さい」かどうかを判定する。

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
@code{gt} や @code{gtu} と同様だが、「以上」かどうかを判定する。

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
@code{gt} や @code{gtu} と同様だが、「以下」かどうかを判定する。

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
これは、比較演算ではないが、ここで挙げておく。というのは、
必ず比較演算と関連して使われるからである。
正確に言うと、@var{cond} は比較式である。
@code{if_then_else} 式は、@var{cond} により、@var{then} で表される値と
@var{else} で表される値のどちらかの選択肢を表す。

ほとんどの機種では、@code{if_then_else} 式は条件ジャンプを表す場合にのみ
有効である。

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
@code{if_then_else} と同様だが、もっと一般的である。
@var{test1}、@var{test2}、@dots{} がそれぞれ順番に実行される。
@code{cond} 式の結果は、最初に非 0 となったテストに対応する @var{value} と
なる。あるいは、非 0 となったテストがなければ、@var{default} になる。


この式は、現時点では命令パターンに対しては使用できない。
insn の属性にたいしてのみ使用できる。@xref{Insn Attributes}.
@end table

@node Bit-Fields
@section Bit-Fields
@cindex bit-fields

特別な式コードがあり、ビットフィールド命令を表現することができる。
この型の式は、RTL 中で左辺値となる。代入式の左辺に置くことが可能で、
その式で指定されたビットフィールドにある値を代入することを指示する。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
これは、@var{loc}(メモリかレジスタの参照)に含まれるか、そこで始まっている
符号拡張されたビットフィールドへの参照を表す。
このビットフィールドは幅が @var{size} ビットで、ビット位置 @var{pos} から
始まっている。コンパイル時の選択により、@code{BITS_BIG_ENDIAN} が、
メモリ単位のどちらの端から @var{pos} を数えるかを指定する。

@var{loc} がメモリ中に置かれているなら、そのモードは一バイト整数のモードで
なければならない。
@var{loc} がレジスタに置かれているなら、使うべきモードは、
パターン @code{insv} または @code{extv} (@pxref{Standard Names})
のオペランドとして指定されたものになり、通常は全語の整数モードである。
何も指定がないときのデフォルトは全語の整数モードになる。

@var{pos} のモードはマシン固有であり、パターン @code{insv} または
@code{extv} でも指定される。

モード @var{m} は、@var{loc} がレジスタなら、それに使われるモードと
同じである。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})

@code{sign_extract} と同様だが、符号なし、あるいはゼロ拡張された
ビットフィールドを参照する。
同じビット列が抽出されるが、符号拡張ではなくゼロで埋め尽くされる。
@end table

@node Conversions
@section Conversions
@cindex conversions
@cindex machine mode conversions

マシンモード間の変換は全て、明示的な変換演算で表す必要がある。
例えば、あるバイトとある全語の和を表す式を、
@code{(plus:SI (reg:QI 34) (reg:SI 80))} と書くことはできない。
なぜなら、@code{plus} という演算では、二つのオペランドは同じマシンモード
を持つ必要があるからである。
このため、バイトの大きさのオペランドを変換演算で以下のように包む必要がある。

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

変換演算は単なるプレースホルダーではない。というのは、指定された
変換前のモードから変換後のモードへ変換する方法はひとつだけでは
ないからである。変換演算のコードで、変換方法を指定するのである。

以下のどの変換演算でも、@var{x} は @code{VOIDmode} であってはならない。
変換を行なうべきがモードが判らないからである。
変換は、コンパイル時に行なうか、@var{x} をレジスタに保持するかのどちらかで
なければならない。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へ符号拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へゼロ拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex float_extend
@item (float_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に拡張した結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は、@var{m} より
幅の狭いモードの浮動小数点数値でなければならない。

@findex truncate
@item (truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は固定小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの固定少数点値でなければならない。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの浮動少数点値でなければならない。

@findex float
@item (float:@var{m} @var{x})
固定小数点値 @var{x} を符号付きとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
固定小数点値 @var{x} を符号無しとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex fix
@item (fix:@var{m} @var{x})
@var{m} が固定小数点モードの場合、浮動小数点値 @var{x} をモード @var{m} の
符号付き整数に変換した結果を表現する。
丸めをどのように行なうかは規定されないので、C プログラムをコンパイルする
ときにこの演算が正しく使えるのは、オペランドが整数値を持つ時だけである。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
浮動小数点値 @var{x} をモード @var{m} の符号なし整数に変換した結果を表現する。
丸めをどのように行なうかは規定されない。
@end table

@node RTL Declarations
@section Declarations
@cindex RTL declarations
@cindex declarations, RTL

宣言式コードは、算術演算を表すのではなく、オペランドの状態に関する
表明を表す。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
この式コードはただ一つの文脈でのみ使われる。
@code{set} 式の目的オペランドとしてだけ使われる。
さらに、この式のオペランドは矛盾のない @code{subreg} 式でなければ
ならない。

@code{strict_low_part} があると、モード @var{n} では意味があるが、
モード @var{m} の一部ではないようなレジスタの一部が、変更すべきで
ないことを示す。
通常、@var{m} の幅がワードより狭いときは、このようなサブレジスタに
代入を行なうと、そのレジスタの他の部分に予期しない影響を与える。
@end table

@node Side Effects
@section Side Effect Expressions
@cindex RTL side effect expressions

ここまで説明してきた式コードは値を表すものであり、動作を
表すものではなかった。
しかし機械命令というものは決して値を生み出すものではない。
機械命令は、マシンの状態に副作用を与えるという点でのみ意味を持つ。
特別な式コードを使って、副作用を表現する。

命令の本体は、必ず以下の副作用を表すコードの一つである。
これまで説明してきた、値を表現するコードは、これらのオペランドとしてのみ
現れるのである。

@table @code
@findex set
@item (set @var{lval} @var{x})
@var{x} の値を @var{lval} で表される場所に格納する動作を表現する。
@var{lval} は、その中に格納可能であるような場所を表す式である。
すなわち、@code{reg}(あるいは @code{subreg}、または @code{strict_low_part})、
@code{mem}、@code{pc}、@code{cc0} のどれかである。

@var{lval} が、@code{reg}、@code{subreg}、@code{mem} のどれかなら、
マシンモードを持つ必要がある。その場合、@var{x} は、そのモードで
有効でなければならない。

@var{lval} が、マシンモードがそのレジスタの全幅より小さいような
@code{reg} であれば、そのマシンモードにより指定されたレジスタの部分には
指定された値が与えられ、レジスタのその他の部分は未定義値となる。
同様に、@var{lval} が、レジスタのモードより狭いモードの @code{subreg} なら、
レジスタのその他の部分がどのように変更されるかは不定である。

@var{lval} が、@code{subreg} の @code{strict_low_part} なら、
@code{subreg} のマシンモードで指定されたレジスタの部分は、
値 @var{x} が与えられ、その他の部分は変更されない。

@var{lval} が @code{(cc0)} なら、マシンモードがないので、
@var{x} は @code{compare} 式か、任意のモードを持つ値で良い。
後者の場合は、``test'' 命令を表現する。
@code{(set (cc0) (reg:@var{m} @var{n}))} という式は、
@code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))} という
式に等価である。
前者の式を使ったほうが、コンパイル中のメモリを節約できる。

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
@var{lval} が @code{(pc)} なら、それはジャンプ命令であり、
@var{x} の取りうる値は非常に限られてくる。
@var{x} は、@code{label_ref} 式とすることができる(無条件ジャンプ)。
@code{if_then_else} (条件ジャンプ)とすることもでき、その場合、
第二オペランドか第三オペランドのどちらかが @code{(pc)} (ジャンプしない場合に
使われる)でなければならず、またもう一方は @code{label_ref}
(ジャンプする場合に使われる)でなければならない。
また、@var{x} は @code{mem} または @code{(plus:SI (pc) @var{y})} でも
良い。ここで、@var{y} は @code{reg} か @code{mem} である。
この最後のパターンは分岐テーブル経由のジャンプを表現するのに使われる。

@var{lval} が @code{(cc0)} でも @code{(pc)} でもなければ、
@var{lval} のモードは @code{VOIDmode} としてはならず、@var{x} のモードは
@var{lval} のモードとして有効でなければならない。

@findex SET_DEST
@findex SET_SRC
@var{lval} は @code{SET_DEST} マクロで、@var{x} は @code{SET_SRC} マクロで
アクセスするようにするのが良い。

@findex return
@item (return)
パターン中に単独の式として書くことで、現在の関数から戻ることを
表す。ただし、VAX のように一命令で戻ることができるマシンに
限られる。
関数から戻るためには、複数の命令からなる「エピローグ」を実行する必要が
あるマシンでは、関数からの復帰は、エピローグの直前に置かれるラベルへ
ジャンプすることで行なわれるので、@code{return} 式コードが使われることはない。

@code{if_then_else} 式の中に置いた場合は、呼び出し元に戻るための @code{pc}
に置かれる値を表す。

@code{(return)} というパターンは、論理的には @code{(set (pc) (return))}
と等価であるが、後者の形式が使われることはない。

@findex call
@item (call @var{function} @var{nargs})
関数呼び出しを表現する。@var{function} は @code{mem} 式であり、
この式のアドレスは、呼び出される関数のアドレスである。
@var{nargs} は二つの目的で使われる式である。
あるマシンでは、スタックに積まれた引数のバイト数を表現する。
あるいは、引数レジスタの数を表現する。

どのマシンも @var{function} が持たなければならない標準的な
マシンモードを持っている。マシン記述では、
@code{FUNCTION_MODE} というマクロを、その不可欠のモード名に
展開されるように定義している。
このモードの目的は、どの種類のアドレッシングが許されるかが
アドレスの対象となるマシンモードに依存するマシンにおいて、
どの種類のアドレッシングが許されているかを指定することである。

@findex clobber
@item (clobber @var{x})
予期できない値を @var{x} に格納すること、または格納する可能性が
あることを表す。@var{x} は、@code{reg} 式か、@code{scratch} 式か、
@code{mem} 式のどれかでなければならない。

これが使われるのは一つは、標準的な値を特定のハードレジスタに格納する
文字列命令においてである。
格納される値を記述する手間をかける必要はないが、
文字列命令を越えてその値を保持しようとしないように、
コンパイラにレジスタの値が変更されることを知らせるのが本質的な
事である。

もし @var{x} が @code{(mem:BLK (const_int 0))} なら、
全メモリ位置が上書きされると見なされなければならないことを意味する。

マシン記述では、ある種類のハードレジスタを「呼びだし時破壊」
(``call-clobbered'') として分類していることに注意。
全ての関数の呼びだし命令は、デフォルトでこれらのレジスタを破壊すると
仮定されているので、この事実を示すために @code{clobber} 式を
使う必要はない。
また、各関数呼び出しは、その関数が @code{const} と宣言されていない限り、
任意のメモリ位置を変更する可能性があると仮定されている。

@code{parallel} の最後の組の式が、それぞれ @code{reg} か
@code{match_scratch} 式 (@pxref{RTL Template})を引数とする
@code{clobber} 式なら、組合せフェーズは、そうすることでパターンが
マッチするようになるなら、適切な @code{clobber} 式を、構築されたばかりの
insn に追加する。

この機能は、例えば、乗算命令と加算命令は MQ レジスタを使わないが、
アキュムレータへの加算命令が MQ レジスタを上書きするようなマシンで
使うことができる。
一個の組み合わされた命令(? combined instruction)は一時レジスタを
必要とするが、一方、それを構成する命令は一時レジスタを必要としない
場合も同様である。

あるレジスタに対する @code{clobber} 式が、他に副作用のある @code{parallel}
の中に現れた場合は、レジスタ確保部が、そのレジスタがその insn の前後
どちらにおいても占有されることがないことを保証する。
しかし、選ばれた選択肢に対して制約 @samp{&} が指定されていない限り、
再ロードパスが入力の一つとして使われたレジスタを確保する場合がある
(@pxref{Modifiers})。
特定のハードレジスタ、または疑似レジスタ、あるいは @code{scratch} 式の
どれかを上書きすることができる。後の二つの場合には、
GNU CC は、その時点で一時的に使用可能なハードレジスタを確保する

一時レジスタを必要とする命令については、疑似レジスタの代わりに
@code{scratch} を使うべきである。
そうしておくと、組合せフェーズが必要なときに @code{clobber} を追加すること
を許すからである。
このためには (@code{clobber} (@code{match_scratch} @dots{})) と
書けば良い。
疑似レジスタを上書きするなら、他のどこにも現れていないものを
使うこと。つまり、そのたびに新しいものを生成して使うこと。
そうしないと、CSE のフェーズが混乱する。

@code{parallel} 中で疑似レジスタを上書きすることのもう一つの使い道が
ある。insn の入力オペランドの一つがやりその insn により上書きされる
場合である。
この場合、insn 中の clobber の中と、別のところとに同じ疑似レジスタを
使うと期待どおりの結果が得られる。

@findex use
@item (use @var{x})
@var{x} の値が使われるということを表す。
プログラムのこの時点での @var{x} の値が必要であることを示す。
たとえ、なぜ必要であるかがはっきりしていなくてもである。
このため、GCC は、@var{x} に値を格納するという
効果しか持たない命令が直前にあっても、その命令を削除しない。
@var{x} は、@code{reg} 式でなければならない。

再ロードフェーズの間、パターンとして @code{use} がある insn は、
@code{reg_equal} ノートを保持することが可能である。
このような @code{use} insn は、再ロードフェーズが終了する前に
削除される。

遅延分岐スケジューリングのフェーズの間は、@var{x} は insn でも良い。
これは、@var{x} が以前にコード中のこの場所にあって、そのデータ依存関係
を考慮する必要があるということを意味する。
このような @code{use} insn は、遅延分岐スケジューリングのフェーズの
終了前に削除される。

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
並列に実行される様々な副作用を表す。
大カッコはベクトルを表す。@code{parallel} のオペランドは
式を要素とする一個のベクトルである。
@var{x0}、@var{x1} 等は個々の副作用を表す式である。
これらの式のコードは、@code{set}や @code{call}、@code{return}、
@code{clobber}、@code{use} のどれかである。

「並列に」という意味は、最初に個々の副作用で使われる全ての値が
計算され、次に全ての副作用が実行されることを表す。

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent
例えば、上の式はハードレジスタ 1 の値と、ハードレジスタ 1 により
指定されるメモリ位置の値を交換するということを曖昧さなしに
表している。
@code{(reg:SI 1)} がメモリアドレスとして現れているところでは、どちらも、
insn を実行する@emph{前}のレジスタ 1 の値を参照している。

このため、@code{parallel} を使ったときに、ある一つの @code{set} の
結果が次の @code{set} で使えると考えるのは@emph{間違い}という
ことになる。
例えば、人は良く、条件が 0 なら分岐する命令を以下のように表そうとする。

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
しかし、この書き方は間違いである。何故なら、これだと分岐条件は
この命令の@emph{前の}条件コードの値に依存しており、
この命令により設定される新しい値を使っていないからである。

@cindex peephole optimization, RTL representation
のぞき穴最適化は、最終フェーズのアセンブリコード出力と一緒に行なわれる。
この最適化により、一個の @code{parallel} からなるパターンの insn を
生成することができる。この場合、@code{parallel} の各要素は、
結果となるアセンブラコードを出力するのに必要なオペランド---多くの場合、
@code{reg} あるいは @code{mem}、定数式である。
これは、他のどのコンパイル過程でも適切な形式の RTL ではないが、
その後には、もはや実行すべき最適化過程が残っていないので、問題ないのである。
ただし、マクロ @code{NOTICE_UPDATE_CC} をもし定義するなら、
その定義では、なんらかののぞき穴最適化を定義するなら上記のような
 insn を取り扱わなければならない。

@findex sequence
@item (sequence [@var{insns} @dots{}])
ある insn の列を表す。ベクトル中に現れる @var{insns} のそれぞれは、
insn の連鎖に現れるのに適したものであるために、@code{insn}、
@code{jump_insn}、@code{call_insn}、@code{code_labe}、@code{barrier}、
@code{note} のどれかでなければならない。

@code{sequence} RTX は、RTL 生成の間は実際の insn には決して置かれること
がない。
この RTX は @code{define_expand} から生ずる insn の列を表しており、
それは、insn が @code{emit_insn} に渡され、insn の連鎖に挿入
されるまえに行なわれる。
実際に挿入された時点で、個々のサブ insn が分離し、@code{sequence} が
捨てられる。

遅延スロットスケジューリングが完了した後、ある insn とその遅延スロットに
置かれている全ての insn は一まとめにされて、一個の @code{sequence} に
収められる。遅延スロットを必要とする insn は、ベクトル中の先頭の
insn である。その後ろに続く insn は遅延スロットに置かれる。

遅延スロット中の insn には @code{INSN_ANNULLED_BRANCH_P} が設定され、
遅延スロット中の insn の効果を条件により無効化するような
分岐 insn を使うべきであることを指示する。
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.
@end table

以下の式コードは副作用の代わりに、insn の本体として現れる。
だが、厳密に言えばいつでも副作用を表すわけではない。

@table @code
@findex asm_input
@item (asm_input @var{s})
文字列 @var{s} で表されるアセンブラコードそのものを表す。

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
@var{operands} についてのマシン固有の演算を表す。
@var{index} で、複数のマシン固有演算の一つを選び出す。
@code{unspec_volatile} を使って、揮発性の演算とトラップを起こす可能性の
ある演算を表す。
その他の演算には @code{unspec} が使われる。

これらのコードは insn の @code{pattern} の内側、
@code{parallel} の内側、式の内側に現れる可能性がある。

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
ジャンプ先アドレスのテーブルを表す。
ベクトルの要素 @var{lr0}... 等は @code{label_ref} 式である。
モード @var{m} で各アドレスにどれだけのメモリを与えるかを指定する。
普通は @var{m} は @code{Pmode} になる。

@findex addr_diff_vec
ジャンプ先アドレスを @var{base} からのオフセットで表したテーブルを
表す。ベクトルの要素 @var{lr0}... 等は、@code{label_ref} 式であり、
@var{base} も @code{label_ref} 式である。
モード @var{m} で各アドレスの差分にどれだけのメモリを与えるかを
指定する。@var{min} と @var{max} は分岐の近距離化により設定され、
それぞれ最小と最大のアドレスを持つラベルを保持する。
@var{flags} は、それを保持する insn に対する @var{base}、@var{min}、
@var{max} と、@var{base} に対する @var{min}、@var{max} の相対的な
位置を表す。詳細については @file{rtl.def} を参照のこと。
@end table

@node Incdec
@section Embedded Side-Effects on Addresses
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

メモリアドレスとして現れる、特別な副作用式コードが 6 つある。

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
@var{x} を標準量だけデクリメントする副作用を表す。
また、@var{x} がデクリンメントされた後の値も表す。
@var{x} は @code{reg} か @code{mem} でなければならず、
ほとんどのマシンでは @code{reg} しか許していない。
@var{m} はそのマシンのポインタ用のマシンモードでなければならない。
@var{x} のデクリメントされる量は、アドレスとして振る舞う式の
メモリ参照を含むマシンモードの長さをバイト数で表したものである。
以下に使い方の例を示す。

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
これは、疑似レジスタ 39 を @code{DFmode} の値の長さだけデクリメントし、
その結果を @code{DFmode} の値のアドレスとして使う事を示している。

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_dec
@item (post_dec:@var{m} @var{x})
@code{pre_dec} と同じ副作用を表すが、異なる値になる。
これにより表される値は、デクリメントされる前の @var{x} の値である。

@findex post_inc
@item (post_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})

@var{x} を @var{y} に設定する副作用を表現し、かつ @var{x} が修正を受ける前の
@var{x} を表現する。@var{x} は @code{reg} か @code{mem} でなければならない。
だが、多くの機種では @code{reg} しか許していない。
@var{m} は使われている機種でのポインタのマシンモードでなければならない。
@var{x} がデクリメントされる量は、この式がアドレスの役割をする
メモリ参照のマシンモードの長さをバイトで表したものである。
これは、現在実装されていないことに注意。

式 @var{y} は次の三つの形式のうちの一つでなければならない。
@table @code
@code{(plus:@var{m} @var{x} @var{z})}
@code{(minus:@var{m} @var{x} @var{z})}
@code{(plus:@var{m} @var{x} @var{i})}
@end table
ここで @var{z} はインデックス・レジスタで、@var{i} は定数である。

使い方の例を示す。

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

これは、疑似レジスタ 42 を、疑似レジスタ 48 の内容をそれに加算する形で
変更することを示している。ただし、42 が指し示していた内容が使われた後で
行われる。

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
同様に、@var{x} の内容を使う前に副作用が発生する。
@end table

これらの組み込み副作用式は注意して使わなければならない。
命令パターンでは使わない。コンパイラの @samp{flow} パスに至るまでは、
スタックへのプッシュを表現するのに使われるだけである。
@samp{flow} パスは、レジスタが一個の命令でインクリメントまたはデクリメント
され、かつ、その直前または直後でアドレスとして使われている場合を
探す。そのような場合は、プリ／ポスト・インクリメント／デクリメントを
使うように変換する。

これらの式のオペランドとして使われているレジスタが、
ある insn の別のアドレス中で使われていると、そのレジスタの元の値が使われる。
レジスタをアドレス以外に使うことは、同一 insn 内で埋め込み副作用式として
使うのは許されない。なぜなら、そういう式は、
異なる機種では異なる振る舞いをし、そのため、取扱いが曖昧になるので
許されない。

組み込み副作用式で表現可能な命令は、また、
アドレスレジスタがどのように変更されるかを記述する追加の @code{set}
を含む @code{parallel} を使って表現することもできる。
だが、これは行なわれない。何故ならこのような操作をともかく許す機種では、
典型的には、メモリアドレスが要求される場所ならどこでもそういう操作を
許すからである。
これらの操作を付加的な並列格納として記述すると、
マシン記述のエントリ数が二倍必要になる。

@node Assembler
@section Assembler Instructions as Expressions
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
RTX コード @code{asm_operands} は、ユーザが指定したアセンブラ命令に
より生成される値を表現する。引数付きの @code{asm} 文を表現するのに
使われる。出力オペランドが一つの @code{asm} 文は以下のようになる。

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
この @code{asm} 文は、値が @code{outputvar} に格納されることを
表現する、一個の @code{asm_operands} RTX を使って以下のように表現される。

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
ここで、@code{asm_operands} RTX のオペランドは、アセンブラテンプレート文字列、
出力オペランドについての制限子、指定されたオペランドの中での出力オペランド
の番号、入力オペランド RTX のベクトル、それに、入力オペランドのモードと
制約のベクトルからなる。モード @var{m1} は、和 @code{x+y} のモードであり、
@var{m2} は、@code{*z} のモードである。

@code{asm} 文に複数の出力値がある場合は、その insn は @code{parallel} の
内側に幾つかの @code{set} RTX を持つ。
@code{set}はそれぞれ @code{asm_operands} を含んでいる。
これらの @code{set} は全て、同じアセンブラテンプレートとベクトルを
共有しているが、それぞれ出力オペランドに応じた制約を保持している。

@node Insns
@section Insns
@cindex insns

関数のコードの RTL 表現は、@dfn{insn} と呼ばれるオブジェクトの
二重線形リストである。insn は他に用途のない特別なコードを持つ式である。
insn の一部は実際の命令である。@code{switch} 文のための分岐テーブル
を表現するものもある。その他、分岐先ラベルや様々な宣言的な情報を
表現するものもある。

各 insn は、それ自身固有のデータを持つほか、現在の関数内の他の insn と
区別するための一意的な識別番号(遅延分岐スケジューリングの後で、
同じ識別番号を持つ insn のコピーが一つの関数内で複数存在することがあるが、
これらのコピーは全く同じであり、@code{sequence} の中にしか現れない)、
それに直前と直後の insn を指すポインタを持っている。
この三つのフィールドはどの insn においても、insn の式コードによらずに、
同じ位置にある。
この三つのフィールドは @code{XEXP} と @code{XINT} を使ってアクセスしても
良いが、以下のような特別なマクロが三つあり、いつでも使うことができる。

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
insn @var{i} に一意的な識別番号をアクセスする。

@findex PREV_INSN
@item PREV_INSN (@var{i})
@var{i} の直前の insn へのポインタをアクセスする。
@var{i} が先頭の insn なら、ヌルポインタになる。

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
@var{i} の直後の insn へのポインタをアクセスする。
@var{i} が末尾の insn なら、ヌルポインタになる。
@end table

@findex get_insns
@findex get_last_insn
insn のリストの先頭の insn は、@code{get_insns} で得ることができる。
末尾の insn は、@code{get_last_insn} を使って得ることができる。
先頭の insn から末尾の insn の範囲内では、@code{NEXT_INSN} と
@code{PREV_INSN} のポインタは常に対応している必要がある。
つまり、@var{insn} が先頭の insn でなければ、

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
上の式は常に真であり、また、@var{insn} が末尾の insn でなければ、

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
は常に真である。

遅延分岐スケジューリング後、リスト中の insn の幾つかは
@code{sequence} 式である可能性がある。@code{sequence} は、insn のベクトルを
含んでいる。このベクトルの中の insn の @code{NEXT_INSN} の値は、
最後の insn を除いて、ベクトルの中での次の insn を指す。
ベクトルの最後の insn の @code{NEXT_INSN} の値は、その insn を含む
@code{sequence} に対する @code{NEXT_INSN} の値と同じである。
@code{PREV_INSN} についても同様である。

つまり、先に述べた恒等式は、@code{sequence} の中の insn については
必ずしも真ではないのである。
特に、@var{insn} が @code{sequence} の先頭の insn なら、
@code{NEXT_INSN (PREV_INSN (@var{insn}))} は、
@code{sequence} 式を含む insn になり、同様に、
@code{PREV_INSN (NEXT_INSN (@var{insn}))} は、@code{sequence} 式の
最後の insn になる。
これらの式を使って @code{sequence} 式を含む insn を取り出すことができる。

どの insn も以下のような6個の式コードの一つを持っている。

@table @code
@findex insn
@item insn
式コード @code{insn} は、ジャンプも関数呼び出しも行わない命令に対して
使う。@code{sequence} 式は、その中の insn の一つがジャンプや関数呼び出しを
行なっても、常にコード が @code{insn} である insn に含まれる。

コードが @code{insn} である insn は、上記の三つの必須フィールドの他に、
四つのフィールドを持つ。この四つのフィールドについては後出の表で
説明する。

@findex jump_insn
@item jump_insn
式コード @code{jump_insn} はジャンプを行なう可能性のある命令(あるいは、
もっと一般的に言うと、@code{label_ref} 式を含む命令)で使われる。
現在の関数から復帰する命令があるなら、やはり @code{jump_insn} になる。

@findex JUMP_LABEL
@code{jump_insn} の insn には、コード @code{insn} の insn と同じ追加の
フィールドがあり、同じようにしてアクセスされ、さらに
ジャンプ最適化が完了したときに一度だけ定義される @code{JUMP_LABLE} という
フィールドも保持している。

単純な、条件ジャンプと無条件ジャンプの場合は、このフィールドは
@code{code_label} を保持しており、ここに insn が(条件分岐の場合もある)
分岐していく。もっと複雑なジャンプでは、
@code{JUMP_LABEL} が insn が参照しているラベルの一つを記録している。
その他のラベルを探すには insn の本体全体を走査するしかない。

関数から復帰する insn はジャンプ insn として数えるが、
何もラベルを参照していないので、@code{JUMP_LABLE} フィールドは 0 になる。

@findex call_insn
@item call_insn
式コード @code{call_insn} は、関数呼びだしを行なう可能性のある
命令に対して使われる。
これらの命令を区別するのは重要である。なぜなら、特定のレジスタや
メモリ位置の値を、予測できない形で変えてしまう可能性があるからである。

@findex CALL_INSN_FUNCTION_USAGE
@code{call_insn} insn は @code{insn} insn と同じ追加のフィールドを
持ち、同じ方法で参照する。さらに付け加えて、@code{CALL_INSN_FUNCTION_USAGE}
というフィールドを持っており、このフィールドは一つのリスト(@code{expr_list}
式の連鎖である)を保持している。このリストは、被呼びだし関数により
使われたか、あるいは上書きされたハードレジスタを示す @code{use} 式と
@code{clobber} 式を含んでいる。
このリストの @code{clobber} に指定されたレジスタは、@code{call_insn} の
実行の@emph{後}、変更される。一方、@code{call_insn} の本体の @code{clobber}
で指定されたレジスタは、insn の実行が完了する前に上書きされる。
このリストの @code{clobber} 式は @code{CALL_USED_REGISTERS} で
指定されたレジスタを増やす。(@pxref{Register Basics})。

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
@code{code_labe} insn は、分岐命令の分岐先となりうるラベルを
表す。標準の三つのフィールドに加えて二つの特別なフィールドがある。
@code{CODE_LABEL_NUMBER} を使って @dfn{ラベル番号}、すなわち、
コンパイル単位(現在の関数の中だけではない)の全てのラベルの中から、
このラベルを一意的に特定する番号を保持する。
最終的には、このラベルはアセンブラ出力ではアセンブララベルとして
表現される。これは、通常は @samp{L@var{n}} という形式になる。
ここで @var{n} はラベル番号である。

@code{code_label} が RTL 式に現れるときは、普通はそのラベルのアドレスを
表す @code{label_ref} の中に、番号として現れる。

@findex LABEL_NUSES
フィールド @code{LABEL_NUSES} は、ジャンプ最適化フェーズが完了した時に
一度だけ定義され、現在の関数の中でこのラベルが参照された回数を保持する。

@findex barrier
@item barrier
バリアは、命令ストリームの、制御の流れが越えることのできない地点に
置かれる。無条件ジャンプ命令の後ろに置かれ、ジャンプが無条件であることを
知らせる。また、@code{volatile} 関数呼び出しの後ろにも置かれる。
これらの関数が戻る事はない(例えば @code{exit} である)。
これらは、三つの標準フィールド以外の情報は持っていない。

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@code{note} insn は、付加的な、デバッグ情報および宣言に関する情報を
表すのに使われる。この insn には、非標準のフィールドが二つある。
一つは整数で、マクロ @code{NOTE_LINE_NUMBER} で参照され、
もう一つは文字列で、マクロ @code{NOTE_SOURCE_FILE} で参照される。

@code{NOTE_LINE_NUMBER} が正なら、そのノートはソース行の位置を
表し、@code{NOTE_SOURCE_FILE} は、その行が含まれるソースファイル名を
表す。このノートは、アセンブラ出力に行番号データを生成するの使われる。

@code{NOTE_LINE_NUMBER} が正でないなら、実際の行番号ではなくては、
以下の値の一つを持つコードである。この場合、@code{NOTE_SOURCE_FILE} は
ヌルポインタでなければならない。

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
このノートは完全に無視できる。幾つかのフェーズでは、
insn を削除するのを、それらの insn をこの種類のノートに変えてしまう
ことで行なっている。

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
This marks what used to be a @code{code_label}, but was not used for other
purposes than taking its address and was transformed to mark that no
code jumps to it.

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
この型のノートは、変数名のスコープレベルの開始位置と終了位置を
表す。デバッグ情報の出力を制御する。

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
この型のノートは、例外処理のスコープレベルの開始位置と終了位置を
表す。@code{NOTE_BLOCK_NUBMER} で、どの @code{CODE_LABEL} が
指定された領域に付属するかを特定する。

@findex NOTE_INSN_LOOP_BEG
@findex NOTE_INSN_LOOP_END
@item NOTE_INSN_LOOP_BEG
@itemx NOTE_INSN_LOOP_END
この型のノートは、@code{while} または @code{for} ループの開始位置と
終了位置を表す。これらにより、ループ最適化部が素早くループを見つけられる
ようになる。

@findex NOTE_INSN_LOOP_CONT
@item NOTE_INSN_LOOP_CONT
ループの中の、@code{continue} 文の飛び先位置に現れる。

@findex NOTE_INSN_LOOP_VTOP
@item NOTE_INSN_LOOP_VTOP
このノートは、終了テストが複製されるようなループにおいて、
終了テストが始まる位置を示す。
この位置は、ループ不変量を考えるときのもう一つの仮想的なループの
開始位置となる。

@findex NOTE_INSN_FUNCTION_END
@item NOTE_INSN_FUNCTION_END
関数本体の終り近く、(一個の命令では関数から戻れないマシンでは)
@code{return} 文の飛び先ラベルの直前に現れるノートである。

@findex NOTE_INSN_SETJMP
@item NOTE_INSN_SETJMP
@code{setjmp} や関係する関数の呼び出し毎に、その直後に現れる。
@end table

これらのコードは、デバッギングダンプにはシンボルで表示される。

@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
insn のマシンモードは普通は @code{VOIDmode} だが、
フェーズによってはモードを色々な目的で使用する。

共通部分式削除パスでは、処理済みのブロックの先頭の insn の場合、
その insn のモードを @code{QImode} に設定する。

二回目の Haifa スケジューリングパスでは、複数命令の同時発行が可能な
ターゲットに対しては、insn が同時に発行される命令のグループの
始まりの命令であると思われる場合は、その insn のモードを @code{TImode}
に設定する。つまり、その命令は直前の命令と同時に発行できないものである。
以降のパス、特に機種依存の命令並べ替えではこれはに頼っている。

以下は、@code{insn}、@code{jump_insn}、@code{call_insn} insn の
追加フィールドの表である。

@table @code
@findex PATTERN
@item PATTERN (@var{i})
この insn により発生する副作用を表す式。
これは次のコードのどれか一つでなければならない。
@code{set}、 @code{call}、 @code{use}、
@code{clobber}、 @code{return}、 @code{asm_input}、 @code{asm_output}、
@code{addr_vec}、 @code{addr_diff_vec}、 @code{trap_if}、 @code{unspec}、
@code{unspec_volatile}、 @code{parallel}、@code{sequence}。
もし @code{parallel} なら、@code{parallel} の各要素もこれらのコードで
なければならない。ただし、@code{parallel} 式はネストできないこと、
@code{addr_vec} と @code{addr_diff_vec} は @code{parallel} 式の内側では
許されないという例外がある。

@findex INSN_CODE
@item INSN_CODE (@var{i})
マシン記述中のどのパターンがこの insn にマッチするかを特定する整数
である。照合がまだ行なわれていないなら -1 を返す。

@code{use}、@code{clobber}、@code{asm_input}、@code{addr_vec}、
@code{addr_diff_vec} のどれか一個を使った式からなるパターンを
持つ insn については、照合は行なわれず、このフィールドは -1 のまま変わらない。

@findex asm_noperands
@code{asm} 文から生じる insn の場合も照合は行なわれない。
これらの insn は少なくとも一個の @code{asm_operands} 式を含む。
このような insn に対して、関数 @code{asm_noperands} は非負の値を
返す。

デバッグ出力では、このフィールドは数字の後に記号名表現が出力される。
この記号名表現は、@file{md} ファイル中のパターンの位置を、
名前付きパターンからの小さな正または負のオフセットとして示す。

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
基本ブロック内の命令間の依存関係についての情報を与える
リスト(@code{insn_list} 式の連鎖)。
ジャンプやラベルは、関係のある insn の間には入らない。

@findex REG_NOTES
@item REG_NOTES (@var{i})
insn について種々雑多な情報を与えるリスト(@code{expr_list} 式と
@code{insn_list} 式の連鎖)。
その insn で使われているレジスタに関係する情報であることが多い。
@end table

insn の @code{LOG_LINKS} フィールドは、@code{insn_list} 式の連鎖である。
それぞれの @code{insn_list} 式はオペランドを二つ取る。
一番目はある insn であり、二番目は別の @code{insn_list} 式(連鎖の次のもの)
である。連鎖の最後の @code{insn_list} では、二番目のオペランドは
ヌルポインタとなる。
連鎖について重要なことは、どの insn が(@code{insn_list} 式の
一番目のオペランドとして)その中に現れるかということである。
順序は重要ではない。

このリストは最初、フロー解析パスにより設定される。
それまではヌルポインタになっている。フロー解析パスは、
命令組合せで使用可能なデータ依存関係についてのリンクを追加するだけである。
フロー解析パスは、insn 毎に、この insn で始めて使われる値をレジスタに
格納する insn へのリンクを追加する。
命令スケジューリングパスは、余分のリンクを追加して、あらゆる依存関係
が表現されるようにする。
リンクは、データ依存関係、逆依存関係、出力依存関係を表す。
リンクのマシンモードがこの三つの型を区別する。
逆依存関係のモードは @code{REG_DEP_ANTI} であり、
出力依存関係のモードは @code{REG_DEP_OUTPUT} であり、
データ依存関係のモードは @code{VOIDmode} である。

insn の @code{REG_NOTES} フィールドは、@code{LOG_LINKS} と同様の
一個の連鎖であるが、@code{insn_list} 式に加えて @code{expr_list} 式も
含んでいる。色々な種類のレジスタノートがあり、それらはマシンモードに
より区別され、あるレジスタノート中では、実際に @code{enum reg_note} で
あると理解される。
このノートの第一オペランド @var{op} は、ノートの種類によって
意味の異なるデータである。

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
マクロ @code{REG_NOTE_KIND (@var{x})} は、レジスタノートの種類を返す。
これと対をなすマクロ @code{PUT_REG_NOTE_KIND(@var{x}, @var{newkind})} は、
@var{x} のレジスタノートのタイプを @var{newkind} に設定する。

レジスタノートには三つのクラスがある。
何か insn への入力に関するもの、何か insn の出力に関するもの、
それに、二つの insn の間のリンケージを作るものである。
また、@code{LOG_LINKS} でしか使われない値が一セットある。

以下のレジスタノートは、insn への入力についての注釈である。

@table @code
@findex REG_DEAD
@item REG_DEAD
@var{op} の中の値がこの insn で死ぬ。つまり、この insn の直後で
この値を書き換えても、プログラムの以後の動作には影響を与えない。

これは、必ずしも、レジスタ @var{op} がこの insn 以後意味のある値を持たない
ということを意味しない。この insn の出力にもなることがあるからである。
しかし、その場合、@code{REG_DEAD} ノートは冗長であり、普通は再ロードパス
迄は存在しない。だが、このことを前提としているコードはない。

@findex REG_INC
@item REG_INC
レジスタ @var{op} は、この insn 内に埋め込まれた副作用により
インクリメント(あるいは、デクリメント。このレベルでは違いはない)
される。
すなわち、これは @code{post_inc} 式、または @code{pre_inc}式、
@code{post_dec} 式、@code{pre_dec} 式に現れる。

@findex REG_NONNEG
@item REG_NONNEG
この insn に到達したとき、レジスタ @var{op} は非負の値を持つことが
知られている。これを使って、例えば m68k の dbra のような、
デクリメントして 0 でない間は分岐する(decrement and branch until zero)
命令がマッチすることが可能になる。

@code{REG_NONNEG} ノートが insn に付加されるのは、
マシン記述に @samp{decrement_and_branch_until_zero}
というパターンがある場合のみである。

@findex REG_NO_CONFLICT
@item REG_NO_CONFLICT
この insn は、たとえ衝突を引き起こすように見えても、
@var{op} とこの insn により設定されるアイテムとの間の
衝突を引き起こさない。
言い換えると、そうなっていないと代入先レジスタと @var{op} が
同じレジスタに割り当てられる場合でも、この insn はその割当を
妨げない。

このノートがある insn は、通常、あるブロックの一部である。
このブロックは複数ワードの疑似レジスタを指定する一個の @code{clobber} insn
で始まり、それぞれが一ワードの値を設定し、@code{REG_NO_CONFLICT} が付随
している insn のグループが一つ、最後に、計算される式を与える
@code{REG_EQUAL} ノートをつけて、出力をそれ自身にコピーする insn が来る。
このブロックは、先頭と末尾の insn について、それぞれ @code{REG_LIBCALL}
ノートと @code{REG_RETVAL} ノートで包み込まれている。

@findex REG_LABEL
@item REG_LABEL
この insn は @var{op}、@code{code_label} を使うが、@code{jump_insn} では
ない。このノートにより、@var{op} が実際に使われることをジャンプ最適化
に対して知らせる。
@end table

以下のノートは、insn の出力の属性を記述する。

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
このノートは、一個のレジスタだけを設定する insn についてのみ有効であり、
そのレジスタが実行時には @var{op} に等しいことを示す。
これが等しくなる範囲は、二つのノートのタイプで異なる。
この insn が明示的にそのレジスタにコピーする値は @var{op} とは
違って見えるかもしれないが、実行時には等しくなる。
一個の @code{set} の出力が @code{strict_low_part} 式なら、
このノートは @code{subreg} 式の @code{SUBREG_REG} に含まれている
レジスタを参照している。

@code{REG_EQUIV} の場合は、レジスタは関数全体を通して @var{op} に
等価であり、全て @var{op} で正当に置き換えることができる。
(ここで「正当に」はプログラムのデータ流を指す。単純な置き換えは
幾つかの insn を不正にする。)
例えば、ある定数が、他の値が決して代入されることのない、あるレジスタに
ロードされるとき、この種類のノートが使われる。

ある仮引数が関数の入り口点で疑似レジスタにコピーされるとき、
この種類のノートが仮引数が渡されたスタックスロットに等価なレジスタを
記録する。この場合、レジスタは他の insn により設定されることもあるが、
その関数内でそのレジスタをスタックスロットに置き換えることはなお有効である。

@code{REG_EQUIV} は、仮引数を格納可能なスタックスロットがある場合、
ある関数の入り口でレジスタ仮引数を疑似レジスタにコピーする命令で使われる。
他の insn がその疑似レジスタを設定する可能性もあるが、
コンパイラにとっては、関数全体で疑似レジスタをそのスタックスロットに
置き換えるのは正当である。
ただし、コンパイラは、そのスタックスロットが、最初のコピー命令での
同じように置き換えを行なうことで適切に初期化されていることを保証されている
場合である。
これは、呼び出し規約でレジスタ仮引数についてスタックスペースを
割り当てるようになっている機種で使われる。
@ref{Stack Arguments} の @code{REG_PARM_STACK_SPACE} を参照のこと。

@code{REG_EQUAL} の場合は、この insn により設定されるレジスタは、
この insn の最後では実行時に @var{op} に等価になるが、
関数内の他の場所では必ずしも等価ではない。
この場合、@var{op} は算術式であることが多い。
例えば、ライブラリ呼び出しのような insn 列が、ある算術演算を
実行するのに使われるとき、この種類のノートが最終的な値を
生成したりコピーする insn に付随する。

これらの二つのノートは、コンパイラのパス群により異なる方法で使われる。
@code{REG_EQUAL} は、レジスタ割当に先立つパス(例えば、
共通部分式削除とループ最適化)により使われ、その値をどう考えれば良いかを
そのパスに知らせる。
@code{REG_EQUIV} ノートは、レジスタ割当により使われ、
利用可能なレジスタが足りなければ、レジスタの代わりに使われる
代入式(定数か、スタック上の仮引数の位置を表す @code{mem} 式)
が利用可能であることを示す。

仮引数のスタックのホームとそのライフタイムを通じてメモリ位置に
等かな疑似レジスタを除いて、全ての等価なものは、
付随する @code{REG_EQUAL} ノートにより最初に示される。
ここで、仮引数のスタックホームは、@code{REG_EQUIV} ノートにより
指示され、最適化の最初の方のパスでは役に立たない。
また、メモリ位置に等価な疑似レジスタは、コンパイルの後の段階に
なるまで検出されない。
@var{op} が定数であり、その insn が
その代入先レジスタの組を一つしか表現しないのであれば、
レジスタ割当の初期の段階で、@code{REG_EQUAL} ノートは @code{REG_EQUIV}
ノートに変えられる。

こうして、レジスタ割当より前のコンパイラのパスでは、@code{REG_EQUAL}
ノートだけを検査する必要があり、レジスタ割当の後のパスでは
@code{REG_EQUIV} ノートだけを検査すれば良い。

@findex REG_UNUSED
@item REG_UNUSED
この insn により設定されるレジスタ @var{op} は、次の insn では
使われない。
@code{REG_DEAD} ノートとの違いは、@code{REG_DEAD} の方は、
入力中の値が後で使われることがないことを示す点にある。
この二つのノートは独立であり、同じレジスタに対して両方とも
存在してもかまわない。

@findex REG_WAS_0
@item REG_WAS_0
この insn の一個の出力は、この insn の前にゼロを含んでいた。
@var{op} が、ゼロに設定した insn である。
このノートが存在し、かつ @var{op} が削除されていたり、@code{note} に
変換されたりしていなければ、このノートを信頼することができる。
このノートが存在しない場合は、何も意味しない。
@end table

以下のノートは、insn 間のリンケージを記述する。
これらは、対で現れる。一個の insn には、ノートの対があり、それらは
二番目の insn を指す。二番目の insn には、最初のinsn を指す逆のノートが
ある。

@table @code
@findex REG_RETVAL
@item REG_RETVAL
この insn は、複数の insn から成る列(例えば、ライブラリ呼び出し)の
値をコピーする。@var{op} は、列の先頭の insn である
(ライブラリ呼び出しの場合は、ライブラリ呼び出しの引数を
設定するように生成された先頭の insn である)。

ループ最適化はこのノートを使って、コードの移動の目的のために、
このような列を一個の演算として取り扱う。
また、フロー解析ではこのノートを使って、このような列で結果が死んでいる
ものを削除する。

通常、@code{REG_EQUAL} ノートもこの insn に付属し、
この列により計算される式を提供する。

これらのノートは再ロード後に削除される。もはや不正確だったり役に
立たなかったりするからである。

@findex REG_LIBCALL
@item REG_LIBCALL
これは、@code{REG_RETVAL} の逆である。
これは複数 insn の列の先頭の insn に置かれ、最後の insn を指す。

これらのノートは再ロード後に削除される。もはや不正確だったり役に
立たなかったりするからである。

@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
@code{cc0} を使う機種では、@code{cc0} を設定したり使ったりする
insn はお互いに近くにある。だが、遅延分岐スロットを埋める処理が
行なわれると、もはや近くにあるとは言えなくなる可能性がある。
その場合、@code{REG_CC_USER} ノートが、@code{cc0} を設定する insn に
置かれて、@code{cc0} を使う insn を指し、@code{REG_CC_SETTER} ノートが
@code{cc0} を使う insn に置かれて、@code{cc0} を設定する insn を
指すようになる。
@end table

以下の値は、@code{LOG_LINKS} フィールドでのみ使われ、
各リンクが表現する依存関係の型を指し示す。
データ依存関係(書き込み後の読み込み依存関係, read after write dependence)
を指し示すリンクはどのコードも使わず、単にモードが @code{VOIDmode} であり、
何の説明文もなく出力される。

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
This indicates a true dependence (a read after write dependence).

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
これは出力依存関係(WAW、書き込み後の書き込み依存)を示す

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
これは逆依存関係(WAR、読み込み後の書き込み依存)
を示す。

@end table

これらのノートは gcov によるプロファイルデータから収集した情報を
記述する。insn の @code{REG_NOTES} フィールドに @code{expr_list} として
格納される。

@table @code
@findex REG_EXEC_COUNT
@item REG_EXEC_COUNT
プロファイルデータに基づく、基本ブロックの実行回数を示す。
このノートは、基本ブロックの先頭の insn に付加される。

@findex REG_BR_PROB
@item REG_BR_PROB
プロファイルデータに基づく、ある分岐 insn の、分岐が行なわれた回数と
行なわれなかった回数の比を示す。
0 と @code{REG_BR_PROB_BASE} の間の値として格納される。
値が大きくなると、分岐が成立する確率がより高くなることを示す。

@findex REG_BR_PRED
@item REG_BR_PRED
このノートは、遅延分岐スケジューリングが起きた後のジャンプ insn に
現れる。これらは、ジャンプの方向と可能性を示す。
フォーマットは、@code{ATTR_FLAG_*} 値のビットマスクである。

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
これは、@code{RTX_FRAME_RELATED_P} insn で使われる。
この insn では、付属した式が、実際の insn パターンの代わりに使われる。
これは、パターンが複雑か間違っている場合に行われる。
@end table

便宜上、@code{insn_list} や @code{expr_list} 中のマシンモードは、
デバッグダンプでは、これらのシンボリックコードで出力される。

@findex insn_list
@findex expr_list
式コード @code{insn_list} と @code{expr_list} の唯一の相違点は、
@code{insn_list} の先頭のオペランドは insn であると仮定され、
デバッグダンプ中では insn の一意的な ID として出力されること、
@code{expr_list} の先頭のオペランドは式として通常の方法で
出力される点にある。

@node Calls
@section RTL Representation of Function-Call Insns
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

サブルーチンを呼び出す insn は、RTL 式コードが @code{call_insn} になる。
サブルーチン呼び出し insn は特別な規則に従う必要があり、
本体部分で特別な RTL 式コード @code{call} を使わなければならない。

@cindex @code{call} usage
@code{call} 式は、以下のようにオペランドを二つ取る。

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
ここで、@var{nbytes} は、サブルーチンに渡される引数データのバイト数を
表すオペランドである。@var{fm} はマシンモードであり、
@var{addr} はサブルーチンのアドレスを表す。
@var{fm} は、マシン記述の @code{FUNCTION_MODE} マクロの定義と
同じでなければならない。

値を返さないサブルーチンについては、上に示した @code{call} 式そのものが
insn の全体になる。ただし、@code{use} 式か @code{clobber} 式を
その他に含んでいる必要がある。

@cindex @code{BLKmode}, and function return values
戻り値があり、そのモードが @code{BLKmode} でないサブルーチンについては、
戻り値はハードレジスタに置かれる。このレジスタの番号が @var{r} なら、
call insn の本体は以下のようになる。

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
この RTL 式は、この insn で、適切なレジスタに有効な値が置かれる
ことを(最適化パスに対して)はっきりさせる。

サブルーチンが @code{BLKmode} の値を返すなら、
その値を格納すべき位置のアドレスをサブルーチンに渡すという処理が
行なわれる。このため、call insn 自身はどんな値も返さないので、
値を返さない呼び出しと同じ形式の RTL になる。

マシンによっては、call 命令自身が幾つかのレジスタを、例えば
戻り先アドレスを保持するために、破壊する。
そういうマシンでの @code{call_insn} insn の本体は、
@code{call} 式と @code{clobber} 式の両方を持つ、一個の @code{parallel}
とすべきである。この @code{clobber} 式は、どのレジスタが破壊されるかを
示す。
同様に、call 命令が、スタックポインタ以外に、RTL で明示的に指定
されていないレジスタを必要とするときは、@code{use} 副式がそのレジスタに
ついて言及すべきである。

呼び出される関数は、コンフィギュレーションマクロ @code{CALL_USED_REGISTERS}
(@pxref{Register Basics})に列挙されている全てのレジスタを修正し、
@code{const} 関数とライブラリ呼びだしを例外として、全メモリを
修正すると仮定される。

単に @code{use} 式を含む insn は、どのレジスタが関数への入力を
保持しているかを示す @code{call_insn} の直前に位置する。
同様に、@code{CALL_USED_REGISTERS} で指定されている以外のレジスタが
呼び出された関数により上書きされるなら、単独の @code{clobber} を
含む insn は、それがどのレジスタかを示すために、その呼び出しの直後に
置かれる。

@node Sharing
@section Structure Sharing Assumptions
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

GNU CC は、ある種類の RTL 式は一意的であることを仮定している。
すなわち、同じ値を表す二つの異なるオブジェクトは存在しないと
仮定しているのである。
一方、それとは逆の、
ある種類の RTL 式オブジェクトは、それを含む構造の中では 2 回以上
現れることはないという仮定をしている場合もある。

これらの仮定は一個の関数に関するものである。
グローバル変数や外部関数を記述する RTL オブジェクト、
それに小さな整数定数のような2,3の基本的なオブジェクトを除いて、
二つの関数に共通の RTL オブジェクトは存在しない。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
各疑似レジスタは、それを表現する @code{reg} オブジェクトは一個しか
持たず、そのため、マシンモードも一個しかない。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
記号名ラベルはどれも、それを参照する @code{symbol_ref} オブジェクトは
一個しかない。

@cindex @code{const_int}, RTL sharing
@item
値が 0、1、@minus{}1 の @code{const_int} 式はそれぞれ一個だけである。
それ以外の幾つかの整数値も一意的に格納される。

@cindex @code{pc}, RTL sharing
@item
@code{pc} 式は一個しかない。

@cindex @code{cc0}, RTL sharing
@item
@code{cc0} 式は一個しかない。

@cindex @code{const_double}, RTL sharing
@item
それぞれの浮動小数点モードで、値 0 の @code{const_double} 式は
それぞれ一個しかない。値が 1 と 2 についても同様である。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
@code{label_ref} や @code{scratch} は、RTL 構造体の中で
二箇所以上は現れない。言い換えると、関数の中の全 insn をツリーウォーク
したときに、@code{label_ref} や @code{scratch} が見つかるたびに、
すでに見た他の全てとは違ったものであると仮定しても良い。

@cindex @code{mem}, RTL sharing
@item
各静的変数やスタックスロットについては、普通はただ一個の @code{mem}
オブジェクトが作られる。このため、これらのオブジェクトはそれが現れる
全ての場所で共用されることが多い。
しかし、これらの変数に対して、等価であるが別の独立したオブジェクトが
作られることがたまにある。

@cindex @code{asm_operands}, RTL sharing
@item
一個の @code{asm} 文に複数の出力オペランドがあると、
出力オペランド毎に別々の @code{asm_operands} 式が作られる。
しかし、これらの式は全て、入力オペランドの列を含むベクトルを共有する。
この共有は後で、二つの @code{asm_operands} 式が同じ文に由来するものか
どうかを調べるのに使われる。このため、全ての最適化で、
ベクトルを全部コピーした場合には注意深く共有を維持しなくては
ならない。

@item
上で説明したものを除いて、RTL 構造体に RTL オブジェクトが二箇所以上に
現れることはない。コンパイラのパスの多くが、このことに依存しており、
他の insn に不要な副作用を与えることなく RTL オブジェクトを直接
修正可能であるということを仮定している。

@findex unshare_all_rtl
@item
最初の RTL 生成の間は、共有される構造体が自由に導入される。
ある関数についての 全 RTL 生成が完了した後で、
全ての共有される構造体が @file{emit-rtl.c} の @code{unshare_all_rtl}
関数によりコピーされる。その後で上記のルールが成り立つことが保証される。

@findex copy_rtx_if_shared
@item
組合せパスの間、ある insn 中の共有構造体が一時的に存在できる。
しかし、共有構造体は、組合せパスがその insn についての処理を終了
する前に、コピーされる。
これは @code{copy_rtx_if_shared} を呼び出すことにより行なわれる。
この関数は @code{unshare_all_rtl} のサブルーチンである。
@end itemize

@node Reading RTL
@section Reading RTL

ファイルから RTL オブジェクトを読み込むには、@code{read_rtx} 関数を
使う。引数は、標準入力ストリーム一つであり、一個の RTL オブジェクトを
返す。

ファイルから RTL を読む処理は非常に遅い。現時点ではこれは問題ではない。
RTL の読み込みは、コンパイラを構築するときにのみ行われるからである。

RTL をテキストとしてファイルにセーブして、GNU CC の言語フロントエンドと
その他の部分とのインターフェースとして使おうと考える人が良くいるが、
これは実現不可能である。

GNU CC は、RTL を内部表現として使うようにしか設計されていない。
ある与えられたプログラムに対する正しい RTL は、特定のターゲットマシンに
著しく依存する。しかも、RTL は、そのプログラムについての情報を
全部は含んでいないのである。

GNU CC と新しい言語フロントエンドのインターフェースを取る正しい方法は、
「tree」データ構造を使う事である。このデータ構造について書いたマニュアルは
ないが、@file{tree.h} と @file{tree.def} で説明されている
