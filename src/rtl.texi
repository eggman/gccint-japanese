@c Copyright (C) 1988-2015 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node RTL
@chapter RTL Representation
@cindex RTL representation
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

GCC の仕事の大半は、レジスタ転送言語(RTL)と呼ばれる中間表現に対して
なされる。このレジスタ転送言語では、出力すべき命令を一つづつ、
その命令が行う操作を代数的な形式で記述する。

RTL は、Lisp 言語のリストにヒントを得たものである。RTL は、
他の構造体を指す構造体からなる内部形式と、マシン記述とデバッグ用ダンプ出力
で用いられるテキスト形式の二種類の形式を持つ。テキスト形式では、
内部形式でのポインタを示すのに多重の括弧を使う。

@menu
* RTL Objects::       式、ベクトル、文字列、整数
* RTL Classes::       RTL 式オブジェクトのカテゴリとその構造
* Accessors::         式オペランドやベクトルの要素へのアクセスマクロ群
* Flags::             RTL 式中のフラグ
* Machine Modes::     データの大きさと形式の記述
* Constants::         定数値を持つ式
* Regs and Memory::   レジスタの内容やメモリを表現する式
* Arithmetic::        算術演算を表す式
* Comparisons::       比較演算式を表す式
* Bit-Fields::        メモリまたはレジスタ中のビットフィールドを表す式
* Conversions::       拡張、打切、浮動小数点／固定小数点への変換
* RTL Declarations::  RTL 宣言
* Side Effects::      副作用のある式
* Incdec::            自動インクリメントアドレッシングに含まれる副作用
* Assembler::         オペランドを伴う @code{asm} の表現
* Insns::             insn 全体の式タイプ
* Calls::             関数呼び出し insn の RTL 表現
* Sharing::           式の共有
* Reading RTL::       ファイルからのRTLテキスト形式の読み込み
@end menu

@node RTL Objects
@section RTL Object Types
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
RTL は5種類のオブジェクトを使う。式、整数、幅広整数、文字列、ベクトル
である。式が最も重要である。ある RTL 式(省略形は``RTX'') は、C 言語の
構造体だが、普通はポインタで参照される。RTL 式の型は typedef 名
@code{rtx} で与えられる。

整数は、単に @code{int} である。10進数を使って表記する。
幅広整数は、整数型のオブジェクトのうちで、その型が @code{HOST_WIDE_INT} の
ものである(@pxref{Host Config})。やはり、10進数を使って表記する。

文字列は文字の連なりである。メモリ中では、通常の C 言語の形式である、
@code{char *} で表現され、C 言語と同じ文法にしたがって表記する。
ただし、RTL での文字列は決してヌルにはならない。マシン記述中で
空文字列を書いた場合、メモリ中ではヌルポインタではなく、ヌル文字への
ポインタとして表現される。文脈によっては、文字列の代わりにヌルポインタ
を使っても有効である。RTL のコード内では、文字列は @code{symbol_ref} 式
の中で最も良く使われる。しかし、マシン記述を構成する RTL 式の他の
文脈にも現れる。

ベクトルは、式を指す任意個数のポインタから成る。ベクトルの要素数は
ベクトルの中で明示的に表現される。ベクトルは、
空白で区切られた要素を順番に並べたものを、鍵括弧(@samp{[@dots{}]})で
囲んで表記する。長さ 0 のベクトルは作成されない。代わりに
ヌルポインタが使われる。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
式は@dfn{式コード}(または RTX コードと呼ばれる) で分類される。
式コードは @file{rtl.def} で定義される名前であり、大文字で記述した
C の列挙型定数でもある。許される式コードとその意味は機種には依存しない。
ある RTX のコードはマクロ @code{GET_CODE (@var{x})} によって
取り出すことができ、また、マクロ @code{PUT_CODE (@var{x}, @var{newcode})}
で変更することができる。

式コードは、式の中にオペランドが幾つあるか、およびオペランドがどんな種類の
オブジェクトかを決定する。
Lisp と違って RTL では、オペランドを見てもどんな種類の
オブジェクトか知ることはできない。代わりに、文脈から知る必要がある。
つまり、オペランドを含む式の式コードから知る必要がある。
例えば、式コードが @code{subreg} である式の中では、最初のオペランドが
式と見なされ、二番目のオペランドが整数とみなされる。式コード @code{plus}
の式では、二つのオペランドがあり、どちらも式としてみなされる。
式コード @code{symbol_ref} の式では、オペランドは一つであり、
文字列としてみなされる。

式は、式のタイプ名と、そのフラグとあればマシンモード、式のオペランドを
空白で区切り、括弧で囲んで表記する。

式コード名は、@samp{md} ファイル中では小文字で書くが、
C のコードとしては大文字となって現れる。このマニュアルでは、
@code{const_int} のように書くことにする。

@cindex (nil)
@cindex nil
通常、式が要求される場合でも、ヌルポインタが有効なコンテキストが
二、三存在する。その場合には、@code{(nil)} と表記する。

@node RTL Classes
@section RTL Classes and Formats
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

様々な式コードは幾つかの@dfn{クラス}に分類される。そのクラスは
一文字で表現される。ある RTX コードのクラスは、マクロ
@code{GET_RTX_CLASS (@var{code})} を使って知ることができる。
現在、@file{rtx.def} では以下のクラスを定義している。

@table @code
@item RTX_OBJ
An RTX code that represents an actual object, such as a register
(@code{REG}) or a memory location (@code{MEM}, @code{SYMBOL_REF}).
@code{LO_SUM}) is also included; instead, @code{SUBREG} and
@code{STRICT_LOW_PART} are not in this class, but in class @code{x}.

@item RTX_CONST_OBJ
An RTX code that represents a constant object.  @code{HIGH} is also
included in this class.

@item RTX_COMPARE
An RTX code for a non-symmetric comparison, such as @code{GEU} or
@code{LT}.

@item RTX_COMM_COMPARE
An RTX code for a symmetric (commutative) comparison, such as @code{EQ}
or @code{ORDERED}.

@item RTX_UNARY
An RTX code for a unary arithmetic operation, such as @code{NEG},
@code{NOT}, or @code{ABS}.  This category also includes value extension
(sign or zero) and conversions between integer and floating point.

@item RTX_COMM_ARITH
An RTX code for a commutative binary operation, such as @code{PLUS} or
@code{AND}.  @code{NE} and @code{EQ} are comparisons, so they have class
@code{<}.

@item RTX_BIN_ARITH
An RTX code for a non-commutative binary operation, such as @code{MINUS},
@code{DIV}, or @code{ASHIFTRT}.

@item RTX_BITFIELD_OPS
An RTX code for a bit-field operation.  Currently only
@code{ZERO_EXTRACT} and @code{SIGN_EXTRACT}.  These have three inputs
and are lvalues (so they can be used for insertion as well).
@xref{Bit-Fields}.

@item RTX_TERNARY
An RTX code for other three input operations.  Currently only
@code{IF_THEN_ELSE},  @code{VEC_MERGE}, @code{SIGN_EXTRACT},
@code{ZERO_EXTRACT}, and @code{FMA}.

@item RTX_INSN
An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and
@code{CALL_INSN}.  @xref{Insns}.

@item RTX_MATCH
An RTX code for something that matches in insns, such as
@code{MATCH_DUP}.  These only occur in machine descriptions.

@item RTX_AUTOINC
An RTX code for an auto-increment addressing mode, such as
@code{POST_INC}.  @samp{XEXP (@var{x}, 0)} gives the auto-modified
register.

@item RTX_EXTRA
All other RTX codes.  This category includes the remaining codes used
only in machine descriptions (@code{DEFINE_*}, etc.).  It also includes
all the codes describing side effects (@code{SET}, @code{USE},
@code{CLOBBER}, etc.) and the non-insns that may appear on an insn
chain, such as @code{NOTE}, @code{BARRIER}, and @code{CODE_LABEL}.
@code{SUBREG} is also part of this class.
@end table

@cindex RTL format
For each expression code, @file{rtl.def} specifies the number of
contained objects and their kinds using a sequence of characters
called the @dfn{format} of the expression code.  For example,
the format of @code{subreg} is @samp{ei}.

@cindex RTL format characters
These are the most commonly used format characters:

@table @code
@item e
An expression (actually a pointer to an expression).

@item i
An integer.

@item w
A wide integer.

@item s
A string.

@item E
A vector of expressions.
@end table

A few other format characters are used occasionally:

@table @code
@item u
@samp{u} is equivalent to @samp{e} except that it is printed differently
in debugging dumps.  It is used for pointers to insns.

@item n
@samp{n} is equivalent to @samp{i} except that it is printed differently
in debugging dumps.  It is used for the line number or code number of a
@code{note} insn.

@item S
@samp{S} indicates a string which is optional.  In the RTL objects in
core, @samp{S} is equivalent to @samp{s}, but when the object is read,
from an @samp{md} file, the string value of this operand may be omitted.
An omitted string is taken to be the null string.

@item V
@samp{V} indicates a vector which is optional.  In the RTL objects in
core, @samp{V} is equivalent to @samp{E}, but when the object is read
from an @samp{md} file, the vector value of this operand may be omitted.
An omitted vector is effectively the same as a vector of no elements.

@item B
@samp{B} indicates a pointer to basic block structure.

@item 0
@samp{0} means a slot whose contents do not fit any normal category.
@samp{0} slots are not printed at all in dumps, and are often used in
special ways by small parts of the compiler.
@end table

There are macros to get the number of operands and the format
of an expression code:

@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
Number of operands of an RTX of code @var{code}.

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
The format of an RTX of code @var{code}, as a C string.
@end table

Some classes of RTX codes always have the same format.  For example, it
is safe to assume that all comparison operations have format @code{ee}.

@table @code
@item 1
All codes of this class have format @code{e}.

@item <
@itemx c
@itemx 2
All codes of these classes have format @code{ee}.

@item b
@itemx 3
All codes of these classes have format @code{eee}.

@item i
All codes of this class have formats that begin with @code{iuueiee}.
@xref{Insns}.  Note that not all RTL objects linked onto an insn chain
are of class @code{i}.

@item o
@itemx m
@itemx x
You can make no assumptions about the format of these codes.
@end table

@node Accessors
@section Access to Operands
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
式中のオペランドは、@code{XEXP} や @code{XINT}、@code{XWINT}、それに
@code{XSTR} というマクロを使って参照することができる。これらのマクロは
それぞれ引数を二つ取る。RTL式のポインタ(RTX) とオペランドの番号である。
オペランドの番号は 0 からはじまる。例えば、

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
とあれば、式 @var{x} の二番目のオペランドを式として参照する。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
こちらは、同じオペランドを整数として参照する。同様に、@code{XSTR} を
使うと文字列として参照する。

どんなオペランドも整数として、あるいは式として、また文字列として
参照できる。ユーザは、オペランドに実際貯えられている値の種類に
応じて、正しい参照方法を選ばなければならない。これは、
オペランドを含んでいる式の式コードを見て判断するのが良い。
また、オペランド数を調べるのも式コードで調べることができる。

例えば、@var{x} が @code{subreg} 式なら、オペランドは二つあり、
それぞれ @code{XEXP (@var{x}, 0)} と @code{XINT (@var{x}, 0)} として
正しく参照できる。@code{XINT (@var{x}, 0)} とすると、
オペランド 0 の式のアドレスを整数にキャストしたものが得られる。
こういう参照の仕方が有効な場合は滅多にないと思うが、もし書くなら
@code{(int) XEXP (@var{x}, 0)} としたほうがきれいである。
また @code{XEXP (@var{x}, 1)} という書き方もエラー無しでコンパイル
できて、二番目の整数オペランドを式のポインタにキャストした結果を
返す。しかし、それを参照したときに恐らくプログラムが落ちてしまう。
さらには、@code{XEXP (@var{x}, 28)} のように書くこともできるが、
式の終りを越えたメモリをアクセスし、予期できない結果に終わるだろう。

オペランドがベクトルの場合の参照方法はもっと複雑である。
マクロ @code{XVEC} を使うとベクトルへのポインタそのものが得られ、
@code{XVECEXP} と @code{XVECLEN} を使うとそれぞれ、ベクトルの要素と
長さを得ることができる。

@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドを
ベクトルへのポインタとして参照する。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの長さを返す。
この値は @code{int} 型である。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの @var{eltnum}
番目の要素を参照する。この値は RTX である。

@var{eltnum} が負でないことおよび @code{XVECLEN (@var{exp}, @var{idx})}
より小さいことを保証するのはユーザの責任である。
@end table

このセクションで定義したマクロは全て左辺値として展開されるので、
単に参照するだけでなく、オペランドや長さやベクトルの要素を代入する
ことができる。

@node Flags
@section Flags in an RTL Expression
@cindex flags in RTL expression

RTL expressions contain several flags (one-bit bit-fields)
that are used in certain types of expression.  Most often they
are accessed with the following macros, which expand into lvalues.

@table @code
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
Nonzero in a @code{symbol_ref} if it refers to part of the current
function's constant pool.  For most targets these addresses are in a
@code{.rodata} section entirely separate from the function, but for
some targets the addresses are close to the beginning of the function.
In either case GCC assumes these addresses can be addressed directly,
perhaps with the help of base registers.
Stored in the @code{unchanging} field and printed as @samp{/u}.

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a call to a
const function.  Stored in the @code{unchanging} field and printed as
@samp{/u}.

@findex RTL_PURE_CALL_P
@cindex @code{call_insn} and @samp{/i}
@cindex @code{return_val}, in @code{call_insn}
@item RTL_PURE_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a call to a
pure function.  Stored in the @code{return_val} field and printed as
@samp{/i}.

@findex RTL_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/u} or @samp{/i}
@item RTL_CONST_OR_PURE_CALL_P (@var{x})
In a @code{call_insn}, true if @code{RTL_CONST_CALL_P} or
@code{RTL_PURE_CALL_P} is true.

@findex RTL_LOOPING_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/c}
@cindex @code{call}, in @code{call_insn}
@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a possibly
infinite looping call to a const or pure function.  Stored in the
@code{call} field and printed as @samp{/c}.  Only true if one of
@code{RTL_CONST_CALL_P} or @code{RTL_PURE_CALL_P} is true.

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
In a @code{jump_insn}, @code{call_insn}, or @code{insn} indicates
that the branch is an annulling one.  See the discussion under
@code{sequence} below.  Stored in the @code{unchanging} field and
printed as @samp{/u}.

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{jump_table_data} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{jump_table_data}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
In an @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label},
@code{jump_table_data}, @code{barrier}, or @code{note},
nonzero if the insn has been deleted.  Stored in the
@code{volatil} field and printed as @samp{/v}.

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
In an @code{insn} or @code{jump_insn} or @code{call_insn} in a delay
slot of a branch, indicates that the insn
is from the target of the branch.  If the branch insn has
@code{INSN_ANNULLED_BRANCH_P} set, this insn will only be executed if
the branch is taken.  For annulled branches with
@code{INSN_FROM_TARGET_P} clear, the insn will be executed only if the
branch is not taken.  When @code{INSN_ANNULLED_BRANCH_P} is not set,
this insn will always be executed.  Stored in the @code{in_struct}
field and printed as @samp{/s}.

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
In a @code{code_label} or @code{note}, indicates that the label is referenced by
code or data not visible to the RTL of a given function.
Labels referenced by a non-local goto will have this bit set.  Stored
in the @code{in_struct} field and printed as @samp{/s}.

@findex LABEL_REF_NONLOCAL_P
@cindex @code{label_ref} and @samp{/v}
@cindex @code{reg_label} and @samp{/v}
@cindex @code{volatil}, in @code{label_ref} and @code{reg_label}
@item LABEL_REF_NONLOCAL_P (@var{x})
In @code{label_ref} and @code{reg_label} expressions, nonzero if this is
a reference to a non-local label.
Stored in the @code{volatil} field and printed as @samp{/v}.

@findex MEM_KEEP_ALIAS_SET_P
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_KEEP_ALIAS_SET_P (@var{x})
In @code{mem} expressions, 1 if we should keep the alias set for this
mem unchanged when we access a component.  Set to 1, for example, when we
are already in a non-addressable component of an aggregate.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
In @code{mem}, @code{asm_operands}, and @code{asm_input} expressions,
nonzero for volatile memory references.
Stored in the @code{volatil} field and printed as @samp{/v}.

@findex MEM_NOTRAP_P
@cindex @code{mem} and @samp{/c}
@cindex @code{call}, in @code{mem}
@item MEM_NOTRAP_P (@var{x})
In @code{mem}, nonzero for memory references that will not trap.
Stored in the @code{call} field and printed as @samp{/c}.

@findex MEM_POINTER
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in @code{mem}
@item MEM_POINTER (@var{x})
Nonzero in a @code{mem} if the memory reference holds a pointer.
Stored in the @code{frame_related} field and printed as @samp{/f}.

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
Nonzero in a @code{reg} if it is the place in which this function's
value is going to be returned.  (This happens only in a hard
register.)  Stored in the @code{return_val} field and printed as
@samp{/i}.

@findex REG_POINTER
@cindex @code{reg} and @samp{/f}
@cindex @code{frame_related}, in @code{reg}
@item REG_POINTER (@var{x})
Nonzero in a @code{reg} if the register holds a pointer.  Stored in the
@code{frame_related} field and printed as @samp{/f}.

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
In a @code{reg}, nonzero if it corresponds to a variable present in
the user's source code.  Zero for temporaries generated internally by
the compiler.  Stored in the @code{volatil} field and printed as
@samp{/v}.

The same hard register may be used also for collecting the values of
functions called by this one, but @code{REG_FUNCTION_VALUE_P} is zero
in this kind of use.

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
Nonzero in an @code{insn}, @code{call_insn}, @code{jump_insn},
@code{barrier}, or @code{set} which is part of a function prologue
and sets the stack pointer, sets the frame pointer, or saves a register.
This flag should also be set on an instruction that sets up a temporary
register to use in place of the frame pointer.
Stored in the @code{frame_related} field and printed as @samp{/f}.

In particular, on RISC targets where there are limits on the sizes of
immediate constants, it is sometimes impossible to reach the register
save area directly from the stack pointer.  In that case, a temporary
register is used that is near enough to the register save area, and the
Canonical Frame Address, i.e., DWARF2's logical frame pointer, register
must (temporarily) be changed to be this temporary register.  So, the
instruction that sets this temporary register must be marked as
@code{RTX_FRAME_RELATED_P}.

If the marked instruction is overly complex (defined in terms of what
@code{dwarf2out_frame_debug_expr} can handle), you will also have to
create a @code{REG_FRAME_RELATED_EXPR} note and attach it to the
instruction.  This note should contain a simple expression of the
computation performed by this instruction, i.e., one that
@code{dwarf2out_frame_debug_expr} can handle.

This flag is required for exception handling support on targets with RTL
prologues.

@findex MEM_READONLY_P
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{mem}
@item MEM_READONLY_P (@var{x})
Nonzero in a @code{mem}, if the memory is statically allocated and read-only.

Read-only in this context means never modified during the lifetime of the
program, not necessarily in ROM or in write-disabled pages.  A common
example of the later is a shared library's global offset table.  This
table is initialized by the runtime loader, so the memory is technically
writable, but after control is transferred from the runtime loader to the
application, this memory will never be subsequently modified.

Stored in the @code{unchanging} field and printed as @samp{/u}.

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{jump_table_data} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{call_insn}, @code{jump_insn} and @code{jump_table_data}
@item SCHED_GROUP_P (@var{x})
During instruction scheduling, in an @code{insn}, @code{call_insn},
@code{jump_insn} or @code{jump_table_data}, indicates that the
previous insn must be scheduled together with this insn.  This is used to
ensure that certain groups of instructions will not be split up by the
instruction scheduling pass, for example, @code{use} insns before
a @code{call_insn} may not be separated from the @code{call_insn}.
Stored in the @code{in_struct} field and printed as @samp{/s}.

@findex SET_IS_RETURN_P
@cindex @code{insn} and @samp{/j}
@cindex @code{jump}, in @code{insn}
@item SET_IS_RETURN_P (@var{x})
For a @code{set}, nonzero if it is for a return.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex SIBLING_CALL_P
@cindex @code{call_insn} and @samp{/j}
@cindex @code{jump}, in @code{call_insn}
@item SIBLING_CALL_P (@var{x})
For a @code{call_insn}, nonzero if the insn is a sibling call.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex STRING_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/f}
@cindex @code{frame_related}, in @code{symbol_ref}
@item STRING_POOL_ADDRESS_P (@var{x})
For a @code{symbol_ref} expression, nonzero if it addresses this function's
string constant pool.
Stored in the @code{frame_related} field and printed as @samp{/f}.

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
Returns a value greater then zero for a @code{subreg} that has
@code{SUBREG_PROMOTED_VAR_P} nonzero if the object being referenced is kept
zero-extended, zero if it is kept sign-extended, and less then zero if it is
extended some other way via the @code{ptr_extend} instruction.
Stored in the @code{unchanging}
field and @code{volatil} field, printed as @samp{/u} and @samp{/v}.
This macro may only be used to get the value it may not be used to change
the value.  Use @code{SUBREG_PROMOTED_UNSIGNED_SET} to change the value.

@findex SUBREG_PROMOTED_UNSIGNED_SET
@cindex @code{subreg} and @samp{/u}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_SET (@var{x})
Set the @code{unchanging} and @code{volatil} fields in a @code{subreg}
to reflect zero, sign, or other extension.  If @code{volatil} is
zero, then @code{unchanging} as nonzero means zero extension and as
zero means sign extension.  If @code{volatil} is nonzero then some
other type of extension was done via the @code{ptr_extend} instruction.

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
Nonzero in a @code{subreg} if it was made when accessing an object that
was promoted to a wider mode in accord with the @code{PROMOTED_MODE} machine
description macro (@pxref{Storage Layout}).  In this case, the mode of
the @code{subreg} is the declared mode of the object and the mode of
@code{SUBREG_REG} is the mode of the register that holds the object.
Promoted variables are always either sign- or zero-extended to the wider
mode on every assignment.  Stored in the @code{in_struct} field and
printed as @samp{/s}.

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
In a @code{symbol_ref}, indicates that @var{x} has been used.  This is
normally only used to ensure that @var{x} is only declared external
once.  Stored in the @code{used} field.

@findex SYMBOL_REF_WEAK
@cindex @code{symbol_ref} and @samp{/i}
@cindex @code{return_val}, in @code{symbol_ref}
@item SYMBOL_REF_WEAK (@var{x})
In a @code{symbol_ref}, indicates that @var{x} has been declared weak.
Stored in the @code{return_val} field and printed as @samp{/i}.

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
In a @code{symbol_ref}, this is used as a flag for machine-specific purposes.
Stored in the @code{volatil} field and printed as @samp{/v}.

Most uses of @code{SYMBOL_REF_FLAG} are historic and may be subsumed
by @code{SYMBOL_REF_FLAGS}.  Certainly use of @code{SYMBOL_REF_FLAGS}
is mandatory if the target requires more than one bit of storage.

@findex PREFETCH_SCHEDULE_BARRIER_P
@cindex @code{prefetch} and @samp{/v}
@cindex @code{volatile}, in @code{prefetch}
@item PREFETCH_SCHEDULE_BARRIER_P (@var{x})
In a @code{prefetch}, indicates that the prefetch is a scheduling barrier.
No other INSNs will be moved over it.
Stored in the @code{volatil} field and printed as @samp{/v}.
@end table

These are the fields to which the above macros refer:

@table @code
@findex call
@cindex @samp{/c} in RTL dump
@item call
In a @code{mem}, 1 means that the memory reference will not trap.

In a @code{call}, 1 means that this pure or const call may possibly
infinite loop.

In an RTL dump, this flag is represented as @samp{/c}.

@findex frame_related
@cindex @samp{/f} in RTL dump
@item frame_related
In an @code{insn} or @code{set} expression, 1 means that it is part of
a function prologue and sets the stack pointer, sets the frame pointer,
saves a register, or sets up a temporary register to use in place of the
frame pointer.

In @code{reg} expressions, 1 means that the register holds a pointer.

In @code{mem} expressions, 1 means that the memory reference holds a pointer.

In @code{symbol_ref} expressions, 1 means that the reference addresses
this function's string constant pool.

In an RTL dump, this flag is represented as @samp{/f}.

@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
In @code{reg} expressions, it is 1 if the register has its entire life
contained within the test expression of some loop.

In @code{subreg} expressions, 1 means that the @code{subreg} is accessing
an object that has had its mode promoted from a wider mode.

In @code{label_ref} expressions, 1 means that the referenced label is
outside the innermost loop containing the insn in which the @code{label_ref}
was found.

In @code{code_label} expressions, it is 1 if the label may never be deleted.
This is used for labels which are the target of non-local gotos.  Such a
label that would have been deleted is replaced with a @code{note} of type
@code{NOTE_INSN_DELETED_LABEL}.

In an @code{insn} during dead-code elimination, 1 means that the insn is
dead code.

In an @code{insn} or @code{jump_insn} during reorg for an insn in the
delay slot of a branch,
1 means that this insn is from the target of the branch.

In an @code{insn} during instruction scheduling, 1 means that this insn
must be scheduled as part of a group together with the previous insn.

In an RTL dump, this flag is represented as @samp{/s}.

@findex return_val
@cindex @samp{/i} in RTL dump
@item return_val
In @code{reg} expressions, 1 means the register contains
the value to be returned by the current function.  On
machines that pass parameters in registers, the same register number
may be used for parameters as well, but this flag is not set on such
uses.

In @code{symbol_ref} expressions, 1 means the referenced symbol is weak.

In @code{call} expressions, 1 means the call is pure.

In an RTL dump, this flag is represented as @samp{/i}.

@findex jump
@cindex @samp{/j} in RTL dump
@item jump
In a @code{mem} expression, 1 means we should keep the alias set for this
mem unchanged when we access a component.

In a @code{set}, 1 means it is for a return.

In a @code{call_insn}, 1 means it is a sibling call.

In an RTL dump, this flag is represented as @samp{/j}.

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
In @code{reg} and @code{mem} expressions, 1 means
that the value of the expression never changes.

In @code{subreg} expressions, it is 1 if the @code{subreg} references an
unsigned object whose mode has been promoted to a wider mode.

In an @code{insn} or @code{jump_insn} in the delay slot of a branch
instruction, 1 means an annulling branch should be used.

In a @code{symbol_ref} expression, 1 means that this symbol addresses
something in the per-function constant pool.

In a @code{call_insn} 1 means that this instruction is a call to a const
function.

In an RTL dump, this flag is represented as @samp{/u}.

@findex used
@item used
This flag is used directly (without an access macro) at the end of RTL
generation for a function, to count the number of times an expression
appears in insns.  Expressions that appear more than once are copied,
according to the rules for shared structure (@pxref{Sharing}).

For a @code{reg}, it is used directly (without an access macro) by the
leaf register renumbering code to ensure that each register is only
renumbered once.

In a @code{symbol_ref}, it indicates that an external declaration for
the symbol has already been written.

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
In a @code{mem}, @code{asm_operands}, or @code{asm_input}
expression, it is 1 if the memory
reference is volatile.  Volatile memory references may not be deleted,
reordered or combined.

In a @code{symbol_ref} expression, it is used for machine-specific
purposes.

In a @code{reg} expression, it is 1 if the value is a user-level variable.
0 indicates an internal compiler temporary.

In an @code{insn}, 1 means the insn has been deleted.

In @code{label_ref} and @code{reg_label} expressions, 1 means a reference
to a non-local label.

In @code{prefetch} expressions, 1 means that the containing insn is a
scheduling barrier.

In an RTL dump, this flag is represented as @samp{/v}.
@end table

@node Machine Modes
@section Machine Modes
@cindex machine modes

@findex machine_mode
A machine mode describes a size of data object and the representation used
for it.  In the C code, machine modes are represented by an enumeration
type, @code{machine_mode}, defined in @file{machmode.def}.  Each RTL
expression has room for a machine mode and so do certain kinds of tree
expressions (declarations and types, to be precise).

In debugging dumps and machine descriptions, the machine mode of an RTL
expression is written after the expression code with a colon to separate
them.  The letters @samp{mode} which appear at the end of each machine mode
name are omitted.  For example, @code{(reg:SI 38)} is a @code{reg}
expression with machine mode @code{SImode}.  If the mode is
@code{VOIDmode}, it is not written at all.

Here is a table of machine modes.  The term ``byte'' below refers to an
object of @code{BITS_PER_UNIT} bits (@pxref{Storage Layout}).

@table @code
@findex BImode
@item BImode
``Bit'' mode represents a single bit, for predicate registers.

@findex QImode
@item QImode
``Quarter-Integer'' mode represents a single byte treated as an integer.

@findex HImode
@item HImode
``Half-Integer'' mode represents a two-byte integer.

@findex PSImode
@item PSImode
``Partial Single Integer'' mode represents an integer which occupies
four bytes but which doesn't really use all four.  On some machines,
this is the right mode to use for pointers.

@findex SImode
@item SImode
``Single Integer'' mode represents a four-byte integer.

@findex PDImode
@item PDImode
``Partial Double Integer'' mode represents an integer which occupies
eight bytes but which doesn't really use all eight.  On some machines,
this is the right mode to use for certain pointers.

@findex DImode
@item DImode
``Double Integer'' mode represents an eight-byte integer.

@findex TImode
@item TImode
``Tetra Integer'' (?) mode represents a sixteen-byte integer.

@findex OImode
@item OImode
``Octa Integer'' (?) mode represents a thirty-two-byte integer.

@findex XImode
@item XImode
``Hexadeca Integer'' (?) mode represents a sixty-four-byte integer.

@findex QFmode
@item QFmode
``Quarter-Floating'' mode represents a quarter-precision (single byte)
floating point number.

@findex HFmode
@item HFmode
``Half-Floating'' mode represents a half-precision (two byte) floating
point number.

@findex TQFmode
@item TQFmode
``Three-Quarter-Floating'' (?) mode represents a three-quarter-precision
(three byte) floating point number.

@findex SFmode
@item SFmode
``Single Floating'' mode represents a four byte floating point number.
In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
this is a single-precision IEEE floating point number; it can also be
used for double-precision (on processors with 16-bit bytes) and
single-precision VAX and IBM types.

@findex DFmode
@item DFmode
``Double Floating'' mode represents an eight byte floating point number.
In the common case, of a processor with IEEE arithmetic and 8-bit bytes,
this is a double-precision IEEE floating point number.

@findex XFmode
@item XFmode
``Extended Floating'' mode represents an IEEE extended floating point
number.  This mode only has 80 meaningful bits (ten bytes).  Some
processors require such numbers to be padded to twelve bytes, others
to sixteen; this mode is used for either.

@findex SDmode
@item SDmode
``Single Decimal Floating'' mode represents a four byte decimal
floating point number (as distinct from conventional binary floating
point).

@findex DDmode
@item DDmode
``Double Decimal Floating'' mode represents an eight byte decimal
floating point number.

@findex TDmode
@item TDmode
``Tetra Decimal Floating'' mode represents a sixteen byte decimal
floating point number all 128 of whose bits are meaningful.

@findex TFmode
@item TFmode
``Tetra Floating'' mode represents a sixteen byte floating point number
all 128 of whose bits are meaningful.  One common use is the
IEEE quad-precision format.

@findex QQmode
@item QQmode
``Quarter-Fractional'' mode represents a single byte treated as a signed
fractional number.  The default format is ``s.7''.

@findex HQmode
@item HQmode
``Half-Fractional'' mode represents a two-byte signed fractional number.
The default format is ``s.15''.

@findex SQmode
@item SQmode
``Single Fractional'' mode represents a four-byte signed fractional number.
The default format is ``s.31''.

@findex DQmode
@item DQmode
``Double Fractional'' mode represents an eight-byte signed fractional number.
The default format is ``s.63''.

@findex TQmode
@item TQmode
``Tetra Fractional'' mode represents a sixteen-byte signed fractional number.
The default format is ``s.127''.

@findex UQQmode
@item UQQmode
``Unsigned Quarter-Fractional'' mode represents a single byte treated as an
unsigned fractional number.  The default format is ``.8''.

@findex UHQmode
@item UHQmode
``Unsigned Half-Fractional'' mode represents a two-byte unsigned fractional
number.  The default format is ``.16''.

@findex USQmode
@item USQmode
``Unsigned Single Fractional'' mode represents a four-byte unsigned fractional
number.  The default format is ``.32''.

@findex UDQmode
@item UDQmode
``Unsigned Double Fractional'' mode represents an eight-byte unsigned
fractional number.  The default format is ``.64''.

@findex UTQmode
@item UTQmode
``Unsigned Tetra Fractional'' mode represents a sixteen-byte unsigned
fractional number.  The default format is ``.128''.

@findex HAmode
@item HAmode
``Half-Accumulator'' mode represents a two-byte signed accumulator.
The default format is ``s8.7''.

@findex SAmode
@item SAmode
``Single Accumulator'' mode represents a four-byte signed accumulator.
The default format is ``s16.15''.

@findex DAmode
@item DAmode
``Double Accumulator'' mode represents an eight-byte signed accumulator.
The default format is ``s32.31''.

@findex TAmode
@item TAmode
``Tetra Accumulator'' mode represents a sixteen-byte signed accumulator.
The default format is ``s64.63''.

@findex UHAmode
@item UHAmode
``Unsigned Half-Accumulator'' mode represents a two-byte unsigned accumulator.
The default format is ``8.8''.

@findex USAmode
@item USAmode
``Unsigned Single Accumulator'' mode represents a four-byte unsigned
accumulator.  The default format is ``16.16''.

@findex UDAmode
@item UDAmode
``Unsigned Double Accumulator'' mode represents an eight-byte unsigned
accumulator.  The default format is ``32.32''.

@findex UTAmode
@item UTAmode
``Unsigned Tetra Accumulator'' mode represents a sixteen-byte unsigned
accumulator.  The default format is ``64.64''.

@findex CCmode
@item CCmode
``Condition Code'' mode represents the value of a condition code, which
is a machine-specific set of bits used to represent the result of a
comparison operation.  Other machine-specific modes may also be used for
the condition code.  These modes are not used on machines that use
@code{cc0} (@pxref{Condition Code}).

@findex BLKmode
@item BLKmode
``Block'' mode represents values that are aggregates to which none of
the other modes apply.  In RTL, only memory references can have this mode,
and only if they appear in string-move or vector instructions.  On machines
which have no such instructions, @code{BLKmode} will not appear in RTL@.

@findex VOIDmode
@item VOIDmode
Void mode means the absence of a mode or an unspecified mode.
For example, RTL expressions of code @code{const_int} have mode
@code{VOIDmode} because they can be taken to have whatever mode the context
requires.  In debugging dumps of RTL, @code{VOIDmode} is expressed by
the absence of any mode.

@findex QCmode
@findex HCmode
@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item QCmode, HCmode, SCmode, DCmode, XCmode, TCmode
These modes stand for a complex number represented as a pair of floating
point values.  The floating point values are in @code{QFmode},
@code{HFmode}, @code{SFmode}, @code{DFmode}, @code{XFmode}, and
@code{TFmode}, respectively.

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
These modes stand for a complex number represented as a pair of integer
values.  The integer values are in @code{QImode}, @code{HImode},
@code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},
respectively.

@findex BND32mode
@findex BND64mode
@item BND32mode BND64mode
These modes stand for bounds for pointer of 32 and 64 bit size respectively.
Mode size is double pointer mode size.
@end table

The machine description defines @code{Pmode} as a C macro which expands
into the machine mode used for addresses.  Normally this is the mode
whose size is @code{BITS_PER_WORD}, @code{SImode} on 32-bit machines.

The only modes which a machine description @i{must} support are
@code{QImode}, and the modes corresponding to @code{BITS_PER_WORD},
@code{FLOAT_TYPE_SIZE} and @code{DOUBLE_TYPE_SIZE}.
The compiler will attempt to use @code{DImode} for 8-byte structures and
unions, but this can be prevented by overriding the definition of
@code{MAX_FIXED_MODE_SIZE}.  Alternatively, you can have the compiler
use @code{TImode} for 16-byte structures and unions.  Likewise, you can
arrange for the C type @code{short int} to avoid using @code{HImode}.

@cindex mode classes
Very few explicit references to machine modes remain in the compiler and
these few references will soon be removed.  Instead, the machine modes
are divided into mode classes.  These are represented by the enumeration
type @code{enum mode_class} defined in @file{machmode.h}.  The possible
mode classes are:

@table @code
@findex MODE_INT
@item MODE_INT
Integer modes.  By default these are @code{BImode}, @code{QImode},
@code{HImode}, @code{SImode}, @code{DImode}, @code{TImode}, and
@code{OImode}.

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
The ``partial integer'' modes, @code{PQImode}, @code{PHImode},
@code{PSImode} and @code{PDImode}.

@findex MODE_FLOAT
@item MODE_FLOAT
Floating point modes.  By default these are @code{QFmode},
@code{HFmode}, @code{TQFmode}, @code{SFmode}, @code{DFmode},
@code{XFmode} and @code{TFmode}.

@findex MODE_DECIMAL_FLOAT
@item MODE_DECIMAL_FLOAT
Decimal floating point modes.  By default these are @code{SDmode},
@code{DDmode} and @code{TDmode}.

@findex MODE_FRACT
@item MODE_FRACT
Signed fractional modes.  By default these are @code{QQmode}, @code{HQmode},
@code{SQmode}, @code{DQmode} and @code{TQmode}.

@findex MODE_UFRACT
@item MODE_UFRACT
Unsigned fractional modes.  By default these are @code{UQQmode}, @code{UHQmode},
@code{USQmode}, @code{UDQmode} and @code{UTQmode}.

@findex MODE_ACCUM
@item MODE_ACCUM
Signed accumulator modes.  By default these are @code{HAmode},
@code{SAmode}, @code{DAmode} and @code{TAmode}.

@findex MODE_UACCUM
@item MODE_UACCUM
Unsigned accumulator modes.  By default these are @code{UHAmode},
@code{USAmode}, @code{UDAmode} and @code{UTAmode}.

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
Complex integer modes.  (These are not currently implemented).

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
Complex floating point modes.  By default these are @code{QCmode},
@code{HCmode}, @code{SCmode}, @code{DCmode}, @code{XCmode}, and
@code{TCmode}.

@findex MODE_FUNCTION
@item MODE_FUNCTION
Algol or Pascal function variables including a static chain.
(These are not currently implemented).

@findex MODE_CC
@item MODE_CC
Modes representing condition code values.  These are @code{CCmode} plus
any @code{CC_MODE} modes listed in the @file{@var{machine}-modes.def}.
@xref{Jump Patterns},
also see @ref{Condition Code}.

@findex MODE_POINTER_BOUNDS
@item MODE_POINTER_BOUNDS
Pointer bounds modes.  Used to represent values of pointer bounds type.
Operations in these modes may be executed as NOPs depending on hardware
features and environment setup.

@findex MODE_RANDOM
@item MODE_RANDOM
This is a catchall mode class for modes which don't fit into the above
classes.  Currently @code{VOIDmode} and @code{BLKmode} are in
@code{MODE_RANDOM}.
@end table

Here are some C macros that relate to machine modes:

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
Returns the machine mode of the RTX @var{x}.

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
Alters the machine mode of the RTX @var{x} to be @var{newmode}.

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
Stands for the number of machine modes available on the target
machine.  This is one greater than the largest numeric value of any
machine mode.

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
Returns the name of mode @var{m} as a string.

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
Returns the mode class of mode @var{m}.

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
Returns the next wider natural mode.  For example, the expression
@code{GET_MODE_WIDER_MODE (QImode)} returns @code{HImode}.

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
Returns the size in bytes of a datum of mode @var{m}.

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
Returns the size in bits of a datum of mode @var{m}.

@findex GET_MODE_IBIT
@item GET_MODE_IBIT (@var{m})
Returns the number of integral bits of a datum of fixed-point mode @var{m}.

@findex GET_MODE_FBIT
@item GET_MODE_FBIT (@var{m})
Returns the number of fractional bits of a datum of fixed-point mode @var{m}.

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
Returns a bitmask containing 1 for all bits in a word that fit within
mode @var{m}.  This macro can only be used for modes whose bitsize is
less than or equal to @code{HOST_BITS_PER_INT}.

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
Return the required alignment, in bits, for an object of mode @var{m}.

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
Returns the size in bytes of the subunits of a datum of mode @var{m}.
This is the same as @code{GET_MODE_SIZE} except in the case of complex
modes.  For them, the unit size is the size of the real or imaginary
part.

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
Returns the number of units contained in a mode, i.e.,
@code{GET_MODE_SIZE} divided by @code{GET_MODE_UNIT_SIZE}.

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
Returns the narrowest mode in mode class @var{c}.
@end table

The following 3 variables are defined on every target.   They can be
used to allocate buffers that are guaranteed to be large enough to
hold any value that can be represented on the target.   The first two
can be overridden by defining them in the target's mode.def file,
however, the value must be a constant that can determined very early
in the compilation process.   The third symbol cannot be overridden.

@table @code
@findex BITS_PER_UNIT
@item BITS_PER_UNIT
The number of bits in an addressable storage unit (byte).  If you do
not define this, the default is 8.

@findex MAX_BITSIZE_MODE_ANY_INT
@item MAX_BITSIZE_MODE_ANY_INT
The maximum bitsize of any mode that is used in integer math.  This
should be overridden by the target if it uses large integers as
containers for larger vectors but otherwise never uses the contents to
compute integer values.

@findex MAX_BITSIZE_MODE_ANY_MODE
@item MAX_BITSIZE_MODE_ANY_MODE
The bitsize of the largest mode on the target.   
@end table

@findex byte_mode
@findex word_mode
The global variables @code{byte_mode} and @code{word_mode} contain modes
whose classes are @code{MODE_INT} and whose bitsizes are either
@code{BITS_PER_UNIT} or @code{BITS_PER_WORD}, respectively.  On 32-bit
machines, these are @code{QImode} and @code{SImode}, respectively.

@node Constants
@section Constant Expression Types
@cindex RTL constants
@cindex RTL constant expression types

The simplest RTL expressions are those that represent constant values.

@table @code
@findex const_int
@item (const_int @var{i})
This type of expression represents the integer value @var{i}.  @var{i}
is customarily accessed with the macro @code{INTVAL} as in
@code{INTVAL (@var{exp})}, which is equivalent to @code{XWINT (@var{exp}, 0)}.

Constants generated for modes with fewer bits than in
@code{HOST_WIDE_INT} must be sign extended to full width (e.g., with
@code{gen_int_mode}).  For constants for modes with more bits than in
@code{HOST_WIDE_INT} the implied high order bits of that constant are
copies of the top bit.  Note however that values are neither
inherently signed nor inherently unsigned; where necessary, signedness
is determined by the rtl operation instead.

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
There is only one expression object for the integer value zero; it is
the value of the variable @code{const0_rtx}.  Likewise, the only
expression for integer value one is found in @code{const1_rtx}, the only
expression for integer value two is found in @code{const2_rtx}, and the
only expression for integer value negative one is found in
@code{constm1_rtx}.  Any attempt to create an expression of code
@code{const_int} and value zero, one, two or negative one will return
@code{const0_rtx}, @code{const1_rtx}, @code{const2_rtx} or
@code{constm1_rtx} as appropriate.

@findex const_true_rtx
Similarly, there is only one object for the integer whose value is
@code{STORE_FLAG_VALUE}.  It is found in @code{const_true_rtx}.  If
@code{STORE_FLAG_VALUE} is one, @code{const_true_rtx} and
@code{const1_rtx} will point to the same object.  If
@code{STORE_FLAG_VALUE} is @minus{}1, @code{const_true_rtx} and
@code{constm1_rtx} will point to the same object.

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
This represents either a floating-point constant of mode @var{m} or
(on older ports that do not define
@code{TARGET_SUPPORTS_WIDE_INT}) an integer constant too large to fit
into @code{HOST_BITS_PER_WIDE_INT} bits but small enough to fit within
twice that number of bits.  In the latter case, @var{m} will be
@code{VOIDmode}.  For integral values constants for modes with more
bits than twice the number in @code{HOST_WIDE_INT} the implied high
order bits of that constant are copies of the top bit of
@code{CONST_DOUBLE_HIGH}.  Note however that integral values are
neither inherently signed nor inherently unsigned; where necessary,
signedness is determined by the rtl operation instead.

On more modern ports, @code{CONST_DOUBLE} only represents floating
point values.  New ports define @code{TARGET_SUPPORTS_WIDE_INT} to
make this designation.

@findex CONST_DOUBLE_LOW
If @var{m} is @code{VOIDmode}, the bits of the value are stored in
@var{i0} and @var{i1}.  @var{i0} is customarily accessed with the macro
@code{CONST_DOUBLE_LOW} and @var{i1} with @code{CONST_DOUBLE_HIGH}.

If the constant is floating point (regardless of its precision), then
the number of integers used to store the value depends on the size of
@code{REAL_VALUE_TYPE} (@pxref{Floating Point}).  The integers
represent a floating point number, but not precisely in the target
machine's or host machine's floating point format.  To convert them to
the precise bit pattern used by the target machine, use the macro
@code{REAL_VALUE_TO_TARGET_DOUBLE} and friends (@pxref{Data Output}).

@findex CONST_WIDE_INT
@item (const_wide_int:@var{m} @var{nunits} @var{elt0} @dots{})
This contains an array of @code{HOST_WIDE_INT}s that is large enough
to hold any constant that can be represented on the target.  This form
of rtl is only used on targets that define
@code{TARGET_SUPPORTS_WIDE_INT} to be nonzero and then
@code{CONST_DOUBLE}s are only used to hold floating-point values.  If
the target leaves @code{TARGET_SUPPORTS_WIDE_INT} defined as 0,
@code{CONST_WIDE_INT}s are not used and @code{CONST_DOUBLE}s are as
they were before.

The values are stored in a compressed format.  The higher-order
0s or -1s are not represented if they are just the logical sign
extension of the number that is represented.

@findex CONST_WIDE_INT_VEC
@item CONST_WIDE_INT_VEC (@var{code})
Returns the entire array of @code{HOST_WIDE_INT}s that are used to
store the value.  This macro should be rarely used.

@findex CONST_WIDE_INT_NUNITS
@item CONST_WIDE_INT_NUNITS (@var{code})
The number of @code{HOST_WIDE_INT}s used to represent the number.
Note that this generally is smaller than the number of
@code{HOST_WIDE_INT}s implied by the mode size.

@findex CONST_WIDE_INT_ELT
@item CONST_WIDE_INT_NUNITS (@var{code},@var{i})
Returns the @code{i}th element of the array.   Element 0 is contains
the low order bits of the constant.

@findex const_fixed
@item (const_fixed:@var{m} @dots{})
Represents a fixed-point constant of mode @var{m}.
The operand is a data structure of type @code{struct fixed_value} and
is accessed with the macro @code{CONST_FIXED_VALUE}.  The high part of
data is accessed with @code{CONST_FIXED_VALUE_HIGH}; the low part is
accessed with @code{CONST_FIXED_VALUE_LOW}.

@findex const_vector
@item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])
Represents a vector constant.  The square brackets stand for the vector
containing the constant elements.  @var{x0}, @var{x1} and so on are
the @code{const_int}, @code{const_double} or @code{const_fixed} elements.

The number of units in a @code{const_vector} is obtained with the macro
@code{CONST_VECTOR_NUNITS} as in @code{CONST_VECTOR_NUNITS (@var{v})}.

Individual elements in a vector constant are accessed with the macro
@code{CONST_VECTOR_ELT} as in @code{CONST_VECTOR_ELT (@var{v}, @var{n})}
where @var{v} is the vector constant and @var{n} is the element
desired.

@findex const_string
@item (const_string @var{str})
Represents a constant string with value @var{str}.  Currently this is
used only for insn attributes (@pxref{Insn Attributes}) since constant
strings in C are placed in memory.

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
Represents the value of an assembler label for data.  @var{symbol} is
a string that describes the name of the assembler label.  If it starts
with a @samp{*}, the label is the rest of @var{symbol} not including
the @samp{*}.  Otherwise, the label is @var{symbol}, usually prefixed
with @samp{_}.

The @code{symbol_ref} contains a mode, which is usually @code{Pmode}.
Usually that is the only mode for which a symbol is directly valid.

@findex label_ref
@item (label_ref:@var{mode} @var{label})
Represents the value of an assembler label for code.  It contains one
operand, an expression, which must be a @code{code_label} or a @code{note}
of type @code{NOTE_INSN_DELETED_LABEL} that appears in the instruction
sequence to identify the place where the label should go.

The reason for using a distinct expression type for code label
references is so that jump optimization can distinguish them.

The @code{label_ref} contains a mode, which is usually @code{Pmode}.
Usually that is the only mode for which a label is directly valid.

@findex const
@item (const:@var{m} @var{exp})
Represents a constant that is the result of an assembly-time
arithmetic computation.  The operand, @var{exp}, is an expression that
contains only constants (@code{const_int}, @code{symbol_ref} and
@code{label_ref} expressions) combined with @code{plus} and
@code{minus}.  However, not all combinations are valid, since the
assembler cannot do arbitrary arithmetic on relocatable symbols.

@var{m} should be @code{Pmode}.

@findex high
@item (high:@var{m} @var{exp})
Represents the high-order bits of @var{exp}, usually a
@code{symbol_ref}.  The number of bits is machine-dependent and is
normally the number of bits specified in an instruction that initializes
the high order bits of a register.  It is used with @code{lo_sum} to
represent the typical two-instruction sequence used in RISC machines to
reference a global memory location.

@var{m} should be @code{Pmode}.
@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
The macro @code{CONST0_RTX (@var{mode})} refers to an expression with
value 0 in mode @var{mode}.  If mode @var{mode} is of mode class
@code{MODE_INT}, it returns @code{const0_rtx}.  If mode @var{mode} is of
mode class @code{MODE_FLOAT}, it returns a @code{CONST_DOUBLE}
expression in mode @var{mode}.  Otherwise, it returns a
@code{CONST_VECTOR} expression in mode @var{mode}.  Similarly, the macro
@code{CONST1_RTX (@var{mode})} refers to an expression with value 1 in
mode @var{mode} and similarly for @code{CONST2_RTX}.  The
@code{CONST1_RTX} and @code{CONST2_RTX} macros are undefined
for vector modes.

@node Regs and Memory
@section Registers and Memory
@cindex RTL register expressions
@cindex RTL memory expressions

Here are the RTL expression types for describing access to machine
registers and to main memory.

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
For small values of the integer @var{n} (those that are less than
@code{FIRST_PSEUDO_REGISTER}), this stands for a reference to machine
register number @var{n}: a @dfn{hard register}.  For larger values of
@var{n}, it stands for a temporary value or @dfn{pseudo register}.
The compiler's strategy is to generate code assuming an unlimited
number of such pseudo registers, and later convert them into hard
registers or into memory references.

@var{m} is the machine mode of the reference.  It is necessary because
machines can generally refer to each register in more than one mode.
For example, a register may contain a full word but there may be
instructions to refer to it as a half word or as a single byte, as
well as instructions to refer to it as a floating point number of
various precisions.

Even for a register that the machine can access in only one mode,
the mode must always be specified.

The symbol @code{FIRST_PSEUDO_REGISTER} is defined by the machine
description, since the number of hard registers on the machine is an
invariant characteristic of the machine.  Note, however, that not
all of the machine registers must be general registers.  All the
machine registers that can be used for storage of data are given
hard register numbers, even those that can be used only in certain
instructions or can hold only certain types of data.

A hard register may be accessed in various modes throughout one
function, but each pseudo register is given a natural mode
and is accessed only in that mode.  When it is necessary to describe
an access to a pseudo register using a nonnatural mode, a @code{subreg}
expression is used.

A @code{reg} expression with a machine mode that specifies more than
one word of data may actually stand for several consecutive registers.
If in addition the register number specifies a hardware register, then
it actually represents several consecutive hardware registers starting
with the specified one.

Each pseudo register number used in a function's RTL code is
represented by a unique @code{reg} expression.

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
Some pseudo register numbers, those within the range of
@code{FIRST_VIRTUAL_REGISTER} to @code{LAST_VIRTUAL_REGISTER} only
appear during the RTL generation phase and are eliminated before the
optimization phases.  These represent locations in the stack frame that
cannot be determined until RTL generation for the function has been
completed.  The following virtual register numbers are defined:

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
This points to the first word of the incoming arguments passed on the
stack.  Normally these arguments are placed there by the caller, but the
callee may have pushed some arguments that were previously passed in
registers.

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
When RTL generation is complete, this virtual register is replaced
by the sum of the register given by @code{ARG_POINTER_REGNUM} and the
value of @code{FIRST_PARM_OFFSET}.

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
If @code{FRAME_GROWS_DOWNWARD} is defined to a nonzero value, this points
to immediately above the first variable on the stack.  Otherwise, it points
to the first variable on the stack.

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM} is replaced with the sum of the
register given by @code{FRAME_POINTER_REGNUM} and the value
@code{STARTING_FRAME_OFFSET}.

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
This points to the location of dynamically allocated memory on the stack
immediately after the stack pointer has been adjusted by the amount of
memory desired.

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
This virtual register is replaced by the sum of the register given by
@code{STACK_POINTER_REGNUM} and the value @code{STACK_DYNAMIC_OFFSET}.

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
This points to the location in the stack at which outgoing arguments
should be written when the stack is pre-pushed (arguments pushed using
push insns should always use @code{STACK_POINTER_REGNUM}).

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
This virtual register is replaced by the sum of the register given by
@code{STACK_POINTER_REGNUM} and the value @code{STACK_POINTER_OFFSET}.
@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})

@code{subreg} expressions are used to refer to a register in a machine
mode other than its natural one, or to refer to one register of
a multi-part @code{reg} that actually refers to several registers.

Each pseudo register has a natural mode.  If it is necessary to
operate on it in a different mode, the register must be
enclosed in a @code{subreg}.

There are currently three supported types for the first operand of a
@code{subreg}:
@itemize
@item pseudo registers
This is the most common case.  Most @code{subreg}s have pseudo
@code{reg}s as their first operand.

@item mem
@code{subreg}s of @code{mem} were common in earlier versions of GCC and
are still supported.  During the reload pass these are replaced by plain
@code{mem}s.  On machines that do not do instruction scheduling, use of
@code{subreg}s of @code{mem} are still used, but this is no longer
recommended.  Such @code{subreg}s are considered to be
@code{register_operand}s rather than @code{memory_operand}s before and
during reload.  Because of this, the scheduling passes cannot properly
schedule instructions with @code{subreg}s of @code{mem}, so for machines
that do scheduling, @code{subreg}s of @code{mem} should never be used.
To support this, the combine and recog passes have explicit code to
inhibit the creation of @code{subreg}s of @code{mem} when
@code{INSN_SCHEDULING} is defined.

The use of @code{subreg}s of @code{mem} after the reload pass is an area
that is not well understood and should be avoided.  There is still some
code in the compiler to support this, but this code has possibly rotted.
This use of @code{subreg}s is discouraged and will most likely not be
supported in the future.

@item hard registers
It is seldom necessary to wrap hard registers in @code{subreg}s; such
registers would normally reduce to a single @code{reg} rtx.  This use of
@code{subreg}s is discouraged and may not be supported in the future.

@end itemize

@code{subreg}s of @code{subreg}s are not supported.  Using
@code{simplify_gen_subreg} is the recommended way to avoid this problem.

@code{subreg}s come in two distinct flavors, each having its own
usage and rules:

@table @asis
@item Paradoxical subregs
When @var{m1} is strictly wider than @var{m2}, the @code{subreg}
expression is called @dfn{paradoxical}.  The canonical test for this
class of @code{subreg} is:

@smallexample
GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})
@end smallexample

Paradoxical @code{subreg}s can be used as both lvalues and rvalues.
When used as an lvalue, the low-order bits of the source value
are stored in @var{reg} and the high-order bits are discarded.
When used as an rvalue, the low-order bits of the @code{subreg} are
taken from @var{reg} while the high-order bits may or may not be
defined.

The high-order bits of rvalues are in the following circumstances:

@itemize
@item @code{subreg}s of @code{mem}
When @var{m2} is smaller than a word, the macro @code{LOAD_EXTEND_OP},
can control how the high-order bits are defined.

@item @code{subreg} of @code{reg}s
The upper bits are defined when @code{SUBREG_PROMOTED_VAR_P} is true.
@code{SUBREG_PROMOTED_UNSIGNED_P} describes what the upper bits hold.
Such subregs usually represent local variables, register variables
and parameter pseudo variables that have been promoted to a wider mode.

@end itemize

@var{bytenum} is always zero for a paradoxical @code{subreg}, even on
big-endian targets.

For example, the paradoxical @code{subreg}:

@smallexample
(set (subreg:SI (reg:HI @var{x}) 0) @var{y})
@end smallexample

stores the lower 2 bytes of @var{y} in @var{x} and discards the upper
2 bytes.  A subsequent:

@smallexample
(set @var{z} (subreg:SI (reg:HI @var{x}) 0))
@end smallexample

would set the lower two bytes of @var{z} to @var{y} and set the upper
two bytes to an unknown value assuming @code{SUBREG_PROMOTED_VAR_P} is
false.

@item Normal subregs
When @var{m1} is at least as narrow as @var{m2} the @code{subreg}
expression is called @dfn{normal}.

Normal @code{subreg}s restrict consideration to certain bits of
@var{reg}.  There are two cases.  If @var{m1} is smaller than a word,
the @code{subreg} refers to the least-significant part (or
@dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or
greater, the @code{subreg} refers to one or more complete words.

When used as an lvalue, @code{subreg} is a word-based accessor.
Storing to a @code{subreg} modifies all the words of @var{reg} that
overlap the @code{subreg}, but it leaves the other words of @var{reg}
alone.

When storing to a normal @code{subreg} that is smaller than a word,
the other bits of the referenced word are usually left in an undefined
state.  This laxity makes it easier to generate efficient code for
such instructions.  To represent an instruction that preserves all the
bits outside of those in the @code{subreg}, use @code{strict_low_part}
or @code{zero_extract} around the @code{subreg}.

@var{bytenum} must identify the offset of the first byte of the
@code{subreg} from the start of @var{reg}, assuming that @var{reg} is
laid out in memory order.  The memory order of bytes is defined by
two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}:

@itemize
@item
@cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}
@code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is
part of the most significant word; otherwise, it is part of the least
significant word.

@item
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is
the most significant byte within a word; otherwise, it is the least
significant byte within a word.
@end itemize

@cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}
On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with
@code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat
floating point values as if they had the same endianness as integer
values.  This works because they handle them solely as a collection of
integer values, with no particular numerical value.  Only real.c and
the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}.

Thus,

@smallexample
(subreg:HI (reg:SI @var{x}) 2)
@end smallexample

on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as

@smallexample
(subreg:HI (reg:SI @var{x}) 0)
@end smallexample

on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both
@code{subreg}s access the lower two bytes of register @var{x}.

@end table

A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the
corresponding @code{MODE_INT} mode, except that it has an unknown
number of undefined bits.  For example:

@smallexample
(subreg:PSI (reg:SI 0) 0)
@end smallexample

accesses the whole of @samp{(reg:SI 0)}, but the exact relationship
between the @code{PSImode} value and the @code{SImode} value is not
defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following
two @code{subreg}s:

@smallexample
(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
@end smallexample

represent independent 4-byte accesses to the two halves of
@samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number
of undefined bits.

If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:

@smallexample
(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
@end smallexample

represent independent 2-byte accesses that together span the whole
of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not
affect the value of the second, and vice versa.  @samp{(reg:PSI 0)}
has an unknown number of undefined bits, so the assignment:

@smallexample
(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
@end smallexample

does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the
value @samp{(reg:HI 4)}.

@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics
The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.
If the semantics are not correct for particular combinations of
@var{m1}, @var{m2} and hard @var{reg}, the target-specific code
must ensure that those combinations are never used.  For example:

@smallexample
CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})
@end smallexample

must be true for every class @var{class} that includes @var{reg}.

@findex SUBREG_REG
@findex SUBREG_BYTE
The first operand of a @code{subreg} expression is customarily accessed
with the @code{SUBREG_REG} macro and the second operand is customarily
accessed with the @code{SUBREG_BYTE} macro.

It has been several years since a platform in which
@code{BYTES_BIG_ENDIAN} not equal to @code{WORDS_BIG_ENDIAN} has
been tested.  Anyone wishing to support such a platform in the future
may be confronted with code rot.

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
This represents a scratch register that will be required for the
execution of a single instruction and not used subsequently.  It is
converted into a @code{reg} by either the local register allocator or
the reload pass.

@code{scratch} is usually present inside a @code{clobber} operation
(@pxref{Side Effects}).

@findex cc0
@cindex condition code register
@item (cc0)
This refers to the machine's condition code register.  It has no
operands and may not have a machine mode.  There are two ways to use it:

@itemize @bullet
@item
To stand for a complete set of condition code flags.  This is best on
most machines, where each comparison sets the entire series of flags.

With this technique, @code{(cc0)} may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) and in comparison operators comparing against zero
(@code{const_int} with value zero; that is to say, @code{const0_rtx}).

@item
To stand for a single flag that is the result of a single condition.
This is useful on machines that have only a single flag bit, and in
which comparison instructions must specify the condition to test.

With this technique, @code{(cc0)} may be validly used in only two
contexts: as the destination of an assignment (in test and compare
instructions) where the source is a comparison operator, and as the
first operand of @code{if_then_else} (in a conditional branch).
@end itemize

@findex cc0_rtx
There is only one expression object of code @code{cc0}; it is the
value of the variable @code{cc0_rtx}.  Any attempt to create an
expression of code @code{cc0} will return @code{cc0_rtx}.

Instructions can set the condition code implicitly.  On many machines,
nearly all instructions set the condition code based on the value that
they compute or store.  It is not necessary to record these actions
explicitly in the RTL because the machine description includes a
prescription for recognizing the instructions that do so (by means of
the macro @code{NOTICE_UPDATE_CC}).  @xref{Condition Code}.  Only
instructions whose sole purpose is to set the condition code, and
instructions that use the condition code, need mention @code{(cc0)}.

On some machines, the condition code register is given a register number
and a @code{reg} is used instead of @code{(cc0)}.  This is usually the
preferable approach if only a small subset of instructions modify the
condition code.  Other machines store condition codes in general
registers; in such cases a pseudo register should be used.

Some machines, such as the SPARC and RS/6000, have two sets of
arithmetic instructions, one that sets and one that does not set the
condition code.  This is best handled by normally generating the
instruction that does not set the condition code, and making a pattern
that both performs the arithmetic and sets the condition code register
(which would not be @code{(cc0)} in this case).  For examples, search
for @samp{addcc} and @samp{andcc} in @file{sparc.md}.

@findex pc
@item (pc)
@cindex program counter
This represents the machine's program counter.  It has no operands and
may not have a machine mode.  @code{(pc)} may be validly used only in
certain specific contexts in jump instructions.

@findex pc_rtx
There is only one expression object of code @code{pc}; it is the value
of the variable @code{pc_rtx}.  Any attempt to create an expression of
code @code{pc} will return @code{pc_rtx}.

All instructions that do not jump alter the program counter implicitly
by incrementing it, but there is no need to mention this in the RTL@.

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
This RTX represents a reference to main memory at an address
represented by the expression @var{addr}.  @var{m} specifies how large
a unit of memory is accessed.  @var{alias} specifies an alias set for the
reference.  In general two items are in different alias sets if they cannot
reference the same memory address.

The construct @code{(mem:BLK (scratch))} is considered to alias all
other memories.  Thus it may be used as a memory barrier in epilogue
stack deallocation patterns.

@findex concat
@item (concat@var{m} @var{rtx} @var{rtx})
This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.

@findex concatn
@item (concatn@var{m} [@var{rtx} @dots{}])
This RTX represents the concatenation of all the @var{rtx} to make a
single value.  Like @code{concat}, this should only appear in
declarations, and not in the insn chain.
@end table

@node Arithmetic
@section RTL Expressions for Arithmetic
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

Unless otherwise specified, all the operands of arithmetic expressions
must be valid for mode @var{m}.  An operand is valid for mode @var{m}
if it has mode @var{m}, or if it is a @code{const_int} or
@code{const_double} and @var{m} is a mode of class @code{MODE_INT}.

For commutative binary operations, constants should be placed in the
second operand.

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})

These three expressions all represent the sum of the values
represented by @var{x} and @var{y} carried out in machine mode
@var{m}.  They differ in their behavior on overflow of integer modes.
@code{plus} wraps round modulo the width of @var{m}; @code{ss_plus}
saturates at the maximum signed value representable in @var{m};
@code{us_plus} saturates at the maximum unsigned value.

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})

This expression represents the sum of @var{x} and the low-order bits
of @var{y}.  It is used with @code{high} (@pxref{Constants}) to
represent the typical two-instruction sequence used in RISC machines
to reference a global memory location.

The number of low order bits is machine-dependent but is
normally the number of bits in a @code{Pmode} item minus the number of
bits set by @code{high}.

@var{m} should be @code{Pmode}.

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

These three expressions represent the result of subtracting @var{y}
from @var{x}, carried out in mode @var{M}.  Behavior on overflow is
the same as for the three variants of @code{plus} (see above).

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
Represents the result of subtracting @var{y} from @var{x} for purposes
of comparison.  The result is computed without overflow, as if with
infinite precision.

Of course, machines can't really subtract with infinite precision.
However, they can pretend to do so when only the sign of the result will
be used, which is the case when the result is stored in the condition
code.  And that is the @emph{only} way this kind of expression may
validly be used: as a value to be stored in the condition codes, either
@code{(cc0)} or a register.  @xref{Comparisons}.

The mode @var{m} is not related to the modes of @var{x} and @var{y}, but
instead is the mode of the condition code value.  If @code{(cc0)} is
used, it is @code{VOIDmode}.  Otherwise it is some mode in class
@code{MODE_CC}, often @code{CCmode}.  @xref{Condition Code}.  If @var{m}
is @code{VOIDmode} or @code{CCmode}, the operation returns sufficient
information (in an unspecified format) so that any comparison operator
can be applied to the result of the @code{COMPARE} operation.  For other
modes in class @code{MODE_CC}, the operation only returns a subset of
this information.

Normally, @var{x} and @var{y} must have the same mode.  Otherwise,
@code{compare} is valid only if the mode of @var{x} is in class
@code{MODE_INT} and @var{y} is a @code{const_int} or
@code{const_double} with mode @code{VOIDmode}.  The mode of @var{x}
determines what mode the comparison is to be done in; thus it must not
be @code{VOIDmode}.

If one of the operands is a constant, it should be placed in the
second operand and the comparison code adjusted as appropriate.

A @code{compare} specifying two @code{VOIDmode} constants is not valid
since there is no way to know in what mode the comparison is to be
performed; the comparison must either be folded during the compilation
or the first operand must be loaded into a register while its mode is
still known.

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
These two expressions represent the negation (subtraction from zero) of
the value represented by @var{x}, carried out in mode @var{m}.  They
differ in the behavior on overflow of integer modes.  In the case of
@code{neg}, the negation of the operand may be a number not representable
in mode @var{m}, in which case it is truncated to @var{m}.  @code{ss_neg}
and @code{us_neg} ensure that an out-of-bounds result saturates to the
maximum or minimum signed or unsigned value.

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
Represents the signed product of the values represented by @var{x} and
@var{y} carried out in machine mode @var{m}.
@code{ss_mult} and @code{us_mult} ensure that an out-of-bounds result
saturates to the maximum or minimum signed or unsigned value.

Some machines support a multiplication that generates a product wider
than the operands.  Write the pattern for this as

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

where @var{m} is wider than the modes of @var{x} and @var{y}, which need
not be the same.

For unsigned widening multiplication, use the same idiom, but with
@code{zero_extend} instead of @code{sign_extend}.

@findex fma
@item (fma:@var{m} @var{x} @var{y} @var{z})
Represents the @code{fma}, @code{fmaf}, and @code{fmal} builtin
functions, which compute @samp{@var{x} * @var{y} + @var{z}}
without doing an intermediate rounding step.

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
Represents the quotient in signed division of @var{x} by @var{y},
carried out in machine mode @var{m}.  If @var{m} is a floating point
mode, it represents the exact quotient; otherwise, the integerized
quotient.
@code{ss_div} ensures that an out-of-bounds result saturates to the maximum
or minimum signed value.

Some machines have division instructions in which the operands and
quotient widths are not all the same; you should represent
such instructions using @code{truncate} and @code{sign_extend} as in,

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
Like @code{div} but represents unsigned division.
@code{us_div} ensures that an out-of-bounds result saturates to the maximum
or minimum unsigned value.

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
Like @code{div} and @code{udiv} but represent the remainder instead of
the quotient.

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
Represents the smaller (for @code{smin}) or larger (for @code{smax}) of
@var{x} and @var{y}, interpreted as signed values in mode @var{m}.
When used with floating point, if both operands are zeros, or if either
operand is @code{NaN}, then it is unspecified which of the two operands
is returned as the result.

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
Like @code{smin} and @code{smax}, but the values are interpreted as unsigned
integers.

@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
Represents the bitwise complement of the value represented by @var{x},
carried out in mode @var{m}, which must be a fixed-point machine mode.

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
Represents the bitwise logical-and of the values represented by
@var{x} and @var{y}, carried out in machine mode @var{m}, which must be
a fixed-point machine mode.

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
Represents the bitwise inclusive-or of the values represented by @var{x}
and @var{y}, carried out in machine mode @var{m}, which must be a
fixed-point mode.

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
Represents the bitwise exclusive-or of the values represented by @var{x}
and @var{y}, carried out in machine mode @var{m}, which must be a
fixed-point mode.

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
These three expressions represent the result of arithmetically shifting @var{x}
left by @var{c} places.  They differ in their behavior on overflow of integer
modes.  An @code{ashift} operation is a plain shift with no special behavior
in case of a change in the sign bit; @code{ss_ashift} and @code{us_ashift}
saturates to the minimum or maximum representable value if any of the bits
shifted out differs from the final sign bit.

@var{x} have mode @var{m}, a fixed-point machine mode.  @var{c}
be a fixed-point mode or be a constant with mode @code{VOIDmode}; which
mode is determined by the mode called for in the machine description
entry for the left-shift instruction.  For example, on the VAX, the mode
of @var{c} is @code{QImode} regardless of @var{m}.

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
Like @code{ashift} but for right shift.  Unlike the case for left shift,
these two operations are distinct.

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
Similar but represent left and right rotate.  If @var{c} is a constant,
use @code{rotate}.

@findex abs
@findex ss_abs
@cindex absolute value
@item (abs:@var{m} @var{x})
@item (ss_abs:@var{m} @var{x})
Represents the absolute value of @var{x}, computed in mode @var{m}.
@code{ss_abs} ensures that an out-of-bounds result saturates to the
maximum signed value.


@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
Represents the square root of @var{x}, computed in mode @var{m}.
Most often @var{m} will be a floating point mode.

@findex ffs
@item (ffs:@var{m} @var{x})
Represents one plus the index of the least significant 1-bit in
@var{x}, represented as an integer of mode @var{m}.  (The value is
zero if @var{x} is zero.)  The mode of @var{x} must be @var{m}
or @code{VOIDmode}.

@findex clrsb
@item (clrsb:@var{m} @var{x})
Represents the number of redundant leading sign bits in @var{x},
represented as an integer of mode @var{m}, starting at the most
significant bit position.  This is one less than the number of leading
sign bits (either 0 or 1), with no special cases.  The mode of @var{x}
must be @var{m} or @code{VOIDmode}.

@findex clz
@item (clz:@var{m} @var{x})
Represents the number of leading 0-bits in @var{x}, represented as an
integer of mode @var{m}, starting at the most significant bit position.
If @var{x} is zero, the value is determined by
@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Note that this is one of
the few expressions that is not invariant under widening.  The mode of
@var{x} must be @var{m} or @code{VOIDmode}.

@findex ctz
@item (ctz:@var{m} @var{x})
Represents the number of trailing 0-bits in @var{x}, represented as an
integer of mode @var{m}, starting at the least significant bit position.
If @var{x} is zero, the value is determined by
@code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}).  Except for this case,
@code{ctz(x)} is equivalent to @code{ffs(@var{x}) - 1}.  The mode of
@var{x} must be @var{m} or @code{VOIDmode}.

@findex popcount
@item (popcount:@var{m} @var{x})
Represents the number of 1-bits in @var{x}, represented as an integer of
mode @var{m}.  The mode of @var{x} must be @var{m} or @code{VOIDmode}.

@findex parity
@item (parity:@var{m} @var{x})
Represents the number of 1-bits modulo 2 in @var{x}, represented as an
integer of mode @var{m}.  The mode of @var{x} must be @var{m} or
@code{VOIDmode}.

@findex bswap
@item (bswap:@var{m} @var{x})
Represents the value @var{x} with the order of bytes reversed, carried out
in mode @var{m}, which must be a fixed-point machine mode.
The mode of @var{x} must be @var{m} or @code{VOIDmode}.
@end table

@node Comparisons
@section Comparison Operations
@cindex RTL comparison operations

Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, @code{STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or zero if it does not, for comparison operators
whose results have a `MODE_INT' mode,
@code{FLOAT_STORE_FLAG_VALUE} (@pxref{Misc}) if the relation holds, or
zero if it does not, for comparison operators that return floating-point
values, and a vector of either @code{VECTOR_STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or of zeros if it does not, for comparison operators
that return vector results.
The mode of the comparison operation is independent of the mode
of the data being compared.  If the comparison operation is being tested
(e.g., the first operand of an @code{if_then_else}), the mode must be
@code{VOIDmode}.

@cindex condition codes
There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes
@code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such
a construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The instruction setting the
condition code must be adjacent to the instruction using the condition
code; only @code{note} insns may separate them.

Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

In the example above, if @code{(cc0)} were last set to
@code{(compare @var{x} @var{y})}, the comparison operation is
identical to @code{(eq @var{x} @var{y})}.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the @code{eq} shown
in case it exists in the context of the particular insn involved.

Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes @code{gt} and @code{gtu} for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than @minus{}1 but not
unsigned greater-than, because @minus{}1 when regarded as unsigned is actually
@code{0xffffffff} which is greater than 1.

The signed comparisons are also used for floating point values.  Floating
point comparisons are distinguished by the machine modes of the operands.

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are equal, otherwise 0.

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are not equal, otherwise 0.

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the @var{x} is greater than @var{y}.  If they
are fixed-point, the comparison is done in a signed sense.

@findex gtu
@cindex greater than
@cindex unsigned greater than
@item (gtu:@var{m} @var{x} @var{y})
Like @code{gt} but does unsigned comparison, on fixed-point numbers only.

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than''.

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``greater than or equal''.

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than or equal''.

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
This is not a comparison operation but is listed here because it is
always used in conjunction with a comparison operation.  To be
precise, @var{cond} is a comparison expression.  This expression
represents a choice, according to @var{cond}, between the value
represented by @var{then} and the one represented by @var{else}.

On most machines, @code{if_then_else} expressions are valid only
to express conditional jumps.

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
Similar to @code{if_then_else}, but more general.  Each of @var{test1},
@var{test2}, @dots{} is performed in turn.  The result of this expression is
the @var{value} corresponding to the first nonzero test, or @var{default} if
none of the tests are nonzero expressions.

This is currently not valid for instruction patterns and is supported only
for insn attributes.  @xref{Insn Attributes}.
@end table

@node Bit-Fields
@section Bit-Fields
@cindex bit-fields

特別な式コードがあり、ビットフィールド命令を表現することができる。
この型の式は、RTL 中で左辺値となる。代入式の左辺に置くことが可能で、
その式で指定されたビットフィールドにある値を代入することを指示する。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
これは、@var{loc}(メモリかレジスタの参照)に含まれるか、そこで始まっている
符号拡張されたビットフィールドへの参照を表す。
このビットフィールドは幅が @var{size} ビットで、ビット位置 @var{pos} から
始まっている。コンパイル時の選択により、@code{BITS_BIG_ENDIAN} が、
メモリ単位のどちらの端から @var{pos} を数えるかを指定する。

@var{loc} がメモリ中に置かれているなら、そのモードは一バイト整数のモードで
なければならない。
@var{loc} がレジスタに置かれているなら、使うべきモードは、
パターン @code{insv} または @code{extv} (@pxref{Standard Names})
のオペランドとして指定されたものになり、通常は全語の整数モードである。
何も指定がないときのデフォルトは全語の整数モードになる。

@var{pos} のモードはマシン固有であり、パターン @code{insv} または
@code{extv} でも指定される。

モード @var{m} は、@var{loc} がレジスタなら、それに使われるモードと
同じである。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})

@code{sign_extract} と同様だが、符号なし、あるいはゼロ拡張された
ビットフィールドを参照する。
同じビット列が抽出されるが、符号拡張ではなくゼロで埋め尽くされる。
@end table

@node Conversions
@section Conversions
@cindex conversions
@cindex machine mode conversions

マシンモード間の変換は全て、明示的な変換演算で表す必要がある。
例えば、あるバイトとある全語の和を表す式を、
@code{(plus:SI (reg:QI 34) (reg:SI 80))} と書くことはできない。
なぜなら、@code{plus} という演算では、二つのオペランドは同じマシンモード
を持つ必要があるからである。
このため、バイトの大きさのオペランドを変換演算で以下のように包む必要がある。

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

変換演算は単なるプレースホルダーではない。というのは、指定された
変換前のモードから変換後のモードへ変換する方法はひとつだけでは
ないからである。変換演算のコードで、変換方法を指定するのである。

以下のどの変換演算でも、@var{x} は @code{VOIDmode} であってはならない。
変換を行なうべきがモードが判らないからである。
変換は、コンパイル時に行なうか、@var{x} をレジスタに保持するかのどちらかで
なければならない。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へ符号拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へゼロ拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex float_extend
@item (float_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に拡張した結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は、@var{m} より
幅の狭いモードの浮動小数点数値でなければならない。

@findex truncate
@item (truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は固定小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの固定少数点値でなければならない。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの浮動少数点値でなければならない。

@findex float
@item (float:@var{m} @var{x})
固定小数点値 @var{x} を符号付きとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
固定小数点値 @var{x} を符号無しとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex fix
@item (fix:@var{m} @var{x})
@var{m} が固定小数点モードの場合、浮動小数点値 @var{x} をモード @var{m} の
符号付き整数に変換した結果を表現する。
丸めをどのように行なうかは規定されないので、C プログラムをコンパイルする
ときにこの演算が正しく使えるのは、オペランドが整数値を持つ時だけである。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
浮動小数点値 @var{x} をモード @var{m} の符号なし整数に変換した結果を表現する。
丸めをどのように行なうかは規定されない。
@end table

@node RTL Declarations
@section Declarations
@cindex RTL declarations
@cindex declarations, RTL

宣言式コードは、算術演算を表すのではなく、オペランドの状態に関する
表明を表す。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
この式コードはただ一つの文脈でのみ使われる。
@code{set} 式の目的オペランドとしてだけ使われる。
さらに、この式のオペランドは矛盾のない @code{subreg} 式でなければ
ならない。

@code{strict_low_part} があると、モード @var{n} では意味があるが、
モード @var{m} の一部ではないようなレジスタの一部が、変更すべきで
ないことを示す。
通常、@var{m} の幅がワードより狭いときは、このようなサブレジスタに
代入を行なうと、そのレジスタの他の部分に予期しない影響を与える。
@end table

@node Side Effects
@section Side Effect Expressions
@cindex RTL side effect expressions

ここまで説明してきた式コードは値を表すものであり、動作を
表すものではなかった。
しかし機械命令というものは決して値を生み出すものではない。
機械命令は、マシンの状態に副作用を与えるという点でのみ意味を持つ。
特別な式コードを使って、副作用を表現する。

命令の本体は、必ず以下の副作用を表すコードの一つである。
これまで説明してきた、値を表現するコードは、これらのオペランドとしてのみ
現れるのである

@table @code
@findex set
@item (set @var{lval} @var{x})
@var{x} の値を @var{lval} で表される場所に格納する動作を表現する。
@var{lval} は、その中に格納可能であるような場所を表す式である。
すなわち、@code{reg}(あるいは @code{subreg}、または @code{strict_low_part})、
@code{mem}、@code{pc}、@code{cc0} のどれかである。

@var{lval} が、@code{reg}、@code{subreg}、@code{mem} のどれかなら、
マシンモードを持つ必要がある。その場合、@var{x} は、そのモードで
有効でなければならない。

@var{lval} が、マシンモードがそのレジスタの全幅より小さいような
@code{reg} であれば、そのマシンモードにより指定されたレジスタの部分には
指定された値が与えられ、レジスタのその他の部分は未定義値となる。
同様に、@var{lval} が、レジスタのモードより狭いモードの @code{subreg} なら、
レジスタのその他の部分がどのように変更されるかは不定である。

@var{lval} が、@code{subreg} の @code{strict_low_part} なら、
@code{subreg} のマシンモードで指定されたレジスタの部分は、
値 @var{x} が与えられ、その他の部分は変更されない。

@var{lval} が @code{(cc0)} なら、マシンモードがないので、
@var{x} は @code{compare} 式か、任意のモードを持つ値で良い。
後者の場合は、``test'' 命令を表現する。
@code{(set (cc0) (reg:@var{m} @var{n}))} という式は、
@code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))} という
式に等価である。
前者の式を使ったほうが、コンパイル中のメモリを節約できる。

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
@var{lval} が @code{(pc)} なら、それはジャンプ命令であり、
@var{x} の取りうる値は非常に限られてくる。
@var{x} は、@code{label_ref} 式とすることができる(無条件ジャンプ)。
@code{if_then_else} (条件ジャンプ)とすることもでき、その場合、
第二オペランドか第三オペランドのどちらかが @code{(pc)} (ジャンプしない場合に
使われる)でなければならず、またもう一方は @code{label_ref}
(ジャンプする場合に使われる)でなければならない。
また、@var{x} は @code{mem} または @code{(plus:SI (pc) @var{y})} でも
良い。ここで、@var{y} は @code{reg} か @code{mem} である。
この最後のパターンは分岐テーブル経由のジャンプを表現するのに使われる。

@var{lval} が @code{(cc0)} でも @code{(pc)} でもなければ、
@var{lval} のモードは @code{VOIDmode} としてはならず、@var{x} のモードは
@var{lval} のモードとして有効でなければならない。

@findex SET_DEST
@findex SET_SRC
@var{lval} は @code{SET_DEST} マクロで、@var{x} は @code{SET_SRC} マクロで
アクセスするようにするのが良い。

@findex return
@item (return)
パターン中に単独の式として書くことで、現在の関数から戻ることを
表す。ただし、VAX のように一命令で戻ることができるマシンに
限られる。
関数から戻るためには、複数の命令からなる「エピローグ」を実行する必要が
あるマシンでは、関数からの復帰は、エピローグの直前に置かれるラベルへ
ジャンプすることで行なわれるので、@code{return} 式コードが使われることはない。

@code{if_then_else} 式の中に置いた場合は、呼び出し元に戻るための @code{pc}
に置かれる値を表す。

@code{(return)} というパターンは、論理的には @code{(set (pc) (return))}
と等価であるが、後者の形式が使われることはない。

@findex call
@item (call @var{function} @var{nargs})
関数呼び出しを表現する。@var{function} は @code{mem} 式であり、
この式のアドレスは、呼び出される関数のアドレスである。
@var{nargs} は二つの目的で使われる式である。
あるマシンでは、スタックに積まれた引数のバイト数を表現する。
あるいは、引数レジスタの数を表現する。

どのマシンも @var{function} が持たなければならない標準的な
マシンモードを持っている。マシン記述では、
@code{FUNCTION_MODE} というマクロを、その不可欠のモード名に
展開されるように定義している。
このモードの目的は、どの種類のアドレッシングが許されるかが
アドレスの対象となるマシンモードに依存するマシンにおいて、
どの種類のアドレッシングが許されているかを指定することである。

@findex clobber
@item (clobber @var{x})
予期できない値を @var{x} に格納すること、または格納する可能性が
あることを表す。@var{x} は、@code{reg} 式か、@code{scratch} 式か、
@code{mem} 式のどれかでなければならない。

これが使われるのは一つは、標準的な値を特定のハードレジスタに格納する
文字列命令においてである。
格納される値を記述する手間をかける必要はないが、
文字列命令を越えてその値を保持しようとしないように、
コンパイラにレジスタの値が変更されることを知らせるのが本質的な
事である。

もし @var{x} が @code{(mem:BLK (const_int 0))} なら、
全メモリ位置が上書きされると見なされなければならないことを意味する。

マシン記述では、ある種類のハードレジスタを「呼びだし時破壊」
(``call-clobbered'') として分類していることに注意。
全ての関数の呼びだし命令は、デフォルトでこれらのレジスタを破壊すると
仮定されているので、この事実を示すために @code{clobber} 式を
使う必要はない。
また、各関数呼び出しは、その関数が @code{const} と宣言されていない限り、
任意のメモリ位置を変更する可能性があると仮定されている。

@code{parallel} の最後の組の式が、それぞれ @code{reg} か
@code{match_scratch} 式 (@pxref{RTL Template})を引数とする
@code{clobber} 式なら、組合せフェーズは、そうすることでパターンが
マッチするようになるなら、適切な @code{clobber} 式を、構築されたばかりの
insn に追加する。

この機能は、例えば、乗算命令と加算命令は MQ レジスタを使わないが、
アキュムレータへの加算命令が MQ レジスタを上書きするようなマシンで
使うことができる。
一個の組み合わされた命令(? combined instruction)は一時レジスタを
必要とするが、一方、それを構成する命令は一時レジスタを必要としない
場合も同様である。

あるレジスタに対する @code{clobber} 式が、他に副作用のある @code{parallel}
の中に現れた場合は、レジスタ確保部が、そのレジスタがその insn の前後
どちらにおいても占有されることがないことを保証する。
しかし、選ばれた選択肢に対して制約 @samp{&} が指定されていない限り、
再ロードパスが入力の一つとして使われたレジスタを確保する場合がある
(@pxref{Modifiers})。
特定のハードレジスタ、または疑似レジスタ、あるいは @code{scratch} 式の
どれかを上書きすることができる。後の二つの場合には、
GNU CC は、その時点で一時的に使用可能なハードレジスタを確保する

一時レジスタを必要とする命令については、疑似レジスタの代わりに
@code{scratch} を使うべきである。
そうしておくと、組合せフェーズが必要なときに @code{clobber} を追加すること
を許すからである。
このためには (@code{clobber} (@code{match_scratch} @dots{})) と
書けば良い。
疑似レジスタを上書きするなら、他のどこにも現れていないものを
使うこと。つまり、そのたびに新しいものを生成して使うこと。
そうしないと、CSE のフェーズが混乱する。

@code{parallel} 中で疑似レジスタを上書きすることのもう一つの使い道が
ある。insn の入力オペランドの一つがやりその insn により上書きされる
場合である。
この場合、insn 中の clobber の中と、別のところとに同じ疑似レジスタを
使うと期待どおりの結果が得られる。

@findex use
@item (use @var{x})
@var{x} の値が使われるということを表す。
プログラムのこの時点での @var{x} の値が必要であることを示す。
たとえ、なぜ必要であるかがはっきりしていなくてもである。
このため、GCC は、@var{x} に値を格納するという
効果しか持たない命令が直前にあっても、その命令を削除しない。
@var{x} は、@code{reg} 式でなければならない。

再ロードフェーズの間、パターンとして @code{use} がある insn は、
@code{reg_equal} ノートを保持することが可能である。
このような @code{use} insn は、再ロードフェーズが終了する前に
削除される。

遅延分岐スケジューリングのフェーズの間は、@var{x} は insn でも良い。
これは、@var{x} が以前にコード中のこの場所にあって、そのデータ依存関係
を考慮する必要があるということを意味する。
このような @code{use} insn は、遅延分岐スケジューリングのフェーズの
終了前に削除される。

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
Represents several side effects performed in parallel.  The square
brackets stand for a vector; the operand of @code{parallel} is a
vector of expressions.  @var{x0}, @var{x1} and so on are individual
side effect expressions---expressions of code @code{set}, @code{call},
@code{return}, @code{simple_return}, @code{clobber} or @code{use}.

``In parallel'' means that first all the values used in the individual
side-effects are computed, and second all the actual side-effects are
performed.  For example,

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent
says unambiguously that the values of hard register 1 and the memory
location addressed by it are interchanged.  In both places where
@code{(reg:SI 1)} appears as a memory address it refers to the value
in register 1 @emph{before} the execution of the insn.

It follows that it is @emph{incorrect} to use @code{parallel} and
expect the result of one @code{set} to be available for the next one.
For example, people sometimes attempt to represent a jump-if-zero
instruction this way:

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
But this is incorrect, because it says that the jump condition depends
on the condition code value @emph{before} this instruction, not on the
new value that is set by this instruction.

@cindex peephole optimization, RTL representation
Peephole optimization, which takes place together with final assembly
code output, can produce insns whose patterns consist of a @code{parallel}
whose elements are the operands needed to output the resulting
assembler code---often @code{reg}, @code{mem} or constant expressions.
This would not be well-formed RTL at any other stage in compilation,
but it is OK then because no further optimization remains to be done.
However, the definition of the macro @code{NOTICE_UPDATE_CC}, if
any, must deal with such insns if you define any peephole optimizations.

@findex cond_exec
@item (cond_exec [@var{cond} @var{expr}])
Represents a conditionally executed expression.  The @var{expr} is
executed only if the @var{cond} is nonzero.  The @var{cond} expression
must not have side-effects, but the @var{expr} may very well have
side-effects.

@findex sequence
@item (sequence [@var{insns} @dots{}])
Represents a sequence of insns.  If a @code{sequence} appears in the
chain of insns, then each of the @var{insns} that appears in the sequence
must be suitable for appearing in the chain of insns, i.e. must satisfy
the @code{INSN_P} predicate.

After delay-slot scheduling is completed, an insn and all the insns that
reside in its delay slots are grouped together into a @code{sequence}.
The insn requiring the delay slot is the first insn in the vector;
subsequent insns are to be placed in the delay slot.

@code{INSN_ANNULLED_BRANCH_P} is set on an insn in a delay slot to
indicate that a branch insn should be used that will conditionally annul
the effect of the insns in the delay slots.  In such a case,
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.

Some back ends also use @code{sequence} objects for purposes other than
delay-slot groups.  This is not supported in the common parts of the
compiler, which treat such sequences as delay-slot groups.

DWARF2 Call Frame Address (CFA) adjustments are sometimes also expressed
using @code{sequence} objects as the value of a @code{RTX_FRAME_RELATED_P}
note.  This only happens if the CFA adjustments cannot be easily derived
from the pattern of the instruction to which the note is attached.  In
such cases, the value of the note is used instead of best-guesing the
semantics of the instruction.  The back end can attach notes containing
a @code{sequence} of @code{set} patterns that express the effect of the
parent instruction.
@end table

These expression codes appear in place of a side effect, as the body of
an insn, though strictly speaking they do not always describe side
effects as such:

@table @code
@findex asm_input
@item (asm_input @var{s})
Represents literal assembler code as described by the string @var{s}.

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
Represents a machine-specific operation on @var{operands}.  @var{index}
selects between multiple machine-specific operations.
@code{unspec_volatile} is used for volatile operations and operations
that may trap; @code{unspec} is used for other operations.

These codes may appear inside a @code{pattern} of an
insn, inside a @code{parallel}, or inside an expression.

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
Represents a table of jump addresses.  The vector elements @var{lr0},
etc., are @code{label_ref} expressions.  The mode @var{m} specifies
how much space is given to each address; normally @var{m} would be
@code{Pmode}.

@findex addr_diff_vec
@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})
Represents a table of jump addresses expressed as offsets from
@var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref}
expressions and so is @var{base}.  The mode @var{m} specifies how much
space is given to each address-difference.  @var{min} and @var{max}
are set up by branch shortening and hold a label with a minimum and a
maximum address, respectively.  @var{flags} indicates the relative
position of @var{base}, @var{min} and @var{max} to the containing insn
and of @var{min} and @var{max} to @var{base}.  See rtl.def for details.

@findex prefetch
@item (prefetch:@var{m} @var{addr} @var{rw} @var{locality})
Represents prefetch of memory at address @var{addr}.
Operand @var{rw} is 1 if the prefetch is for data to be written, 0 otherwise;
targets that do not support write prefetches should treat this as a normal
prefetch.
Operand @var{locality} specifies the amount of temporal locality; 0 if there
is none or 1, 2, or 3 for increasing levels of temporal locality;
targets that do not support locality hints should ignore this.

This insn is used to minimize cache-miss latency by moving data into a
cache before it is accessed.  It should use only non-faulting data prefetch
instructions.
@end table

@node Incdec
@section Embedded Side-Effects on Addresses
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

メモリアドレスとして現れる、特別な副作用式コードが 6 つある。

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
@var{x} を標準量だけデクリメントする副作用を表す。
また、@var{x} がデクリンメントされた後の値も表す。
@var{x} は @code{reg} か @code{mem} でなければならず、
ほとんどのマシンでは @code{reg} しか許していない。
@var{m} はそのマシンのポインタ用のマシンモードでなければならない。
@var{x} のデクリメントされる量は、アドレスとして振る舞う式の
メモリ参照を含むマシンモードの長さをバイト数で表したものである。
以下に使い方の例を示す。

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
これは、疑似レジスタ 39 を @code{DFmode} の値の長さだけデクリメントし、
その結果を @code{DFmode} の値のアドレスとして使う事を示している。

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_dec
@item (post_dec:@var{m} @var{x})
@code{pre_dec} と同じ副作用を表すが、異なる値になる。
これにより表される値は、デクリメントされる前の @var{x} の値である。

@findex post_inc
@item (post_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})

@var{x} を @var{y} に設定する副作用を表現し、かつ @var{x} が修正を受ける前の
@var{x} を表現する。@var{x} は @code{reg} か @code{mem} でなければならない。
だが、多くの機種では @code{reg} しか許していない。
@var{m} は使われている機種でのポインタのマシンモードでなければならない。
@var{x} がデクリメントされる量は、この式がアドレスの役割をする
メモリ参照のマシンモードの長さをバイトで表したものである。
これは、現在実装されていないことに注意。

式 @var{y} は次の三つの形式のうちの一つでなければならない。
@table @code
@code{(plus:@var{m} @var{x} @var{z})}
@code{(minus:@var{m} @var{x} @var{z})}
@code{(plus:@var{m} @var{x} @var{i})}
@end table
ここで @var{z} はインデックス・レジスタで、@var{i} は定数である。

使い方の例を示す。

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

これは、疑似レジスタ 42 を、疑似レジスタ 48 の内容をそれに加算する形で
変更することを示している。ただし、42 が指し示していた内容が使われた後で
行われる。

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
同様に、@var{x} の内容を使う前に副作用が発生する。
@end table

これらの組み込み副作用式は注意して使わなければならない。
命令パターンでは使わない。コンパイラの @samp{flow} パスに至るまでは、
スタックへのプッシュを表現するのに使われるだけである。
@samp{flow} パスは、レジスタが一個の命令でインクリメントまたはデクリメント
され、かつ、その直前または直後でアドレスとして使われている場合を
探す。そのような場合は、プリ／ポスト・インクリメント／デクリメントを
使うように変換する。

これらの式のオペランドとして使われているレジスタが、
ある insn の別のアドレス中で使われていると、そのレジスタの元の値が使われる。
レジスタをアドレス以外に使うことは、同一 insn 内で埋め込み副作用式として
使うのは許されない。なぜなら、そういう式は、
異なる機種では異なる振る舞いをし、そのため、取扱いが曖昧になるので
許されない。

組み込み副作用式で表現可能な命令は、また、
アドレスレジスタがどのように変更されるかを記述する追加の @code{set}
を含む @code{parallel} を使って表現することもできる。
だが、これは行なわれない。何故ならこのような操作をともかく許す機種では、
典型的には、メモリアドレスが要求される場所ならどこでもそういう操作を
許すからである。
これらの操作を付加的な並列格納として記述すると、
マシン記述のエントリ数が二倍必要になる。

@node Assembler
@section Assembler Instructions as Expressions
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
RTX コード @code{asm_operands} は、ユーザが指定したアセンブラ命令に
より生成される値を表現する。引数付きの @code{asm} 文を表現するのに
使われる。出力オペランドが一つの @code{asm} 文は以下のようになる。

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
この @code{asm} 文は、値が @code{outputvar} に格納されることを
表現する、一個の @code{asm_operands} RTX を使って以下のように表現される。

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
ここで、@code{asm_operands} RTX のオペランドは、アセンブラテンプレート文字列、
出力オペランドについての制限子、指定されたオペランドの中での出力オペランド
の番号、入力オペランド RTX のベクトル、それに、入力オペランドのモードと
制約のベクトルからなる。モード @var{m1} は、和 @code{x+y} のモードであり、
@var{m2} は、@code{*z} のモードである。

@code{asm} 文に複数の出力値がある場合は、その insn は @code{parallel} の
内側に幾つかの @code{set} RTX を持つ。
@code{set}はそれぞれ @code{asm_operands} を含んでいる。
これらの @code{set} は全て、同じアセンブラテンプレートとベクトルを
共有しているが、それぞれ出力オペランドに応じた制約を保持している。

@node Insns
@section Insns
@cindex insns

関数のコードの RTL 表現は、@dfn{insn} と呼ばれるオブジェクトの
二重線形リストである。insn は他に用途のない特別なコードを持つ式である。
insn の一部は実際の命令である。@code{switch} 文のための分岐テーブル
を表現するものもある。その他、分岐先ラベルや様々な宣言的な情報を
表現するものもある。

各 insn は、それ自身固有のデータを持つほか、現在の関数内の他の insn と
区別するための一意的な識別番号(遅延分岐スケジューリングの後で、
同じ識別番号を持つ insn のコピーが一つの関数内で複数存在することがあるが、
これらのコピーは全く同じであり、@code{sequence} の中にしか現れない)、
それに直前と直後の insn を指すポインタを持っている。
この三つのフィールドはどの insn においても、insn の式コードによらずに、
同じ位置にある。
この三つのフィールドは @code{XEXP} と @code{XINT} を使ってアクセスしても
良いが、以下のような特別なマクロが三つあり、いつでも使うことができる。

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
Accesses the unique id of insn @var{i}.

@findex PREV_INSN
@item PREV_INSN (@var{i})
Accesses the chain pointer to the insn preceding @var{i}.
If @var{i} is the first insn, this is a null pointer.

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
Accesses the chain pointer to the insn following @var{i}.
If @var{i} is the last insn, this is a null pointer.
@end table

@findex get_insns
@findex get_last_insn
The first insn in the chain is obtained by calling @code{get_insns}; the
last insn is the result of calling @code{get_last_insn}.  Within the
chain delimited by these insns, the @code{NEXT_INSN} and
@code{PREV_INSN} pointers must always correspond: if @var{insn} is not
the first insn,

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true and if @var{insn} is not the last insn,

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true.

After delay slot scheduling, some of the insns in the chain might be
@code{sequence} expressions, which contain a vector of insns.  The value
of @code{NEXT_INSN} in all but the last of these insns is the next insn
in the vector; the value of @code{NEXT_INSN} of the last insn in the vector
is the same as the value of @code{NEXT_INSN} for the @code{sequence} in
which it is contained.  Similar rules apply for @code{PREV_INSN}.

This means that the above invariants are not necessarily true for insns
inside @code{sequence} expressions.  Specifically, if @var{insn} is the
first insn in a @code{sequence}, @code{NEXT_INSN (PREV_INSN (@var{insn}))}
is the insn containing the @code{sequence} expression, as is the value
of @code{PREV_INSN (NEXT_INSN (@var{insn}))} if @var{insn} is the last
insn in the @code{sequence} expression.  You can use these expressions
to find the containing @code{sequence} expression.

Every insn has one of the following expression codes:

@table @code
@findex insn
@item insn
The expression code @code{insn} is used for instructions that do not jump
and do not do function calls.  @code{sequence} expressions are always
contained in insns with code @code{insn} even if one of those insns
should jump or do function calls.

Insns with code @code{insn} have four additional fields beyond the three
mandatory ones listed above.  These four are described in a table below.

@findex jump_insn
@item jump_insn
The expression code @code{jump_insn} is used for instructions that may
jump (or, more generally, may contain @code{label_ref} expressions to
which @code{pc} can be set in that instruction).  If there is an
instruction to return from the current function, it is recorded as a
@code{jump_insn}.

@findex JUMP_LABEL
@code{jump_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{JUMP_LABEL} which is defined once jump optimization has completed.

For simple conditional and unconditional jumps, this field contains
the @code{code_label} to which this insn will (possibly conditionally)
branch.  In a more complex jump, @code{JUMP_LABEL} records one of the
labels that the insn refers to; other jump target labels are recorded
as @code{REG_LABEL_TARGET} notes.  The exception is @code{addr_vec}
and @code{addr_diff_vec}, where @code{JUMP_LABEL} is @code{NULL_RTX}
and the only way to find the labels is to scan the entire body of the
insn.

Return insns count as jumps, but since they do not refer to any
labels, their @code{JUMP_LABEL} is @code{NULL_RTX}.

@findex call_insn
@item call_insn
The expression code @code{call_insn} is used for instructions that may do
function calls.  It is important to distinguish these instructions because
they imply that certain registers and memory locations may be altered
unpredictably.

@findex CALL_INSN_FUNCTION_USAGE
@code{call_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of
@code{expr_list} expressions) containing @code{use}, @code{clobber} and
sometimes @code{set} expressions that denote hard registers and
@code{mem}s used or clobbered by the called function.

A @code{mem} generally points to a stack slot in which arguments passed
to the libcall by reference (@pxref{Register Arguments,
TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is
caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),
the stack slot will be mentioned in @code{clobber} and @code{use}
entries; if it's callee-copied, only a @code{use} will appear, and the
@code{mem} may point to addresses that are not stack slots.

Registers occurring inside a @code{clobber} in this list augment
registers specified in @code{CALL_USED_REGISTERS} (@pxref{Register
Basics}).

If the list contains a @code{set} involving two registers, it indicates
that the function returns one of its arguments.  Such a @code{set} may
look like a no-op if the same register holds the argument and the return
value.

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
A @code{code_label} insn represents a label that a jump insn can jump
to.  It contains two special fields of data in addition to the three
standard ones.  @code{CODE_LABEL_NUMBER} is used to hold the @dfn{label
number}, a number that identifies this label uniquely among all the
labels in the compilation (not just in the current function).
Ultimately, the label is represented in the assembler output as an
assembler label, usually of the form @samp{L@var{n}} where @var{n} is
the label number.

When a @code{code_label} appears in an RTL expression, it normally
appears within a @code{label_ref} which represents the address of
the label, as a number.

Besides as a @code{code_label}, a label can also be represented as a
@code{note} of type @code{NOTE_INSN_DELETED_LABEL}.

@findex LABEL_NUSES
The field @code{LABEL_NUSES} is only defined once the jump optimization
phase is completed.  It contains the number of times this label is
referenced in the current function.

@findex LABEL_KIND
@findex SET_LABEL_KIND
@findex LABEL_ALT_ENTRY_P
@cindex alternate entry points
The field @code{LABEL_KIND} differentiates four different types of
labels: @code{LABEL_NORMAL}, @code{LABEL_STATIC_ENTRY},
@code{LABEL_GLOBAL_ENTRY}, and @code{LABEL_WEAK_ENTRY}.  The only labels
that do not have type @code{LABEL_NORMAL} are @dfn{alternate entry
points} to the current function.  These may be static (visible only in
the containing translation unit), global (exposed to all translation
units), or weak (global, but can be overridden by another symbol with the
same name).

Much of the compiler treats all four kinds of label identically.  Some
of it needs to know whether or not a label is an alternate entry point;
for this purpose, the macro @code{LABEL_ALT_ENTRY_P} is provided.  It is
equivalent to testing whether @samp{LABEL_KIND (label) == LABEL_NORMAL}.
The only place that cares about the distinction between static, global,
and weak alternate entry points, besides the front-end code that creates
them, is the function @code{output_alternate_entry_point}, in
@file{final.c}.

To set the kind of a label, use the @code{SET_LABEL_KIND} macro.

@findex jump_table_data
@item jump_table_data
A @code{jump_table_data} insn is a placeholder for the jump-table data
of a @code{casesi} or @code{tablejump} insn.  They are placed after
a @code{tablejump_p} insn.  A @code{jump_table_data} insn is not part o
a basic blockm but it is associated with the basic block that ends with
the @code{tablejump_p} insn.  The @code{PATTERN} of a @code{jump_table_data}
is always either an @code{addr_vec} or an @code{addr_diff_vec}, and a
@code{jump_table_data} insn is always preceded by a @code{code_label}.
The @code{tablejump_p} insn refers to that @code{code_label} via its
@code{JUMP_LABEL}.

@findex barrier
@item barrier
Barriers are placed in the instruction stream when control cannot flow
past them.  They are placed after unconditional jump instructions to
indicate that the jumps are unconditional and after calls to
@code{volatile} functions, which do not return (e.g., @code{exit}).
They contain no information beyond the three standard fields.

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@code{note} insns are used to represent additional debugging and
declarative information.  They contain two nonstandard fields, an
integer which is accessed with the macro @code{NOTE_LINE_NUMBER} and a
string accessed with @code{NOTE_SOURCE_FILE}.

If @code{NOTE_LINE_NUMBER} is positive, the note represents the
position of a source line and @code{NOTE_SOURCE_FILE} is the source file name
that the line came from.  These notes control generation of line
number data in the assembler output.

Otherwise, @code{NOTE_LINE_NUMBER} is not really a line number but a
code with one of the following values (and @code{NOTE_SOURCE_FILE}
must contain a null pointer):

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
Such a note is completely ignorable.  Some passes of the compiler
delete insns by altering them into notes of this kind.

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
This marks what used to be a @code{code_label}, but was not used for other
purposes than taking its address and was transformed to mark that no
code jumps to it.

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
These types of notes indicate the position of the beginning and end
of a level of scoping of variable names.  They control the output
of debugging information.

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
These types of notes indicate the position of the beginning and end of a
level of scoping for exception handling.  @code{NOTE_EH_HANDLER}
identifies which region is associated with these notes.

@findex NOTE_INSN_FUNCTION_BEG
@item NOTE_INSN_FUNCTION_BEG
Appears at the start of the function body, after the function
prologue.

@findex NOTE_INSN_VAR_LOCATION
@findex NOTE_VAR_LOCATION
@item NOTE_INSN_VAR_LOCATION
This note is used to generate variable location debugging information.
It indicates that the user variable in its @code{VAR_LOCATION} operand
is at the location given in the RTL expression, or holds a value that
can be computed by evaluating the RTL expression from that static
point in the program up to the next such note for the same user
variable.

@end table

これらのコードは、デバッギングダンプにはシンボルで表示される。

@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
The machine mode of an insn is normally @code{VOIDmode}, but some
phases use the mode for various purposes.

The common subexpression elimination pass sets the mode of an insn to
@code{QImode} when it is the first insn in a block that has already
been processed.

The second Haifa scheduling pass, for targets that can multiple issue,
sets the mode of an insn to @code{TImode} when it is believed that the
instruction begins an issue group.  That is, when the instruction
cannot issue simultaneously with the previous.  This may be relied on
by later passes, in particular machine-dependent reorg.

Here is a table of the extra fields of @code{insn}, @code{jump_insn}
and @code{call_insn} insns:

@table @code
@findex PATTERN
@item PATTERN (@var{i})
An expression for the side effect performed by this insn.  This must
be one of the following codes: @code{set}, @code{call}, @code{use},
@code{clobber}, @code{return}, @code{simple_return}, @code{asm_input},
@code{asm_output}, @code{addr_vec}, @code{addr_diff_vec},
@code{trap_if}, @code{unspec}, @code{unspec_volatile},
@code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a
@code{parallel}, each element of the @code{parallel} must be one these
codes, except that @code{parallel} expressions cannot be nested and
@code{addr_vec} and @code{addr_diff_vec} are not permitted inside a
@code{parallel} expression.

@findex INSN_CODE
@item INSN_CODE (@var{i})
An integer that says which pattern in the machine description matches
this insn, or @minus{}1 if the matching has not yet been attempted.

Such matching is never attempted and this field remains @minus{}1 on an insn
whose pattern consists of a single @code{use}, @code{clobber},
@code{asm_input}, @code{addr_vec} or @code{addr_diff_vec} expression.

@findex asm_noperands
Matching is also never attempted on insns that result from an @code{asm}
statement.  These contain at least one @code{asm_operands} expression.
The function @code{asm_noperands} returns a non-negative value for
such insns.

In the debugging output, this field is printed as a number followed by
a symbolic representation that locates the pattern in the @file{md}
file as some small positive or negative offset from a named pattern.

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
A list (chain of @code{insn_list} expressions) giving information about
dependencies between instructions within a basic block.  Neither a jump
nor a label may come between the related insns.  These are only used by
the schedulers and by combine.  This is a deprecated data structure.
Def-use and use-def chains are now preferred.

@findex REG_NOTES
@item REG_NOTES (@var{i})
A list (chain of @code{expr_list}, @code{insn_list} and @code{int_list}
expressions) giving miscellaneous information about the insn.  It is often
information pertaining to the registers used in this insn.
@end table

The @code{LOG_LINKS} field of an insn is a chain of @code{insn_list}
expressions.  Each of these has two operands: the first is an insn,
and the second is another @code{insn_list} expression (the next one in
the chain).  The last @code{insn_list} in the chain has a null pointer
as second operand.  The significant thing about the chain is which
insns appear in it (as first operands of @code{insn_list}
expressions).  Their order is not significant.

This list is originally set up by the flow analysis pass; it is a null
pointer until then.  Flow only adds links for those data dependencies
which can be used for instruction combination.  For each insn, the flow
analysis pass adds a link to insns which store into registers values
that are used for the first time in this insn.

The @code{REG_NOTES} field of an insn is a chain similar to the
@code{LOG_LINKS} field but it includes @code{expr_list} and @code{int_list}
expressions in addition to @code{insn_list} expressions.  There are several
kinds of register notes, which are distinguished by the machine mode, which
in a register note is really understood as being an @code{enum reg_note}.
The first operand @var{op} of the note is data whose meaning depends on
the kind of note.

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
The macro @code{REG_NOTE_KIND (@var{x})} returns the kind of
register note.  Its counterpart, the macro @code{PUT_REG_NOTE_KIND
(@var{x}, @var{newkind})} sets the register note type of @var{x} to be
@var{newkind}.

Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set
of values that are only used in @code{LOG_LINKS}.

These register notes annotate inputs to an insn:

@table @code
@findex REG_DEAD
@item REG_DEAD
The value in @var{op} dies in this insn; that is to say, altering the
value immediately after this insn would not affect the future behavior
of the program.

It does not follow that the register @var{op} has no useful value after
this insn since @var{op} is not necessarily modified by this insn.
Rather, no subsequent instruction uses the contents of @var{op}.

@findex REG_UNUSED
@item REG_UNUSED
The register @var{op} being set by this insn will not be used in a
subsequent insn.  This differs from a @code{REG_DEAD} note, which
indicates that the value in an input will not be used subsequently.
These two notes are independent; both may be present for the same
register.

@findex REG_INC
@item REG_INC
The register @var{op} is incremented (or decremented; at this level
there is no distinction) by an embedded side effect inside this insn.
This means it appears in a @code{post_inc}, @code{pre_inc},
@code{post_dec} or @code{pre_dec} expression.

@findex REG_NONNEG
@item REG_NONNEG
The register @var{op} is known to have a nonnegative value when this
insn is reached.  This is used so that decrement and branch until zero
instructions, such as the m68k dbra, can be matched.

The @code{REG_NONNEG} note is added to insns only if the machine
description has a @samp{decrement_and_branch_until_zero} pattern.

@findex REG_LABEL_OPERAND
@item REG_LABEL_OPERAND
This insn uses @var{op}, a @code{code_label} or a @code{note} of type
@code{NOTE_INSN_DELETED_LABEL}, but is not a @code{jump_insn}, or it
is a @code{jump_insn} that refers to the operand as an ordinary
operand.  The label may still eventually be a jump target, but if so
in an indirect jump in a subsequent insn.  The presence of this note
allows jump optimization to be aware that @var{op} is, in fact, being
used, and flow optimization to build an accurate flow graph.

@findex REG_LABEL_TARGET
@item REG_LABEL_TARGET
This insn is a @code{jump_insn} but not an @code{addr_vec} or
@code{addr_diff_vec}.  It uses @var{op}, a @code{code_label} as a
direct or indirect jump target.  Its purpose is similar to that of
@code{REG_LABEL_OPERAND}.  This note is only present if the insn has
multiple targets; the last label in the insn (in the highest numbered
insn-field) goes into the @code{JUMP_LABEL} field and does not have a
@code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.

@findex REG_CROSSING_JUMP
@item REG_CROSSING_JUMP
This insn is a branching instruction (either an unconditional jump or
an indirect jump) which crosses between hot and cold sections, which
could potentially be very far apart in the executable.  The presence
of this note indicates to other optimizations that this branching
instruction should not be ``collapsed'' into a simpler branching
construct.  It is used when the optimization to partition basic blocks
into hot and cold sections is turned on.

@findex REG_SETJMP
@item REG_SETJMP
Appears attached to each @code{CALL_INSN} to @code{setjmp} or a
related function.
@end table

The following notes describe attributes of outputs of an insn:

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
This note is only valid on an insn that sets only one register and
indicates that that register will be equal to @var{op} at run time; the
scope of this equivalence differs between the two types of notes.  The
value which the insn explicitly copies into the register may look
different from @var{op}, but they will be equal at run time.  If the
output of the single @code{set} is a @code{strict_low_part} expression,
the note refers to the register that is contained in @code{SUBREG_REG}
of the @code{subreg} expression.

For @code{REG_EQUIV}, the register is equivalent to @var{op} throughout
the entire function, and could validly be replaced in all its
occurrences by @var{op}.  (``Validly'' here refers to the data flow of
the program; simple replacement may make some insns invalid.)  For
example, when a constant is loaded into a register that is never
assigned any other value, this kind of note is used.

When a parameter is copied into a pseudo-register at entry to a function,
a note of this kind records that the register is equivalent to the stack
slot where the parameter was passed.  Although in this case the register
may be set by other insns, it is still valid to replace the register
by the stack slot throughout the function.

A @code{REG_EQUIV} note is also used on an instruction which copies a
register parameter into a pseudo-register at entry to a function, if
there is a stack slot where that parameter could be stored.  Although
other insns may set the pseudo-register, it is valid for the compiler to
replace the pseudo-register by stack slot throughout the function,
provided the compiler ensures that the stack slot is properly
initialized by making the replacement in the initial copy instruction as
well.  This is used on machines for which the calling convention
allocates stack space for register parameters.  See
@code{REG_PARM_STACK_SPACE} in @ref{Stack Arguments}.

In the case of @code{REG_EQUAL}, the register that is set by this insn
will be equal to @var{op} at run time at the end of this insn but not
necessarily elsewhere in the function.  In this case, @var{op}
is typically an arithmetic expression.  For example, when a sequence of
insns such as a library call is used to perform an arithmetic operation,
this kind of note is attached to the insn that produces or copies the
final value.

These two notes are used in different ways by the compiler passes.
@code{REG_EQUAL} is used by passes prior to register allocation (such as
common subexpression elimination and loop optimization) to tell them how
to think of that value.  @code{REG_EQUIV} notes are used by register
allocation to indicate that there is an available substitute expression
(either a constant or a @code{mem} expression for the location of a
parameter on the stack) that may be used in place of a register if
insufficient registers are available.

Except for stack homes for parameters, which are indicated by a
@code{REG_EQUIV} note and are not useful to the early optimization
passes and pseudo registers that are equivalent to a memory location
throughout their entire life, which is not detected until later in
the compilation, all equivalences are initially indicated by an attached
@code{REG_EQUAL} note.  In the early stages of register allocation, a
@code{REG_EQUAL} note is changed into a @code{REG_EQUIV} note if
@var{op} is a constant and the insn represents the only set of its
destination register.

Thus, compiler passes prior to register allocation need only check for
@code{REG_EQUAL} notes and passes subsequent to register allocation
need only check for @code{REG_EQUIV} notes.
@end table

These notes describe linkages between insns.  They occur in pairs: one
insn has one of a pair of notes that points to a second insn, which has
the inverse note pointing back to the first insn.

@table @code
@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
On machines that use @code{cc0}, the insns which set and use @code{cc0}
set and use @code{cc0} are adjacent.  However, when branch delay slot
filling is done, this may no longer be true.  In this case a
@code{REG_CC_USER} note will be placed on the insn setting @code{cc0} to
point to the insn using @code{cc0} and a @code{REG_CC_SETTER} note will
be placed on the insn using @code{cc0} to point to the insn setting
@code{cc0}.
@end table

These values are only used in the @code{LOG_LINKS} field, and indicate
the type of dependency that each link represents.  Links which indicate
a data dependence (a read after write dependence) do not use any code,
they simply have mode @code{VOIDmode}, and are printed without any
descriptive text.

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
This indicates a true dependence (a read after write dependence).

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
This indicates an output dependence (a write after write dependence).

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
This indicates an anti dependence (a write after read dependence).

@end table

These notes describe information gathered from gcov profile data.  They
are stored in the @code{REG_NOTES} field of an insn.

@table @code
@findex REG_BR_PROB
@item REG_BR_PROB
This is used to specify the ratio of branches to non-branches of a
branch insn according to the profile data.  The note is represented
as an @code{int_list} expression whose integer value is between 0 and
REG_BR_PROB_BASE.  Larger values indicate a higher probability that
the branch will be taken.

@findex REG_BR_PRED
@item REG_BR_PRED
These notes are found in JUMP insns after delayed branch scheduling
has taken place.  They indicate both the direction and the likelihood
of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression
is used in place of the actual insn pattern.  This is done in cases where
the pattern is either complex or misleading.
@end table

For convenience, the machine mode in an @code{insn_list} or
@code{expr_list} is printed using these symbolic codes in debugging dumps.

@findex insn_list
@findex expr_list
The only difference between the expression codes @code{insn_list} and
@code{expr_list} is that the first operand of an @code{insn_list} is
assumed to be an insn and is printed in debugging dumps as the insn's
unique id; the first operand of an @code{expr_list} is printed in the
ordinary way as an expression.

@node Calls
@section RTL Representation of Function-Call Insns
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

サブルーチンを呼び出す insn は、RTL 式コードが @code{call_insn} になる。
サブルーチン呼び出し insn は特別な規則に従う必要があり、
本体部分で特別な RTL 式コード @code{call} を使わなければならない。

@cindex @code{call} usage
@code{call} 式は、以下のようにオペランドを二つ取る。

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
ここで、@var{nbytes} は、サブルーチンに渡される引数データのバイト数を
表すオペランドである。@var{fm} はマシンモードであり、
@var{addr} はサブルーチンのアドレスを表す。
@var{fm} は、マシン記述の @code{FUNCTION_MODE} マクロの定義と
同じでなければならない。

値を返さないサブルーチンについては、上に示した @code{call} 式そのものが
insn の全体になる。ただし、@code{use} 式か @code{clobber} 式を
その他に含んでいる必要がある。

@cindex @code{BLKmode}, and function return values
戻り値があり、そのモードが @code{BLKmode} でないサブルーチンについては、
戻り値はハードレジスタに置かれる。このレジスタの番号が @var{r} なら、
call insn の本体は以下のようになる。

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
この RTL 式は、この insn で、適切なレジスタに有効な値が置かれる
ことを(最適化パスに対して)はっきりさせる。

サブルーチンが @code{BLKmode} の値を返すなら、
その値を格納すべき位置のアドレスをサブルーチンに渡すという処理が
行なわれる。このため、call insn 自身はどんな値も返さないので、
値を返さない呼び出しと同じ形式の RTL になる。

マシンによっては、call 命令自身が幾つかのレジスタを、例えば
戻り先アドレスを保持するために、破壊する。
そういうマシンでの @code{call_insn} insn の本体は、
@code{call} 式と @code{clobber} 式の両方を持つ、一個の @code{parallel}
とすべきである。この @code{clobber} 式は、どのレジスタが破壊されるかを
示す。
同様に、call 命令が、スタックポインタ以外に、RTL で明示的に指定
されていないレジスタを必要とするときは、@code{use} 副式がそのレジスタに
ついて言及すべきである。

呼び出される関数は、コンフィギュレーションマクロ @code{CALL_USED_REGISTERS}
(@pxref{Register Basics})に列挙されている全てのレジスタを修正し、
@code{const} 関数とライブラリ呼びだしを例外として、全メモリを
修正すると仮定される。

単に @code{use} 式を含む insn は、どのレジスタが関数への入力を
保持しているかを示す @code{call_insn} の直前に位置する。
同様に、@code{CALL_USED_REGISTERS} で指定されている以外のレジスタが
呼び出された関数により上書きされるなら、単独の @code{clobber} を
含む insn は、それがどのレジスタかを示すために、その呼び出しの直後に
置かれる。

@node Sharing
@section Structure Sharing Assumptions
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

GNU CC は、ある種類の RTL 式は一意的であることを仮定している。
すなわち、同じ値を表す二つの異なるオブジェクトは存在しないと
仮定しているのである。
一方、それとは逆の、
ある種類の RTL 式オブジェクトは、それを含む構造の中では 2 回以上
現れることはないという仮定をしている場合もある。

これらの仮定は一個の関数に関するものである。
グローバル変数や外部関数を記述する RTL オブジェクト、
それに小さな整数定数のような2,3の基本的なオブジェクトを除いて、
二つの関数に共通の RTL オブジェクトは存在しない。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
各疑似レジスタは、それを表現する @code{reg} オブジェクトは一個しか
持たず、そのため、マシンモードも一個しかない。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
記号名ラベルはどれも、それを参照する @code{symbol_ref} オブジェクトは
一個しかない。

@cindex @code{const_int}, RTL sharing
@item
値が 0、1、@minus{}1 の @code{const_int} 式はそれぞれ一個だけである。
それ以外の幾つかの整数値も一意的に格納される。

@cindex @code{pc}, RTL sharing
@item
@code{pc} 式は一個しかない。

@cindex @code{cc0}, RTL sharing
@item
@code{cc0} 式は一個しかない。

@cindex @code{const_double}, RTL sharing
@item
それぞれの浮動小数点モードで、値 0 の @code{const_double} 式は
それぞれ一個しかない。値が 1 と 2 についても同様である。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
@code{label_ref} や @code{scratch} は、RTL 構造体の中で
二箇所以上は現れない。言い換えると、関数の中の全 insn をツリーウォーク
したときに、@code{label_ref} や @code{scratch} が見つかるたびに、
すでに見た他の全てとは違ったものであると仮定しても良い。

@cindex @code{mem}, RTL sharing
@item
各静的変数やスタックスロットについては、普通はただ一個の @code{mem}
オブジェクトが作られる。このため、これらのオブジェクトはそれが現れる
全ての場所で共用されることが多い。
しかし、これらの変数に対して、等価であるが別の独立したオブジェクトが
作られることがたまにある。

@cindex @code{asm_operands}, RTL sharing
@item
一個の @code{asm} 文に複数の出力オペランドがあると、
出力オペランド毎に別々の @code{asm_operands} 式が作られる。
しかし、これらの式は全て、入力オペランドの列を含むベクトルを共有する。
この共有は後で、二つの @code{asm_operands} 式が同じ文に由来するものか
どうかを調べるのに使われる。このため、全ての最適化で、
ベクトルを全部コピーした場合には注意深く共有を維持しなくては
ならない。

@item
上で説明したものを除いて、RTL 構造体に RTL オブジェクトが二箇所以上に
現れることはない。コンパイラのパスの多くが、このことに依存しており、
他の insn に不要な副作用を与えることなく RTL オブジェクトを直接
修正可能であるということを仮定している。

@findex unshare_all_rtl
@item
最初の RTL 生成の間は、共有される構造体が自由に導入される。
ある関数についての 全 RTL 生成が完了した後で、
全ての共有される構造体が @file{emit-rtl.c} の @code{unshare_all_rtl}
関数によりコピーされる。その後で上記のルールが成り立つことが保証される。

@findex copy_rtx_if_shared
@item
組合せパスの間、ある insn 中の共有構造体が一時的に存在できる。
しかし、共有構造体は、組合せパスがその insn についての処理を終了
する前に、コピーされる。
これは @code{copy_rtx_if_shared} を呼び出すことにより行なわれる。
この関数は @code{unshare_all_rtl} のサブルーチンである。
@end itemize

@node Reading RTL
@section Reading RTL

ファイルから RTL オブジェクトを読み込むには、@code{read_rtx} 関数を
使う。引数は、標準入力ストリーム一つであり、一個の RTL オブジェクトを
返す。

ファイルから RTL を読む処理は非常に遅い。現時点ではこれは問題ではない。
RTL の読み込みは、コンパイラを構築するときにのみ行われるからである。

RTL をテキストとしてファイルにセーブして、GNU CC の言語フロントエンドと
その他の部分とのインターフェースとして使おうと考える人が良くいるが、
これは実現不可能である。

GNU CC は、RTL を内部表現として使うようにしか設計されていない。
ある与えられたプログラムに対する正しい RTL は、特定のターゲットマシンに
著しく依存する。しかも、RTL は、そのプログラムについての情報を
全部は含んでいないのである。

GNU CC と新しい言語フロントエンドのインターフェースを取る正しい方法は、
「tree」データ構造を使う事である。このデータ構造について書いたマニュアルは
ないが、@file{tree.h} と @file{tree.def} で説明されている
