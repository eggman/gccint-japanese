@c Copyright (C) 1988-2015 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@node RTL
@chapter RTL Representation
@cindex RTL representation
@cindex representation of RTL
@cindex Register Transfer Language (RTL)

GCC の仕事の大半は、レジスタ転送言語(RTL)と呼ばれる中間表現に対して
なされる。このレジスタ転送言語では、出力すべき命令を一つづつ、
その命令が行う操作を代数的な形式で記述する。

RTL は、Lisp 言語のリストにヒントを得たものである。RTL は、
他の構造体を指す構造体からなる内部形式と、マシン記述とデバッグ用ダンプ出力
で用いられるテキスト形式の二種類の形式を持つ。テキスト形式では、
内部形式でのポインタを示すのに多重の括弧を使う。

@menu
* RTL Objects::       式、ベクトル、文字列、整数
* RTL Classes::       RTL 式オブジェクトのカテゴリとその構造
* Accessors::         式オペランドやベクトルの要素へのアクセスマクロ群
* Flags::             RTL 式中のフラグ
* Machine Modes::     データの大きさと形式の記述
* Constants::         定数値を持つ式
* Regs and Memory::   レジスタの内容やメモリを表現する式
* Arithmetic::        算術演算を表す式
* Comparisons::       比較演算式を表す式
* Bit-Fields::        メモリまたはレジスタ中のビットフィールドを表す式
* Conversions::       拡張、打切、浮動小数点／固定小数点への変換
* RTL Declarations::  RTL 宣言
* Side Effects::      副作用のある式
* Incdec::            自動インクリメントアドレッシングに含まれる副作用
* Assembler::         オペランドを伴う @code{asm} の表現
* Insns::             insn 全体の式タイプ
* Calls::             関数呼び出し insn の RTL 表現
* Sharing::           式の共有
* Reading RTL::       ファイルからのRTLテキスト形式の読み込み
@end menu

@node RTL Objects
@section RTL Object Types
@cindex RTL object types

@cindex RTL integers
@cindex RTL strings
@cindex RTL vectors
@cindex RTL expression
@cindex RTX (See RTL)
RTL は5種類のオブジェクトを使う。式、整数、幅広整数、文字列、ベクトル
である。式が最も重要である。ある RTL 式(省略形は``RTX'') は、C 言語の
構造体だが、普通はポインタで参照される。RTL 式の型は typedef 名
@code{rtx} で与えられる。

整数は、単に @code{int} である。10進数を使って表記する。
幅広整数は、整数型のオブジェクトのうちで、その型が @code{HOST_WIDE_INT} の
ものである(@pxref{Host Config})。やはり、10進数を使って表記する。

文字列は文字の連なりである。メモリ中では、通常の C 言語の形式である、
@code{char *} で表現され、C 言語と同じ文法にしたがって表記する。
ただし、RTL での文字列は決してヌルにはならない。マシン記述中で
空文字列を書いた場合、メモリ中ではヌルポインタではなく、ヌル文字への
ポインタとして表現される。文脈によっては、文字列の代わりにヌルポインタ
を使っても有効である。RTL のコード内では、文字列は @code{symbol_ref} 式
の中で最も良く使われる。しかし、マシン記述を構成する RTL 式の他の
文脈にも現れる。

ベクトルは、式を指す任意個数のポインタから成る。ベクトルの要素数は
ベクトルの中で明示的に表現される。ベクトルは、
空白で区切られた要素を順番に並べたものを、鍵括弧(@samp{[@dots{}]})で
囲んで表記する。長さ 0 のベクトルは作成されない。代わりに
ヌルポインタが使われる。

@cindex expression codes
@cindex codes, RTL expression
@findex GET_CODE
@findex PUT_CODE
式は@dfn{式コード}(または RTX コードと呼ばれる) で分類される。
式コードは @file{rtl.def} で定義される名前であり、大文字で記述した
C の列挙型定数でもある。許される式コードとその意味は機種には依存しない。
ある RTX のコードはマクロ @code{GET_CODE (@var{x})} によって
取り出すことができ、また、マクロ @code{PUT_CODE (@var{x}, @var{newcode})}
で変更することができる。

式コードは、式の中にオペランドが幾つあるか、およびオペランドがどんな種類の
オブジェクトかを決定する。
Lisp と違って RTL では、オペランドを見てもどんな種類の
オブジェクトか知ることはできない。代わりに、文脈から知る必要がある。
つまり、オペランドを含む式の式コードから知る必要がある。
例えば、式コードが @code{subreg} である式の中では、最初のオペランドが
式と見なされ、二番目のオペランドが整数とみなされる。式コード @code{plus}
の式では、二つのオペランドがあり、どちらも式としてみなされる。
式コード @code{symbol_ref} の式では、オペランドは一つであり、
文字列としてみなされる。

式は、式のタイプ名と、そのフラグとあればマシンモード、式のオペランドを
空白で区切り、括弧で囲んで表記する。

式コード名は、@samp{md} ファイル中では小文字で書くが、
C のコードとしては大文字となって現れる。このマニュアルでは、
@code{const_int} のように書くことにする。

@cindex (nil)
@cindex nil
通常、式が要求される場合でも、ヌルポインタが有効なコンテキストが
二、三存在する。その場合には、@code{(nil)} と表記する。

@node RTL Classes
@section RTL Classes and Formats
@cindex RTL classes
@cindex classes of RTX codes
@cindex RTX codes, classes of
@findex GET_RTX_CLASS

様々な式コードは幾つかの@dfn{クラス}に分類される。そのクラスは
一文字で表現される。ある RTX コードのクラスは、マクロ
@code{GET_RTX_CLASS (@var{code})} を使って知ることができる。
現在、@file{rtx.def} では以下のクラスを定義している。

@table @code
@item RTX_OBJ
An RTX code that represents an actual object, such as a register
(@code{REG}) or a memory location (@code{MEM}, @code{SYMBOL_REF}).
@code{LO_SUM}) is also included; instead, @code{SUBREG} and
@code{STRICT_LOW_PART} are not in this class, but in class @code{x}.

@item RTX_CONST_OBJ
An RTX code that represents a constant object.  @code{HIGH} is also
included in this class.

@item RTX_COMPARE
An RTX code for a non-symmetric comparison, such as @code{GEU} or
@code{LT}.

@item RTX_COMM_COMPARE
An RTX code for a symmetric (commutative) comparison, such as @code{EQ}
or @code{ORDERED}.

@item RTX_UNARY
An RTX code for a unary arithmetic operation, such as @code{NEG},
@code{NOT}, or @code{ABS}.  This category also includes value extension
(sign or zero) and conversions between integer and floating point.

@item RTX_COMM_ARITH
An RTX code for a commutative binary operation, such as @code{PLUS} or
@code{AND}.  @code{NE} and @code{EQ} are comparisons, so they have class
@code{<}.

@item RTX_BIN_ARITH
An RTX code for a non-commutative binary operation, such as @code{MINUS},
@code{DIV}, or @code{ASHIFTRT}.

@item RTX_BITFIELD_OPS
An RTX code for a bit-field operation.  Currently only
@code{ZERO_EXTRACT} and @code{SIGN_EXTRACT}.  These have three inputs
and are lvalues (so they can be used for insertion as well).
@xref{Bit-Fields}.

@item RTX_TERNARY
An RTX code for other three input operations.  Currently only
@code{IF_THEN_ELSE},  @code{VEC_MERGE}, @code{SIGN_EXTRACT},
@code{ZERO_EXTRACT}, and @code{FMA}.

@item RTX_INSN
An RTX code for an entire instruction:  @code{INSN}, @code{JUMP_INSN}, and
@code{CALL_INSN}.  @xref{Insns}.

@item RTX_MATCH
An RTX code for something that matches in insns, such as
@code{MATCH_DUP}.  These only occur in machine descriptions.

@item RTX_AUTOINC
An RTX code for an auto-increment addressing mode, such as
@code{POST_INC}.  @samp{XEXP (@var{x}, 0)} gives the auto-modified
register.

@item RTX_EXTRA
All other RTX codes.  This category includes the remaining codes used
only in machine descriptions (@code{DEFINE_*}, etc.).  It also includes
all the codes describing side effects (@code{SET}, @code{USE},
@code{CLOBBER}, etc.) and the non-insns that may appear on an insn
chain, such as @code{NOTE}, @code{BARRIER}, and @code{CODE_LABEL}.
@code{SUBREG} is also part of this class.
@end table

@cindex RTL format
@file{rtl.def} には、式のタイプ毎に、その式が含むオブジェクトの数と
その性質が@dfn{フォーマット}と呼ぶ式 コードを表す文字の連なりで記述されている。
例えば、@code{subreg} のフォーマットは @samp{ei} となる。

@cindex RTL format characters
以下のフォーマット指定文字列がよく使われる。

@table @code
@item e
式(実際には式へのポインタ)

@item i
整数

@item w
幅広整数

@item s
文字列

@item E
式のベクトル
@end table

その他に以下のフォーマット指定文字が使われる。

@table @code
@item u
@samp{u} は、デバッグ用ダンプで異なった表示がなされる以外は
@samp{e} に同じである。insn へのポインタで使われる。

@item n
@samp{n} は、デバッグ用ダンプで異なった表示がなされる以外は @samp{i} に
同じである。@code{note} insn で行番号やコード番号のために使われる。

@item S
@samp{S} は省略可能な文字列を示す。メモリ中での RTL オブジェクトでは、
@samp{S} は @samp{s} に同じであるが、@samp{md} ファイルからオブジェクトを
読み込む場合には、このオペランドの文字列値は省かれる。省かれた文字列は
ヌル文字列であるとして扱われる。

@item V
@samp{V} は省略可能なベクトルを示す。メモリ中での RTL オブジェクトでは、
@samp{V} は @samp{E} に同じであるが、@samp{md} ファイルからオブジェクトを
読み込む場合には、このオペランドのベクトル値は省かれる。省かれたベクトルは、
実質的には要素が一つもないベクトルと同じである。

@item 0
@samp{0} は、通常のカテゴリには収まらないものを入れるためのスロット
であることを意味する。@samp{0} のスロットは、どのダンプにも表示されず、
gcc の極く一部で特別な使われ方をする。
@end table

以下は、オペランド数、式コードのフォーマットを得るためのマクロである。

@table @code
@findex GET_RTX_LENGTH
@item GET_RTX_LENGTH (@var{code})
コードが @var{code} である RTX のオペランド数。

@findex GET_RTX_FORMAT
@item GET_RTX_FORMAT (@var{code})
コードが @var{code} である RTX のフォーマットを C の文字列で
表したもの。
@end table

RTX コードの幾つかのクラスは常に同じフォーマットである。
例えば、全ての比較演算のフォーマットは @code{ee} であると想定しても
安全である。

@table @code
@item 1
このクラスのコードのフォーマットは全て @code{e} である。

@item <
@itemx c
@itemx 2
このクラスのコードのフォーマットは全て @code{ee} である。

@item b
@itemx 3
このクラスのコードのフォーマットは全て @code{eee} である。

@item i
このクラスのコードのフォーマットは全て @code{iuueiee} で始まる。
ある insn の連鎖にリンクされた RTL オブジェクトのクラスが全て
@code{i} ではないことに注意。

@item o
@itemx m
@itemx x
これらのコードのフォーマットについては何ら想定を置くことはできない。
@end table

@node Accessors
@section Access to Operands
@cindex accessors
@cindex access to operands
@cindex operand access

@findex XEXP
@findex XINT
@findex XWINT
@findex XSTR
式中のオペランドは、@code{XEXP} や @code{XINT}、@code{XWINT}、それに
@code{XSTR} というマクロを使って参照することができる。これらのマクロは
それぞれ引数を二つ取る。RTL式のポインタ(RTX) とオペランドの番号である。
オペランドの番号は 0 からはじまる。例えば、

@smallexample
XEXP (@var{x}, 2)
@end smallexample

@noindent
とあれば、式 @var{x} の二番目のオペランドを式として参照する。

@smallexample
XINT (@var{x}, 2)
@end smallexample

@noindent
こちらは、同じオペランドを整数として参照する。同様に、@code{XSTR} を
使うと文字列として参照する。

どんなオペランドも整数として、あるいは式として、また文字列として
参照できる。ユーザは、オペランドに実際貯えられている値の種類に
応じて、正しい参照方法を選ばなければならない。これは、
オペランドを含んでいる式の式コードを見て判断するのが良い。
また、オペランド数を調べるのも式コードで調べることができる。

例えば、@var{x} が @code{subreg} 式なら、オペランドは二つあり、
それぞれ @code{XEXP (@var{x}, 0)} と @code{XINT (@var{x}, 0)} として
正しく参照できる。@code{XINT (@var{x}, 0)} とすると、
オペランド 0 の式のアドレスを整数にキャストしたものが得られる。
こういう参照の仕方が有効な場合は滅多にないと思うが、もし書くなら
@code{(int) XEXP (@var{x}, 0)} としたほうがきれいである。
また @code{XEXP (@var{x}, 1)} という書き方もエラー無しでコンパイル
できて、二番目の整数オペランドを式のポインタにキャストした結果を
返す。しかし、それを参照したときに恐らくプログラムが落ちてしまう。
さらには、@code{XEXP (@var{x}, 28)} のように書くこともできるが、
式の終りを越えたメモリをアクセスし、予期できない結果に終わるだろう。

オペランドがベクトルの場合の参照方法はもっと複雑である。
マクロ @code{XVEC} を使うとベクトルへのポインタそのものが得られ、
@code{XVECEXP} と @code{XVECLEN} を使うとそれぞれ、ベクトルの要素と
長さを得ることができる。

@table @code
@findex XVEC
@item XVEC (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドを
ベクトルへのポインタとして参照する。

@findex XVECLEN
@item XVECLEN (@var{exp}, @var{idx})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの長さを返す。
この値は @code{int} 型である。

@findex XVECEXP
@item XVECEXP (@var{exp}, @var{idx}, @var{eltnum})
式 @var{exp} の @var{idx} 番目のオペランドであるベクトルの @var{eltnum}
番目の要素を参照する。この値は RTX である。

@var{eltnum} が負でないことおよび @code{XVECLEN (@var{exp}, @var{idx})}
より小さいことを保証するのはユーザの責任である。
@end table

このセクションで定義したマクロは全て左辺値として展開されるので、
単に参照するだけでなく、オペランドや長さやベクトルの要素を代入する
ことができる。

@node Flags
@section Flags in an RTL Expression
@cindex flags in RTL expression

RTL 式は、ある種の型の式で使われる色々なフラグ(一ビットのビットフィールド)と
その他の値を含んでいる。ほとんどの場合、フラグは以下のマクロで
参照される。

@table @code
@findex CONSTANT_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/u}
@cindex @code{unchanging}, in @code{symbol_ref}
@item CONSTANT_POOL_ADDRESS_P (@var{x})
Nonzero in a @code{symbol_ref} if it refers to part of the current
function's constant pool.  For most targets these addresses are in a
@code{.rodata} section entirely separate from the function, but for
some targets the addresses are close to the beginning of the function.
In either case GCC assumes these addresses can be addressed directly,
perhaps with the help of base registers.
Stored in the @code{unchanging} field and printed as @samp{/u}.

@findex RTL_CONST_CALL_P
@cindex @code{call_insn} and @samp{/u}
@cindex @code{unchanging}, in @code{call_insn}
@item RTL_CONST_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a call to a
const function.  Stored in the @code{unchanging} field and printed as
@samp{/u}.

@findex RTL_PURE_CALL_P
@cindex @code{call_insn} and @samp{/i}
@cindex @code{return_val}, in @code{call_insn}
@item RTL_PURE_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a call to a
pure function.  Stored in the @code{return_val} field and printed as
@samp{/i}.

@findex RTL_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/u} or @samp{/i}
@item RTL_CONST_OR_PURE_CALL_P (@var{x})
In a @code{call_insn}, true if @code{RTL_CONST_CALL_P} or
@code{RTL_PURE_CALL_P} is true.

@findex RTL_LOOPING_CONST_OR_PURE_CALL_P
@cindex @code{call_insn} and @samp{/c}
@cindex @code{call}, in @code{call_insn}
@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})
In a @code{call_insn} indicates that the insn represents a possibly
infinite looping call to a const or pure function.  Stored in the
@code{call} field and printed as @samp{/c}.  Only true if one of
@code{RTL_CONST_CALL_P} or @code{RTL_PURE_CALL_P} is true.

@findex INSN_ANNULLED_BRANCH_P
@cindex @code{jump_insn} and @samp{/u}
@cindex @code{call_insn} and @samp{/u}
@cindex @code{insn} and @samp{/u}
@cindex @code{unchanging}, in @code{jump_insn}, @code{call_insn} and @code{insn}
@item INSN_ANNULLED_BRANCH_P (@var{x})
In a @code{jump_insn}, @code{call_insn}, or @code{insn} indicates
that the branch is an annulling one.  See the discussion under
@code{sequence} below.  Stored in the @code{unchanging} field and
printed as @samp{/u}.

@findex INSN_DELETED_P
@cindex @code{insn} and @samp{/v}
@cindex @code{call_insn} and @samp{/v}
@cindex @code{jump_insn} and @samp{/v}
@cindex @code{code_label} and @samp{/v}
@cindex @code{jump_table_data} and @samp{/v}
@cindex @code{barrier} and @samp{/v}
@cindex @code{note} and @samp{/v}
@cindex @code{volatil}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label}, @code{jump_table_data}, @code{barrier}, and @code{note}
@item INSN_DELETED_P (@var{x})
In an @code{insn}, @code{call_insn}, @code{jump_insn}, @code{code_label},
@code{jump_table_data}, @code{barrier}, or @code{note},
nonzero if the insn has been deleted.  Stored in the
@code{volatil} field and printed as @samp{/v}.

@findex INSN_FROM_TARGET_P
@cindex @code{insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{in_struct}, in @code{insn} and @code{jump_insn} and @code{call_insn}
@item INSN_FROM_TARGET_P (@var{x})
In an @code{insn} or @code{jump_insn} or @code{call_insn} in a delay
slot of a branch, indicates that the insn
is from the target of the branch.  If the branch insn has
@code{INSN_ANNULLED_BRANCH_P} set, this insn will only be executed if
the branch is taken.  For annulled branches with
@code{INSN_FROM_TARGET_P} clear, the insn will be executed only if the
branch is not taken.  When @code{INSN_ANNULLED_BRANCH_P} is not set,
this insn will always be executed.  Stored in the @code{in_struct}
field and printed as @samp{/s}.

@findex LABEL_PRESERVE_P
@cindex @code{code_label} and @samp{/i}
@cindex @code{note} and @samp{/i}
@cindex @code{in_struct}, in @code{code_label} and @code{note}
@item LABEL_PRESERVE_P (@var{x})
In a @code{code_label} or @code{note}, indicates that the label is referenced by
code or data not visible to the RTL of a given function.
Labels referenced by a non-local goto will have this bit set.  Stored
in the @code{in_struct} field and printed as @samp{/s}.

@findex LABEL_REF_NONLOCAL_P
@cindex @code{label_ref} and @samp{/v}
@cindex @code{reg_label} and @samp{/v}
@cindex @code{volatil}, in @code{label_ref} and @code{reg_label}
@item LABEL_REF_NONLOCAL_P (@var{x})
In @code{label_ref} and @code{reg_label} expressions, nonzero if this is
a reference to a non-local label.
Stored in the @code{volatil} field and printed as @samp{/v}.

@findex MEM_KEEP_ALIAS_SET_P
@cindex @code{mem} and @samp{/j}
@cindex @code{jump}, in @code{mem}
@item MEM_KEEP_ALIAS_SET_P (@var{x})
In @code{mem} expressions, 1 if we should keep the alias set for this
mem unchanged when we access a component.  Set to 1, for example, when we
are already in a non-addressable component of an aggregate.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex MEM_VOLATILE_P
@cindex @code{mem} and @samp{/v}
@cindex @code{asm_input} and @samp{/v}
@cindex @code{asm_operands} and @samp{/v}
@cindex @code{volatil}, in @code{mem}, @code{asm_operands}, and @code{asm_input}
@item MEM_VOLATILE_P (@var{x})
@code{mem} 式において、揮発性のメモリ参照の場合に非 0 となる。
@code{volatil} フィールドに格納され、@samp{/v} と出力される。

@findex MEM_NOTRAP_P
@cindex @code{mem} and @samp{/c}
@cindex @code{call}, in @code{mem}
@item MEM_NOTRAP_P (@var{x})
In @code{mem}, nonzero for memory references that will not trap.
Stored in the @code{call} field and printed as @samp{/c}.

@findex MEM_POINTER
@cindex @code{mem} and @samp{/f}
@cindex @code{frame_related}, in @code{mem}
@item MEM_POINTER (@var{x})
Nonzero in a @code{mem} if the memory reference holds a pointer.
Stored in the @code{frame_related} field and printed as @samp{/f}.

@findex REG_FUNCTION_VALUE_P
@cindex @code{reg} and @samp{/i}
@cindex @code{return_val}, in @code{reg}
@item REG_FUNCTION_VALUE_P (@var{x})
Nonzero in a @code{reg} if it is the place in which this function's
value is going to be returned.  (This happens only in a hard
register.)  Stored in the @code{return_val} field and printed as
@samp{/i}.

@findex REG_POINTER
@cindex @code{reg} and @samp{/f}
@cindex @code{frame_related}, in @code{reg}
@item REG_POINTER (@var{x})
Nonzero in a @code{reg} if the register holds a pointer.  Stored in the
@code{frame_related} field and printed as @samp{/f}.

@findex REG_USERVAR_P
@cindex @code{reg} and @samp{/v}
@cindex @code{volatil}, in @code{reg}
@item REG_USERVAR_P (@var{x})
In a @code{reg}, nonzero if it corresponds to a variable present in
the user's source code.  Zero for temporaries generated internally by
the compiler.  Stored in the @code{volatil} field and printed as
@samp{/v}.

The same hard register may be used also for collecting the values of
functions called by this one, but @code{REG_FUNCTION_VALUE_P} is zero
in this kind of use.

@findex RTX_FRAME_RELATED_P
@cindex @code{insn} and @samp{/f}
@cindex @code{call_insn} and @samp{/f}
@cindex @code{jump_insn} and @samp{/f}
@cindex @code{barrier} and @samp{/f}
@cindex @code{set} and @samp{/f}
@cindex @code{frame_related}, in @code{insn}, @code{call_insn}, @code{jump_insn}, @code{barrier}, and @code{set}
@item RTX_FRAME_RELATED_P (@var{x})
Nonzero in an @code{insn}, @code{call_insn}, @code{jump_insn},
@code{barrier}, or @code{set} which is part of a function prologue
and sets the stack pointer, sets the frame pointer, or saves a register.
This flag should also be set on an instruction that sets up a temporary
register to use in place of the frame pointer.
Stored in the @code{frame_related} field and printed as @samp{/f}.

In particular, on RISC targets where there are limits on the sizes of
immediate constants, it is sometimes impossible to reach the register
save area directly from the stack pointer.  In that case, a temporary
register is used that is near enough to the register save area, and the
Canonical Frame Address, i.e., DWARF2's logical frame pointer, register
must (temporarily) be changed to be this temporary register.  So, the
instruction that sets this temporary register must be marked as
@code{RTX_FRAME_RELATED_P}.

If the marked instruction is overly complex (defined in terms of what
@code{dwarf2out_frame_debug_expr} can handle), you will also have to
create a @code{REG_FRAME_RELATED_EXPR} note and attach it to the
instruction.  This note should contain a simple expression of the
computation performed by this instruction, i.e., one that
@code{dwarf2out_frame_debug_expr} can handle.

This flag is required for exception handling support on targets with RTL
prologues.

@findex MEM_READONLY_P
@cindex @code{mem} and @samp{/u}
@cindex @code{unchanging}, in @code{mem}
@item MEM_READONLY_P (@var{x})
Nonzero in a @code{mem}, if the memory is statically allocated and read-only.

Read-only in this context means never modified during the lifetime of the
program, not necessarily in ROM or in write-disabled pages.  A common
example of the later is a shared library's global offset table.  This
table is initialized by the runtime loader, so the memory is technically
writable, but after control is transferred from the runtime loader to the
application, this memory will never be subsequently modified.

Stored in the @code{unchanging} field and printed as @samp{/u}.

@findex SCHED_GROUP_P
@cindex @code{insn} and @samp{/s}
@cindex @code{call_insn} and @samp{/s}
@cindex @code{jump_insn} and @samp{/s}
@cindex @code{jump_table_data} and @samp{/s}
@cindex @code{in_struct}, in @code{insn}, @code{call_insn}, @code{jump_insn} and @code{jump_table_data}
@item SCHED_GROUP_P (@var{x})
During instruction scheduling, in an @code{insn}, @code{call_insn},
@code{jump_insn} or @code{jump_table_data}, indicates that the
previous insn must be scheduled together with this insn.  This is used to
ensure that certain groups of instructions will not be split up by the
instruction scheduling pass, for example, @code{use} insns before
a @code{call_insn} may not be separated from the @code{call_insn}.
Stored in the @code{in_struct} field and printed as @samp{/s}.

@findex SET_IS_RETURN_P
@cindex @code{insn} and @samp{/j}
@cindex @code{jump}, in @code{insn}
@item SET_IS_RETURN_P (@var{x})
For a @code{set}, nonzero if it is for a return.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex SIBLING_CALL_P
@cindex @code{call_insn} and @samp{/j}
@cindex @code{jump}, in @code{call_insn}
@item SIBLING_CALL_P (@var{x})
For a @code{call_insn}, nonzero if the insn is a sibling call.
Stored in the @code{jump} field and printed as @samp{/j}.

@findex STRING_POOL_ADDRESS_P
@cindex @code{symbol_ref} and @samp{/f}
@cindex @code{frame_related}, in @code{symbol_ref}
@item STRING_POOL_ADDRESS_P (@var{x})
For a @code{symbol_ref} expression, nonzero if it addresses this function's
string constant pool.
Stored in the @code{frame_related} field and printed as @samp{/f}.

@findex SUBREG_PROMOTED_UNSIGNED_P
@cindex @code{subreg} and @samp{/u} and @samp{/v}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_P (@var{x})
Returns a value greater then zero for a @code{subreg} that has
@code{SUBREG_PROMOTED_VAR_P} nonzero if the object being referenced is kept
zero-extended, zero if it is kept sign-extended, and less then zero if it is
extended some other way via the @code{ptr_extend} instruction.
Stored in the @code{unchanging}
field and @code{volatil} field, printed as @samp{/u} and @samp{/v}.
This macro may only be used to get the value it may not be used to change
the value.  Use @code{SUBREG_PROMOTED_UNSIGNED_SET} to change the value.

@findex SUBREG_PROMOTED_UNSIGNED_SET
@cindex @code{subreg} and @samp{/u}
@cindex @code{unchanging}, in @code{subreg}
@cindex @code{volatil}, in @code{subreg}
@item SUBREG_PROMOTED_UNSIGNED_SET (@var{x})
Set the @code{unchanging} and @code{volatil} fields in a @code{subreg}
to reflect zero, sign, or other extension.  If @code{volatil} is
zero, then @code{unchanging} as nonzero means zero extension and as
zero means sign extension.  If @code{volatil} is nonzero then some
other type of extension was done via the @code{ptr_extend} instruction.

@findex SUBREG_PROMOTED_VAR_P
@cindex @code{subreg} and @samp{/s}
@cindex @code{in_struct}, in @code{subreg}
@item SUBREG_PROMOTED_VAR_P (@var{x})
それが、マシン記述マクロ @code{PROMOTED_MODE} (@pxref{Storage Layout})に
従って、より幅の広いモードに拡張されたオブジェクトを参照した際に
作られたものなら、非ゼロである。この場合、@code{subreg} のモードは
そのオブジェクトの宣言されたモードであり、@code{SUBREG_REG} のモードは
そのオブジェクトを保持するレジスタのモードである。
拡張された変数は、それぞれの代入の際に、常に、より幅の広いモードへ
符号拡張またゼロ拡張される。
@code{in_struct} フィールドに格納され、@samp{/s} として出力される。

@findex SYMBOL_REF_USED
@cindex @code{used}, in @code{symbol_ref}
@item SYMBOL_REF_USED (@var{x})
In a @code{symbol_ref}, indicates that @var{x} has been used.  This is
normally only used to ensure that @var{x} is only declared external
once.  Stored in the @code{used} field.

@findex SYMBOL_REF_WEAK
@cindex @code{symbol_ref} and @samp{/i}
@cindex @code{return_val}, in @code{symbol_ref}
@item SYMBOL_REF_WEAK (@var{x})
In a @code{symbol_ref}, indicates that @var{x} has been declared weak.
Stored in the @code{return_val} field and printed as @samp{/i}.

@findex SYMBOL_REF_FLAG
@cindex @code{symbol_ref} and @samp{/v}
@cindex @code{volatil}, in @code{symbol_ref}
@item SYMBOL_REF_FLAG (@var{x})
@code{symbol_ref} 中で、機種に固有な目的のためのフラグとして使われる。
@code{volatil} フィールドに格納され、@samp{/v} として出力される。

Most uses of @code{SYMBOL_REF_FLAG} are historic and may be subsumed
by @code{SYMBOL_REF_FLAGS}.  Certainly use of @code{SYMBOL_REF_FLAGS}
is mandatory if the target requires more than one bit of storage.

@findex PREFETCH_SCHEDULE_BARRIER_P
@cindex @code{prefetch} and @samp{/v}
@cindex @code{volatile}, in @code{prefetch}
@item PREFETCH_SCHEDULE_BARRIER_P (@var{x})
In a @code{prefetch}, indicates that the prefetch is a scheduling barrier.
No other INSNs will be moved over it.
Stored in the @code{volatil} field and printed as @samp{/v}.
@end table

以下に、上述のマクロが参照するフィールドを挙げる。

@table @code
@findex call
@cindex @samp{/c} in RTL dump
@item call
In a @code{mem}, 1 means that the memory reference will not trap.

In a @code{call}, 1 means that this pure or const call may possibly
infinite loop.

In an RTL dump, this flag is represented as @samp{/c}.

@findex frame_related
@cindex @samp{/f} in RTL dump
@item frame_related
In an @code{insn} or @code{set} expression, 1 means that it is part of
a function prologue and sets the stack pointer, sets the frame pointer,
saves a register, or sets up a temporary register to use in place of the
frame pointer.

In @code{reg} expressions, 1 means that the register holds a pointer.

In @code{mem} expressions, 1 means that the memory reference holds a pointer.

In @code{symbol_ref} expressions, 1 means that the reference addresses
this function's string constant pool.

In an RTL dump, this flag is represented as @samp{/f}.

@findex in_struct
@cindex @samp{/s} in RTL dump
@item in_struct
In @code{reg} expressions, it is 1 if the register has its entire life
contained within the test expression of some loop.

In @code{subreg} expressions, 1 means that the @code{subreg} is accessing
an object that has had its mode promoted from a wider mode.

In @code{label_ref} expressions, 1 means that the referenced label is
outside the innermost loop containing the insn in which the @code{label_ref}
was found.

In @code{code_label} expressions, it is 1 if the label may never be deleted.
This is used for labels which are the target of non-local gotos.  Such a
label that would have been deleted is replaced with a @code{note} of type
@code{NOTE_INSN_DELETED_LABEL}.

In an @code{insn} during dead-code elimination, 1 means that the insn is
dead code.

In an @code{insn} or @code{jump_insn} during reorg for an insn in the
delay slot of a branch,
1 means that this insn is from the target of the branch.

In an @code{insn} during instruction scheduling, 1 means that this insn
must be scheduled as part of a group together with the previous insn.

In an RTL dump, this flag is represented as @samp{/s}.

@findex return_val
@cindex @samp{/i} in RTL dump
@item return_val
In @code{reg} expressions, 1 means the register contains
the value to be returned by the current function.  On
machines that pass parameters in registers, the same register number
may be used for parameters as well, but this flag is not set on such
uses.

In @code{symbol_ref} expressions, 1 means the referenced symbol is weak.

In @code{call} expressions, 1 means the call is pure.

In an RTL dump, this flag is represented as @samp{/i}.

@findex jump
@cindex @samp{/j} in RTL dump
@item jump
In a @code{mem} expression, 1 means we should keep the alias set for this
mem unchanged when we access a component.

In a @code{set}, 1 means it is for a return.

In a @code{call_insn}, 1 means it is a sibling call.

In an RTL dump, this flag is represented as @samp{/j}.

@findex unchanging
@cindex @samp{/u} in RTL dump
@item unchanging
In @code{reg} and @code{mem} expressions, 1 means
that the value of the expression never changes.

In @code{subreg} expressions, it is 1 if the @code{subreg} references an
unsigned object whose mode has been promoted to a wider mode.

In an @code{insn} or @code{jump_insn} in the delay slot of a branch
instruction, 1 means an annulling branch should be used.

In a @code{symbol_ref} expression, 1 means that this symbol addresses
something in the per-function constant pool.

In a @code{call_insn} 1 means that this instruction is a call to a const
function.

In an RTL dump, this flag is represented as @samp{/u}.

@findex used
@item used
This flag is used directly (without an access macro) at the end of RTL
generation for a function, to count the number of times an expression
appears in insns.  Expressions that appear more than once are copied,
according to the rules for shared structure (@pxref{Sharing}).

For a @code{reg}, it is used directly (without an access macro) by the
leaf register renumbering code to ensure that each register is only
renumbered once.

In a @code{symbol_ref}, it indicates that an external declaration for
the symbol has already been written.

@findex volatil
@cindex @samp{/v} in RTL dump
@item volatil
@cindex volatile memory references
In a @code{mem}, @code{asm_operands}, or @code{asm_input}
expression, it is 1 if the memory
reference is volatile.  Volatile memory references may not be deleted,
reordered or combined.

In a @code{symbol_ref} expression, it is used for machine-specific
purposes.

In a @code{reg} expression, it is 1 if the value is a user-level variable.
0 indicates an internal compiler temporary.

In an @code{insn}, 1 means the insn has been deleted.

In @code{label_ref} and @code{reg_label} expressions, 1 means a reference
to a non-local label.

In @code{prefetch} expressions, 1 means that the containing insn is a
scheduling barrier.

In an RTL dump, this flag is represented as @samp{/v}.
@end table

@node Machine Modes
@section Machine Modes
@cindex machine modes

@findex machine_mode
マシンモードは、データオブジェクトの大きさ、その表現方法を記述する。
C のコード中では、マシンモードは列挙型 @code{enum machine_mode} で
表現される。この列挙型は、@file{machmode.def} で定義されている。
各 RTL 式にはマシンモードを格納する場所があり、そのため、ある種のツリー式
(正確には、宣言と型である)を格納する場所も持っている。

デバッグダンプとマシン記述のなかでは、RTL 式のマシンモードは、式コードの
後ろにコロンで区切って書く。各マシンモード名に付く@samp{mode}は、
省略される。例えば、@code{(reg:SI 38)} は、@code{reg} 式で、マシンモードは
@code{SImode} である。モードが @code{VOIDmode} の場合は、モードとしては
何も出力されない。

以下にマシンモードの表を示す。以下では、「バイト」とは、@code{BITS_PER_UNIT}
ビットのオブジェクトを指す(@pxref{Storage Layout})。

@table @code
@findex QImode
@item QImode
「1/4 精度整数」(Quarter-Integer)モードは、整数として扱われる1バイトを
表現する。

@findex HImode
@item HImode
「1/2 精度整数」(Half-Integer)モードは、2バイト整数を表す。

@findex PSImode
@item PSImode
「部分単精度整数」(Partial Single Integer)モードは、4バイトを占有するが、
実際に4バイト全てを使うことはないような整数を表す。
マシンによっては、これがポインタ用の正しいモードになる。

@findex SImode
@item SImode
「単精度整数」(Single Integer)モードは、四バイト整数を表す。

@findex PDImode
@item PDImode
「部分倍精度整数」(Partial Double Integer)モードは、8バイトを占有するが、
実際に8バイト全てを使うことはないような整数を表す。
マシンによっては、これがある種のポインタ用の正しいモードになる。

@findex DImode
@item DImode
「倍精度整数」モードは八バイト整数を表す。

@findex TImode
@item TImode
「4倍精度整数」(Tetra Integer)モードは、16バイト整数を表す。

@findex SFmode
@item SFmode
「単精度浮動小数点数」(Single Floating)モードは、単精度(四バイト)浮動小数点数
を表す。

@findex DFmode
@item DFmode
「倍精度浮動小数点数」(Double Floating)モードは、倍精度(八バイト)浮動小数点数
を表す。

@findex XFmode
@item XFmode
「拡張精度浮動小数点数」(Extended Floating)モードは、3倍精度(12バイト)
浮動小数点数を表す。このモードは、IEEE 拡張浮動小数点数に使う。
システムによっては、12バイトの中には実際に使われないビットがある。

@findex TFmode
@item TFmode
「4倍精度浮動小数点数」(Tetra Floating)モードは、4倍精度(16バイト)
浮動小数点数を表す。

@findex CCmode
@item CCmode
「条件コード」(Condition Code)モードは、条件コードの値を表す。
条件コードは、機種に固有のビットの一群で、比較演算の結果を表す。
これ以外の機種固有のモードが条件コードに対して使われることもある。
これらのモードは、@code{cc0} を使う機種では使われない。
(@pxref{Condition Code}。)

@findex BLKmode
@item BLKmode
「ブロック」(Block)モードは、他のどのモードも適用できないような集合体の
値を表す。RTL では、メモリへの参照のみがこのモードを取りうる。
しかも、それが文字列移動またはベクトル命令中に現れたときだけに限られる。
このような命令を持たない機種では、@code{BLKmode} が RTL に現れることは
ない。

@findex VOIDmode
@item VOIDmode
「ボイド」(Void)モードは、モードがないこと、あるいはモードを指定しないこと
を意味する。例えば、コードが @code{const_int} である RTL 式は
@code{VOIDmode} になる。何故なら、文脈が要求するどんなモードとしても
取ることが出来るからである。RTL のデバッグダンプ中では、@code{VOIDmode} は、
モードが一切無いことにより表現される。

@findex SCmode
@findex DCmode
@findex XCmode
@findex TCmode
@item SCmode, DCmode, XCmode, TCmode
これらのモードは、浮動小数点数値の対として表現された複素数を表す。
浮動小数点数値は、それぞれ、@code{SFmode}, @code{DFmode}, @code{XFmode},
@code{TFmode} になる。

@findex CQImode
@findex CHImode
@findex CSImode
@findex CDImode
@findex CTImode
@findex COImode
@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
これらのモードは、整数値の対として表現された複素数を表す。
整数値は、それぞれ、@code{QImode}, @code{HImode}, @code{SImode},
@code{DImode}, @code{TImode}, @code{OImode} である。

@end table

マシン記述では、@code{Pmode} を C のマクロとして定義し、このマクロは
アドレス向けのマシンモードに展開される。普通は、これは @code{BITS_PER_WORD}
の大きさのモードであり、32ビットのマシンでは @code{SImode} になる。

マシン記述に必ず記述が必要なのは、@code{QImode} と、それぞれ
@code{BITS_PER_WORD}、@code{FLOAT_TYPE_SIZE}、@code{DOUBLE_TYPE_SIZE}
に対応するモードである。
GCC は、8バイトの構造体と共用体に対して @code{DImode} を使うことを
試みるが、@code{MAX_FIXED_MODE_SIZE} の定義を書き換えることにより、
抑止することができる。
また、16バイトの構造体と共用体向けに @code{TImode} を使わせることも
可能である。同様に、C の @code{short int} 型に、@code{HImode} を
使うのを避けるように設定することも可能である。

@cindex mode classes
現在では、GCC の中でマシンモードを明示的に参照しているコードはほとんどなく、
あっても早々に削除してしまう予定である。その代わり、マシンモードを
モードのクラスに分割している。マシンモードのクラスは、列挙型
@code{enum mode_class} で表される。この列挙型は @file{machmode.h} で
定義されている。取りうるモードクラスは以下の通りである。

@table @code
@findex MODE_INT
@item MODE_INT
整数モード。デフォルトでは、@code{QImode}, @code{HImode}, @code{SImode},
@code{DImode}, @code{TImode} が該当する。

@findex MODE_PARTIAL_INT
@item MODE_PARTIAL_INT
「部分整数モード」を表す。@code{PSImode} と @code{PDImode} が
該当する。

@findex MODE_FLOAT
@item MODE_FLOAT
浮動小数点モード。デフォルトでは、@code{SFmode}, @code{DFmode}, @code{XFmode},
@code{TFmode} である。

@findex MODE_COMPLEX_INT
@item MODE_COMPLEX_INT
整数複素数モード。(現時点では実装されていない。)

@findex MODE_COMPLEX_FLOAT
@item MODE_COMPLEX_FLOAT
浮動小数点複素数モード。デフォルトでは、@code{SCmode}、
@code{DCmode}, @code{XCmode}, and @code{TCmode} である。

@findex MODE_FUNCTION
@item MODE_FUNCTION
静的チェーンを含む、Algol や Pascal の関数変数である。
(現時点では実装されていない。)

@findex MODE_CC
@item MODE_CC
条件コード値を表すモード。これには、@code{CCmode} と、
@code{EXTRA_CC_MODES} マクロに示された全てのモードが含まれる。
@xref{Jump Patterns}、@ref{Condition Code} を参照のこと。

@findex MODE_RANDOM
@item MODE_RANDOM
これは、上記のどのクラスにも当てはまらないモードのための受皿モードである。
現時点では、@code{VOIDmode} と @code{BLKmode} が @code{MODE_RANDOM} に
該当する。
@end table

以下にマシンモード関連の C マクロを示す。

@table @code
@findex GET_MODE
@item GET_MODE (@var{x})
RTX @var{x} のマシンモードを返す。

@findex PUT_MODE
@item PUT_MODE (@var{x}, @var{newmode})
RTX @var{x} のマシンモードを @var{newmode} にする。

@findex NUM_MACHINE_MODES
@item NUM_MACHINE_MODES
ターゲット機種で利用可能なマシンモードの数を表す。
これは、マシンモード値のうち最大のものに 1 を足したものになる。

@findex GET_MODE_NAME
@item GET_MODE_NAME (@var{m})
モード @var{m} の名前を文字列で返す。

@findex GET_MODE_CLASS
@item GET_MODE_CLASS (@var{m})
モード @var{m} のモードクラスを返す。

@findex GET_MODE_WIDER_MODE
@item GET_MODE_WIDER_MODE (@var{m})
指定したモードの次に広い自然なモードを返す。
例えば、@code{GET_MODE_WIDER_MODE (QImode)} という式は、
@code{HImode} を返す。

@findex GET_MODE_SIZE
@item GET_MODE_SIZE (@var{m})
モード @var{m} のデータの大きさをバイト数で返す。

@findex GET_MODE_BITSIZE
@item GET_MODE_BITSIZE (@var{m})
モード @var{m} のデータの大きさをビット数で返す。

@findex GET_MODE_MASK
@item GET_MODE_MASK (@var{m})
一語中のビットのうち、モード @var{m} の範囲内に収まる全てのビットを
表すビットマスクを返す。
このマクロは、ビット数が @code{HOST_BITS_PER_INT} 以下であるモードに
対してのみ使うことができる。

@findex GET_MODE_ALIGNMENT
@item GET_MODE_ALIGNMENT (@var{m})
モード @var{m} のオブジェクトに必要なアラインメントをビット数で
返す。

@findex GET_MODE_UNIT_SIZE
@item GET_MODE_UNIT_SIZE (@var{m})
モード @var{m} のデータの部分単位の大きさをバイト数で返す。
これは、複素数のモードの場合以外は、@code{GET_MODE_SIZE} と同じである。
複素数のモードの場合は、部分単位の大きさは、実数部また虚数部の大きさである。

@findex GET_MODE_NUNITS
@item GET_MODE_NUNITS (@var{m})
あるモードに含まれる単位の数を返す。
すなわち、@code{GET_MODE_SIZE} を @code{GET_MODE_UNIT_SIZE} で
割ったものを返す。

@findex GET_CLASS_NARROWEST_MODE
@item GET_CLASS_NARROWEST_MODE (@var{c})
モードクラス @var{c} の中で最も幅の狭いモードを返す。
@end table

@findex byte_mode
@findex word_mode
グローバル変数 @code{byte_mode} と @code{word_mode} は、
モードクラスが @code{MODE_INT} であり、ビット数が
それぞれ @code{BITS_PER_UNIT} と @code{BITS_PER_WORD} のモードを保持している。
32ビットマシンでは、それぞれ @code{QImode} と @code{SImode} になる。

@node Constants
@section Constant Expression Types
@cindex RTL constants
@cindex RTL constant expression types

最も簡単な RTL 式は、定数値を表すものである。

@table @code
@findex const_int
@item (const_int @var{i})
この型の式は、整数値 @var{i} を表す。@var{i} は、マクロ @code{INTVAL} を
使って @code{INTVAL (@var{exp})} のように参照するのが良く行われる。
これは、@code{XWINT (@var{exp}, 0)} と書くのと同じである。

@findex const0_rtx
@findex const1_rtx
@findex const2_rtx
@findex constm1_rtx
整数値 0 を表す式オブジェクトは唯一つしかなく、変数 @code{const0_rtx}
の値だけである。
同じく、整数値 1 に対する式は、@code{const1_rtx} だけであり、
整数値 2 に対する式は、@code{const2_rtx} だけである。
さらに、整数値 -1 に対する式は @code{constm1_rtx} だけである。
コードが @code{const_int} で、値が 0, 1, 2, -1 のどれかの
式を作ろうとすると、それぞれ、@code{const0_rtx}、@code{const1_rtx}、
@code{const2_rtx}、@code{constm1_rtx} が返される。

@findex const_true_rtx
同様に、値が @code{STORE_FLAG_VALUE} である整数に対するオブジェクトは
唯一つだけで、@code{const_true_rtx} になる。@code{STORE_FLAG_VALUE} が
1 であれば、@code{const_true_rtx} と @code{const1_rtx} は同じオブジェクトを
指す。@code{STORE_FLAG_VALUE} が -1 なら、@code{const_true_rtx} と
@code{constm1_rtx} は同じオブジェクトを指すことになる。

@findex const_double
@item (const_double:@var{m} @var{i0} @var{i1} @dots{})
モード @var{m} の浮動小数点定数か、@code{HOST_BITS_PER_WIDE_INT} ビット
には収まらないが @code{HOST_BITS_PER_WIDE_INT} の二倍のビット数になら
収まるような整数定数を表す(GNU CC は、それ以上に大きい定数を表現する
機能は提供していない)。後者の場合は、@var{m} は @code{VOIDmode} になる。

@findex CONST_DOUBLE_MEM
@findex CONST_DOUBLE_CHAIN
@var{addr} は、定数が置かれているメモリ上の位置に対応する @code{mem} 式を
保持する。メモリ上の位置は確保されていないが、現在のコンパイル
(表示されないフィールドを使い維持されている)の全ての @code{const_double}
式の連鎖上には存在するなら、@var{addr} は @code{const0_rtx} を含む。
その連鎖に存在しなければ、@var{addr} は @code{cc0_rtx} を含む。
@var{addr} は、マクロ @code{CONST_DOUBLE_MEM} と
@code{CONST_DOUBLE_CHAIN} を経由した連鎖フィールドを使って
アクセスするようになっている。

@findex CONST_DOUBLE_LOW
@var{m} が @code{VOIDmode} なら、値を表すビット群は @var{i0} と @var{i1}
に格納される。@var{i0} はマクロ @code{CONST_DOUBLE_LOW} で、@var{i1} は
@code{CONST_DOUBLE_HIGH} で参照するのが通例となっている。

定数が浮動小数点数なら(精度に関わらず)、その値を格納するのに必要な
整数の個数は、@code{REAL_VALUE_TYPE} に依存する(@pxref{Cross-compilation})。
その整数群は浮動小数点数を表現するが、厳密にはターゲットマシンまた
ホストマシンの浮動小数点数形式ではない。ターゲットマシンで使われる
正確なビットパターンに変換するには、マクロ @code{REAL_VALUE_TO_TARGET_DOUBLE}
と関連マクロを使用すること(@pxref{Data Output})。

@findex const_string
@item (const_string @var{str})
値が @var{str} である文字列定数を表す。
現時点では、この式は insn の属性(@pxref{Insn Attributes})についてのみ
使われている。というのは、C 言語の文字列定数はメモリ中に置かれるからである。

@findex symbol_ref
@item (symbol_ref:@var{mode} @var{symbol})
アセンブラのデータに対するラベルの値を表現する。
@var{symbol} は、アセンブララベル名を記述する文字列である。
この文字列が @samp{*} で始まるなら、ラベル名は、@var{symbol} から
@samp{*} を除いたものになる。それ以外の場合は、@var{symbol} そのものが
ラベル名となり、通常は @samp{_} というプレフィックスが付く。

@code{symbol_ref} にはモードがあり、普通は @code{Pmode} になる。
普通は、このモードがシンボルに対して直接有効になる唯一のモードである。

@findex label_ref
@item (label_ref:@var{mode} @var{label})
コードに対するアセンブラ・ラベルの値を表現する。
オペランドは一つであり、それは式となる。この式は、ラベルの置かれるべき
位置を特定するための命令列に現れる @code{code_label} でなければならない。

コードラベルの参照に異なる式のタイプを使用するのは、
ジャンプ最適化で区別できるようにするためである。


@findex const
@item (const:@var{m} @var{exp})
アセンブル時の代数計算の結果として生じる定数を表現する。
オペランド @var{exp} は、定数(@code{const_int}、@code{symbol_ref}、
@code{label_ref} 式)に @code{plus} と @code{minus} を組み合わせたもののみ
からなる式である。ただし、全ての組合せが有効とは限らない。
アセンブラは、再配置可能なシンボルについては勝手な計算は出来ないからである。

@var{m} は @code{Pmode} でなければならない。

@findex high
@item (high:@var{m} @var{exp})
@var{exp}、普通は @code{symbol_ref} の上位ビット群を表現する。
ビット数は機種依存であり、通常はレジスタの上位ビットを初期化する
命令で指定されるビット数になる。
@code{lo_sum} と共に使って、RISC で良く使われる、グローバルなメモリ位置を
参照する典型的な二命令の列を表現する。

@var{m} は @code{Pmode} でなければならない。
@end table

@findex CONST0_RTX
@findex CONST1_RTX
@findex CONST2_RTX
マクロ @code{CONST0_RTX (@var{mode})} は、値が 0 でモードが @var{mode} の
式を参照する。モード @var{mode} が、@code{MODE_INT} のクラスのモードであれば、
@code{const0_rtx} を返す。そうでなければ、モード @var{mode} の
@code{CONST_DOUBLE} 式を返す。
同様に、マクロ @code{CONST1_RTX (@var{mode})} は、値が 1 でモード @var{mode}
の式を参照する。@code{CONST2_RTX} についても同様である。

@node Regs and Memory
@section Registers and Memory
@cindex RTL register expressions
@cindex RTL memory expressions

以下に、レジスタとメモリへのアクセスを記述する、RTL 式のタイプを示す。

@table @code
@findex reg
@cindex hard registers
@cindex pseudo registers
@item (reg:@var{m} @var{n})
小さな整数 @var{n} (@code{FIRST_PSEUDO_REGISTER} より小さい)に対して、
マシンのレジスタ番号 @var{n}、すなわち@dfn{ハードレジスタ}の
参照であることを意味する。@var{n} が大きな値の場合は、
一時的な値か @dfn{仮想レジスタ}を表す。
GCC の戦略としては、まず、このような仮想レジスタが無限個あると仮定して
コード生成を行ない、後で、ハードレジスタかメモリ参照への置き換えを行なう。

@var{m} は、この参照のマシンモードである。
モードの指定が必要なのは、一般に複数のモードで各レジスタを参照する
ことが可能だからである。
例えば、レジスタを一つ取ってみると、そこには全語を入れることができるが、
それを半語やバイトとして参照する命令や、色々な精度の浮動小数点数として
参照する命令もありうるのである。

レジスタをアクセスするモードが一つしかないマシンの場合でも、
モードは常に指定しなければならない。

@code{FIRST_PSEUDO_REGISTER} というシンボルはマシン記述により
定義される。というのは、あるマシンのハードレジスタの数は
そのマシンの不変の特徴だからである。ただ、マシンのレジスタが全て
汎用レジスタである必要はない。
データの格納に使える全てのマシンレジスタは、ハードレジスタ番号が
与えられる。たとえ、それらのレジスタが特定の命令でしか使えなかったり、
特定の型のデータしか保持できなくても。

ハードレジスタは一つの関数の中でも色々なモードでアクセスされる。
しかし、疑似レジスタにはそれぞれ自然なモードが与えられており、
そのモードでしかアクセスされない。
疑似レジスタを自然なモード以外のモードでアクセスするのを記述する
必要があるときは、@code{subreg} 式が使われる。

1ワードより多くのデータを指定するマシンモードを持つ @code{reg} 式は、
実際には幾つかの連続するレジスタを表す事がある。
そのレジスタ番号が、ある一個のハードウェアレジスタを指定するだけでなく、
実際には、その指定されたレジスタから始まる、幾つかの連続した
ハードウェアレジスタ群を表している。

関数 RTL コードで使われている疑似レジスタ番号はそれぞれ、
一意的な @code{reg} 式で表現される。

@findex FIRST_VIRTUAL_REGISTER
@findex LAST_VIRTUAL_REGISTER
@code{FIRST_VIRTUAL_REGISTER} から @code{LAST_VIRTUAL_REGISTER} までの
範囲の疑似レジスタ番号のうちいくつかは、
RTL 生成過程にしか現れず、最適化過程の前に削除される。
こういう疑似レジスタ番号は、それを含む関数についての RTL 生成が
完了するまでは決定できないスタックフレーム中の位置を表す。
以下の仮想レジスタ番号が定義されている。

@table @code
@findex VIRTUAL_INCOMING_ARGS_REGNUM
@item VIRTUAL_INCOMING_ARGS_REGNUM
スタック渡しされた入力引数の先頭のワードを指し示す。
通常、これらの引数は呼びだし側によって置かれるが、
呼び出された側が、以前にレジスタで渡された引数の幾つかを
プッシュすることもありうる。

@cindex @code{FIRST_PARM_OFFSET} and virtual registers
@cindex @code{ARG_POINTER_REGNUM} and virtual registers
RTL が完了した時点で、この仮想レジスタは、 @code{ARG_POINTER_REGNUM} で
指定されるレジスタと @code{FIRST_PARM_OFFSET} の値の和に置き換えられる。

@findex VIRTUAL_STACK_VARS_REGNUM
@cindex @code{FRAME_GROWS_DOWNWARD} and virtual registers
@item VIRTUAL_STACK_VARS_REGNUM
@code{FRAME_GROWS_DOWNWARD} が定義されていれば、このマクロは
スタック上の先頭の変数のすぐ上を指す。
@code{FRAME_GROWS_DOWNWARD} が定義されていない場合は、
スタック上の先頭の変数そのものを指す。

@cindex @code{STARTING_FRAME_OFFSET} and virtual registers
@cindex @code{FRAME_POINTER_REGNUM} and virtual registers
@code{VIRTUAL_STACK_VARS_REGNUM} は、@code{FRAME_POINTER_REGNUM} で
指定されるレジスタと @code{STARTING_FRAME_OFFSET} の値の和で置き換えられる。

@findex VIRTUAL_STACK_DYNAMIC_REGNUM
@item VIRTUAL_STACK_DYNAMIC_REGNUM
これは、必要とするメモリ量の分だけスタックポインタの調整が行なわれた直後の、
スタック上に動的に確保されたメモリの位置を指す。

@cindex @code{STACK_DYNAMIC_OFFSET} and virtual registers
@cindex @code{STACK_POINTER_REGNUM} and virtual registers
この仮想レジスタは、@code{STACK_POINTER_REGNUM} で指定されるレジスタと
@code{STACK_DYNAMIC_OFFSET} の値の和に置き換えられる。

@findex VIRTUAL_OUTGOING_ARGS_REGNUM
@item VIRTUAL_OUTGOING_ARGS_REGNUM
スタックが前もってプッシュされたときに、出力引数が書き込まれるべき
スタック上の位置を指す。
(push insn を使ってプッシュされる引数は常に @code{STACK_POINTER_REGNUM} を
使うべきである。)

@cindex @code{STACK_POINTER_OFFSET} and virtual registers
この仮想レジスタは、@code{STACK_POINTER_REGNUM} で指定されるレジスタと
@code{STACK_POINTER_OFFSET} の値の和に置き換えられる。
@end table

@findex subreg
@item (subreg:@var{m1} @var{reg:m2} @var{bytenum})

@code{subreg} 式は、マシンに取って自然なモード以外のモードにある
レジスタ、あるいは実際には複数のレジスタを参照する複数ワードの @code{reg}
のうちの一つのレジスタを参照するのに使われる。

疑似レジスタにはそれぞれ自然なモードがある。
その自然なモードとは異なるモードでの操作が必要な場合、例えば、
一個のバイトを保持している疑似レジスタに対してフルワードの移動命令を
行なう場合は、その疑似レジスタは @code{subreg} の中に収まって
いなければならない。この例の場合は、@var{wordnum} は 0 である。

There are currently three supported types for the first operand of a
@code{subreg}:
@itemize
@item pseudo registers
This is the most common case.  Most @code{subreg}s have pseudo
@code{reg}s as their first operand.

@item mem
@code{subreg}s of @code{mem} were common in earlier versions of GCC and
are still supported.  During the reload pass these are replaced by plain
@code{mem}s.  On machines that do not do instruction scheduling, use of
@code{subreg}s of @code{mem} are still used, but this is no longer
recommended.  Such @code{subreg}s are considered to be
@code{register_operand}s rather than @code{memory_operand}s before and
during reload.  Because of this, the scheduling passes cannot properly
schedule instructions with @code{subreg}s of @code{mem}, so for machines
that do scheduling, @code{subreg}s of @code{mem} should never be used.
To support this, the combine and recog passes have explicit code to
inhibit the creation of @code{subreg}s of @code{mem} when
@code{INSN_SCHEDULING} is defined.

The use of @code{subreg}s of @code{mem} after the reload pass is an area
that is not well understood and should be avoided.  There is still some
code in the compiler to support this, but this code has possibly rotted.
This use of @code{subreg}s is discouraged and will most likely not be
supported in the future.

@item hard registers
It is seldom necessary to wrap hard registers in @code{subreg}s; such
registers would normally reduce to a single @code{reg} rtx.  This use of
@code{subreg}s is discouraged and may not be supported in the future.

@end itemize

@code{subreg}s of @code{subreg}s are not supported.  Using
@code{simplify_gen_subreg} is the recommended way to avoid this problem.

@code{subreg}s come in two distinct flavors, each having its own
usage and rules:

@table @asis
@item Paradoxical subregs
When @var{m1} is strictly wider than @var{m2}, the @code{subreg}
expression is called @dfn{paradoxical}.  The canonical test for this
class of @code{subreg} is:

@smallexample
GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})
@end smallexample

Paradoxical @code{subreg}s can be used as both lvalues and rvalues.
When used as an lvalue, the low-order bits of the source value
are stored in @var{reg} and the high-order bits are discarded.
When used as an rvalue, the low-order bits of the @code{subreg} are
taken from @var{reg} while the high-order bits may or may not be
defined.

The high-order bits of rvalues are in the following circumstances:

@itemize
@item @code{subreg}s of @code{mem}
When @var{m2} is smaller than a word, the macro @code{LOAD_EXTEND_OP},
can control how the high-order bits are defined.

@item @code{subreg} of @code{reg}s
The upper bits are defined when @code{SUBREG_PROMOTED_VAR_P} is true.
@code{SUBREG_PROMOTED_UNSIGNED_P} describes what the upper bits hold.
Such subregs usually represent local variables, register variables
and parameter pseudo variables that have been promoted to a wider mode.

@end itemize

@var{bytenum} is always zero for a paradoxical @code{subreg}, even on
big-endian targets.

For example, the paradoxical @code{subreg}:

@smallexample
(set (subreg:SI (reg:HI @var{x}) 0) @var{y})
@end smallexample

stores the lower 2 bytes of @var{y} in @var{x} and discards the upper
2 bytes.  A subsequent:

@smallexample
(set @var{z} (subreg:SI (reg:HI @var{x}) 0))
@end smallexample

would set the lower two bytes of @var{z} to @var{y} and set the upper
two bytes to an unknown value assuming @code{SUBREG_PROMOTED_VAR_P} is
false.

@item Normal subregs
When @var{m1} is at least as narrow as @var{m2} the @code{subreg}
expression is called @dfn{normal}.

Normal @code{subreg}s restrict consideration to certain bits of
@var{reg}.  There are two cases.  If @var{m1} is smaller than a word,
the @code{subreg} refers to the least-significant part (or
@dfn{lowpart}) of one word of @var{reg}.  If @var{m1} is word-sized or
greater, the @code{subreg} refers to one or more complete words.

When used as an lvalue, @code{subreg} is a word-based accessor.
Storing to a @code{subreg} modifies all the words of @var{reg} that
overlap the @code{subreg}, but it leaves the other words of @var{reg}
alone.

When storing to a normal @code{subreg} that is smaller than a word,
the other bits of the referenced word are usually left in an undefined
state.  This laxity makes it easier to generate efficient code for
such instructions.  To represent an instruction that preserves all the
bits outside of those in the @code{subreg}, use @code{strict_low_part}
or @code{zero_extract} around the @code{subreg}.

@var{bytenum} must identify the offset of the first byte of the
@code{subreg} from the start of @var{reg}, assuming that @var{reg} is
laid out in memory order.  The memory order of bytes is defined by
two target macros, @code{WORDS_BIG_ENDIAN} and @code{BYTES_BIG_ENDIAN}:

@itemize
@item
@cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}
@code{WORDS_BIG_ENDIAN}, if set to 1, says that byte number zero is
part of the most significant word; otherwise, it is part of the least
significant word.

@item
@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}
@code{BYTES_BIG_ENDIAN}, if set to 1, says that byte number zero is
the most significant byte within a word; otherwise, it is the least
significant byte within a word.
@end itemize

@cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}
On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with
@code{WORDS_BIG_ENDIAN}.  However, most parts of the compiler treat
floating point values as if they had the same endianness as integer
values.  This works because they handle them solely as a collection of
integer values, with no particular numerical value.  Only real.c and
the runtime libraries care about @code{FLOAT_WORDS_BIG_ENDIAN}.

Thus,

@smallexample
(subreg:HI (reg:SI @var{x}) 2)
@end smallexample

on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as

@smallexample
(subreg:HI (reg:SI @var{x}) 0)
@end smallexample

on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both
@code{subreg}s access the lower two bytes of register @var{x}.

@end table

A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the
corresponding @code{MODE_INT} mode, except that it has an unknown
number of undefined bits.  For example:

@smallexample
(subreg:PSI (reg:SI 0) 0)
@end smallexample

accesses the whole of @samp{(reg:SI 0)}, but the exact relationship
between the @code{PSImode} value and the @code{SImode} value is not
defined.  If we assume @samp{UNITS_PER_WORD <= 4}, then the following
two @code{subreg}s:

@smallexample
(subreg:PSI (reg:DI 0) 0)
(subreg:PSI (reg:DI 0) 4)
@end smallexample

represent independent 4-byte accesses to the two halves of
@samp{(reg:DI 0)}.  Both @code{subreg}s have an unknown number
of undefined bits.

If @samp{UNITS_PER_WORD <= 2} then these two @code{subreg}s:

@smallexample
(subreg:HI (reg:PSI 0) 0)
(subreg:HI (reg:PSI 0) 2)
@end smallexample

represent independent 2-byte accesses that together span the whole
of @samp{(reg:PSI 0)}.  Storing to the first @code{subreg} does not
affect the value of the second, and vice versa.  @samp{(reg:PSI 0)}
has an unknown number of undefined bits, so the assignment:

@smallexample
(set (subreg:HI (reg:PSI 0) 0) (reg:HI 4))
@end smallexample

does not guarantee that @samp{(subreg:HI (reg:PSI 0) 0)} has the
value @samp{(reg:HI 4)}.

@cindex @code{CANNOT_CHANGE_MODE_CLASS} and subreg semantics
The rules above apply to both pseudo @var{reg}s and hard @var{reg}s.
If the semantics are not correct for particular combinations of
@var{m1}, @var{m2} and hard @var{reg}, the target-specific code
must ensure that those combinations are never used.  For example:

@smallexample
CANNOT_CHANGE_MODE_CLASS (@var{m2}, @var{m1}, @var{class})
@end smallexample

must be true for every class @var{class} that includes @var{reg}.

@findex SUBREG_REG
@findex SUBREG_BYTE
The first operand of a @code{subreg} expression is customarily accessed
with the @code{SUBREG_REG} macro and the second operand is customarily
accessed with the @code{SUBREG_BYTE} macro.

It has been several years since a platform in which
@code{BYTES_BIG_ENDIAN} not equal to @code{WORDS_BIG_ENDIAN} has
been tested.  Anyone wishing to support such a platform in the future
may be confronted with code rot.

@findex scratch
@cindex scratch operands
@item (scratch:@var{m})
一個の命令の実行に必要とされ、それ以降は使われないスクラッチレジスタを
表す。
局所レジスタ確保か再ロードパスのどちらかにより、@code{reg} に変換される。

@code{scratch} は、普通は @code{clobber} 演算中に存在する
(@pxref{Side Effects}).

@findex cc0
@cindex condition code register
@item (cc0)
条件コードレジスタを参照する。オペランドは無く、マシンモードも持たない。
使い方は以下の二通りがある。

@itemize @bullet
@item
条件コードフラグの完全なセットを表すために使う。
ほとんどのマシンでは、それぞれの比較が一連のフラグ全体を設定するので、
これが最善である。

このテクニックを使うと、@code{(cc0)} が正しく使える文脈は
二つだけである。
代入における代入先(テストおよび比較命令において)として、
および 0 (値がゼロの @code{const_int}、すなわち @code{const0_rtx} である)
との比較を行なう比較演算においてである。

@item
一個の条件の結果である一個のフラグを表すために使う。
これは、一個のフラグビットしか持たないマシン上で、そして
比較命令がテストすべき条件を指定しなければならない場合に
役にたつ。

この手法を使う場合、@code{(cc0)} が有効なのは次の二つの文脈だけである。
ソースオペランドが比較演算子である(テストと比較命令では)
代入の目的オペランドとして、もう一つは
(条件分岐の) @code{if_then_else} の最初のオペランドとしてである。
@end itemize

@findex cc0_rtx
コード @code{cc0} の式オブジェクトはただ一つだけ存在する。
変数 @code{cc0_rtx} の値である。
コード @code{cc0} の式を作りだそうとすると必ず @code{cc0_rtx} が
返ってくる。

命令が暗黙のうちに条件コードを設定する可能性がある。
多くのマシンでは、ほぼ全ての命令が計算したり、格納した値に基づいて
条件コードを設定する。こういう動作を RTL に明示的に記録する必要は
ない。というのは、マシン記述に、その命令が条件コードを設定することを
認識するための指示が含まれているからである(マクロ @code{NOTICE_UPDATE_CC}
を使う)。@xref{Condition Code}。
条件コードを設定することだけを目的とする命令、そして
条件コードを使用する命令だけが、@code{(cc0)} を書く必要がある

マシンによっては、条件コードレジスタにレジスタ番号が与えられ、
@code{reg} が @code{(cc0)} の代わりに使われる。
条件コードを書き換える命令がほんの一部の命令に限られるなら、
このアプローチが望ましい。
また別のマシンでは、条件コードを汎用レジスタに格納する。
その場合は疑似レジスタを使うべきである。

Sparc や RS/6000 のようなマシンでは、二種類の算術演算命令のセットがある。
一つのセットは条件コードを設定し、もう一つは設定しない。
このような場合を扱う最も良い方法は、通常は、条件コードを設定しない
命令を生成し、算術演算の実行と条件コードレジスタ(この場合は
@code{(cc0)} ではない)の設定の両方を行なうパターンを作ることである。
例としては、@file{sparc.md} で @samp{addcc} や @samp{andcc} を
探してみて欲しい

@findex pc
@item (pc)
@cindex program counter
プログラムカウンタを表す。
オペランドは取らず、マシンモードも持たなくて良い。
@code{(pc)} が使えるのは、分岐命令の特定の文脈においてだけである。

@findex pc_rtx
コードが @code{pc} である式オブジェクトはただ一つである。
変数 @code{pc_rtx} の値である。
コードが @code{pc} の式を作ろうとすると返ってくるのは
@code{pc_rtx} になる。

分岐を行なわない命令は全て、プログラムカウンタをインクリメントすることに
より暗黙のうちに変更する。しかし、このことを RTL に記述する必要はない。

@findex mem
@item (mem:@var{m} @var{addr} @var{alias})
この RTX は、式 @var{addr} で表されるアドレスの主記憶への参照を
表す。@var{m} はメモリの、アクセスされる単位の大きさを表す。

@findex concat
@item (concat@var{m} @var{rtx} @var{rtx})
This RTX represents the concatenation of two other RTXs.  This is used
for complex values.  It should only appear in the RTL attached to
declarations and during RTL generation.  It should not appear in the
ordinary insn chain.

@findex concatn
@item (concatn@var{m} [@var{rtx} @dots{}])
This RTX represents the concatenation of all the @var{rtx} to make a
single value.  Like @code{concat}, this should only appear in
declarations, and not in the insn chain.
@end table

@node Arithmetic
@section RTL Expressions for Arithmetic
@cindex arithmetic, in RTL
@cindex math, in RTL
@cindex RTL expressions for arithmetic

指定されない限り、代数演算式の全てのオペランドはモード @var{m} に対して
有効でなければならない。あるオペランドがモード @var{m} に対して有効なのは、
オペランド自身のモードが @var{m} の場合か、オペランドが @code{const_int}
または @code{const_double} で @var{m} が @code{MODE_INT} クラスのモード
の時である。

交換可能な二項演算の場合には、定数は二番目のオペランドに置くべきである。

@table @code
@findex plus
@findex ss_plus
@findex us_plus
@cindex RTL sum
@cindex RTL addition
@cindex RTL addition with signed saturation
@cindex RTL addition with unsigned saturation
@item (plus:@var{m} @var{x} @var{y})
@itemx (ss_plus:@var{m} @var{x} @var{y})
@itemx (us_plus:@var{m} @var{x} @var{y})

マシンモード @var{m} で実行される、@var{x} と @var{y} で表される値の
加算を表す。

@c ??? What happens on overflow of floating point modes?

@findex lo_sum
@item (lo_sum:@var{m} @var{x} @var{y})

@code{plus} にほぼ同じだが、@var{x} と、@var{y} の下位ビットの和を
表す点が異なる。下位ビット数は機種により異なるが、一般には、
@code{Pmode} のビット数から、コード @code{high} によってセットされる
ビット数を引いたものになる(@pxref{Constants})。

@var{m} は、@code{Pmode} でなければならない。

@findex minus
@findex ss_minus
@findex us_minus
@cindex RTL difference
@cindex RTL subtraction
@cindex RTL subtraction with signed saturation
@cindex RTL subtraction with unsigned saturation
@item (minus:@var{m} @var{x} @var{y})
@itemx (ss_minus:@var{m} @var{x} @var{y})
@itemx (us_minus:@var{m} @var{x} @var{y})

減算を表す以外は @code{plus} と同じである。

@findex compare
@cindex RTL comparison
@item (compare:@var{m} @var{x} @var{y})
比較目的の @var{y} から @var{x} を引く減算の結果を表す。
無限の精度があるかのように、計算は桁溢れなしで行われる。

当然のことだが、実際に無限の精度で引き算を行える機械は存在しない。
だが、引き算の結果の符号だけが使われる場合は、無限の精度で引き算が
できるような振りをすることができる。その場合、引き算の結果は条件コードに
格納される。そして、この種類の式が正しく使えるのはこういう場合、
すなわち、条件コードに格納される値としてだけである。

モード @var{m} は、@var{x} や @var{y} のモードには関係なく、
条件コードの値のモードになる。@code{(cc0)} が使われるのなら、
@code{VOIDmode} になる。それ以外の場合は、@code{MODE_CC} クラスの
中のあるモードになる。良く使われるのは @code{CCmode} である。
@xref{Condition Code}.

普通は、@var{x} と @var{y} は同じモードでなければならない。
それ以外で @code{compare} が有効なのは、@var{x} のモードが、
@code{MODE_INT} のクラスに属し、かつ、@var{y} が @code{VOIDmode} モード
の @code{const_int} か @code{const_double} の場合のみである。
@var{x} のモードによって、比較が行われるモードが決まるので、
@var{x} のモードは @code{VOIDmode} であってはならない。

オペランドの一方が定数であるなら、それは第二オペランドに
置くべきであり、そうすることによって比較のためのコードが
適切に調整される。

@code{compare} で、@code{VOIDmode} の定数を二つ指定するのは
無効である。というのは、どのモードで比較を実行すべきか知りようがないから
である。比較は、コンパイル中に畳み込まれるか、先頭のオペランドが
そのモードがわかっているレジスタにロードされるかしなければならない。

@findex neg
@findex ss_neg
@findex us_neg
@cindex negation
@cindex negation with signed saturation
@cindex negation with unsigned saturation
@item (neg:@var{m} @var{x})
@itemx (ss_neg:@var{m} @var{x})
@itemx (us_neg:@var{m} @var{x})
@var{x} で表現される値の符号を反転した(0 から引いた)値を表現する。
@var{m} のモードで演算が行われる。

@findex mult
@findex ss_mult
@findex us_mult
@cindex multiplication
@cindex product
@cindex multiplication with signed saturation
@cindex multiplication with unsigned saturation
@item (mult:@var{m} @var{x} @var{y})
@itemx (ss_mult:@var{m} @var{x} @var{y})
@itemx (us_mult:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値の符号付きの積を表現する。
積は、モード @var{m} で行われる。

機種によっては、オペランドよりも大きな積を生成する乗算をサポート
している。その場合には、次のようにパターンを書くこと。

@smallexample
(mult:@var{m} (sign_extend:@var{m} @var{x}) (sign_extend:@var{m} @var{y}))
@end smallexample

ここで、@var{m} は、@var{x} と @var{y} のモードよりも大きいモードである。
@var{x} と @var{y} のモードは同じでなくても良い

符号無しの、大きな積を生じる乗算の場合には、
@code{zero_extend} を使って同じように書けば良い。

@findex div
@findex ss_div
@cindex division
@cindex signed division
@cindex signed division with signed saturation
@cindex quotient
@item (div:@var{m} @var{x} @var{y})
@itemx (ss_div:@var{m} @var{x} @var{y})
マシンモード @var{m} で @var{x} を @var{y} で割った、符号付きの商を表す。
@var{m} が浮動小数点モードなら、厳密な商を表す。そうでなければ、
整数化した商を表す。

マシンによっては、オペランドと商の幅が全部同じではない場合の除算命令を
持っていることがある。そういう命令を表現するには、以下のように、
@code{truncate} と @code{sign_extend} を使う。

@smallexample
(truncate:@var{m1} (div:@var{m2} @var{x} (sign_extend:@var{m2} @var{y})))
@end smallexample

@findex udiv
@cindex unsigned division
@cindex unsigned division with unsigned saturation
@cindex division
@item (udiv:@var{m} @var{x} @var{y})
@itemx (us_div:@var{m} @var{x} @var{y})
@code{div} とほぼ同じだが、符号無しの除算を表す。

@findex mod
@findex umod
@cindex remainder
@cindex division
@item (mod:@var{m} @var{x} @var{y})
@itemx (umod:@var{m} @var{x} @var{y})
@code{div} や @code{udiv} と似ているが、商の代わりに剰余を表す。

@findex smin
@findex smax
@cindex signed minimum
@cindex signed maximum
@item (smin:@var{m} @var{x} @var{y})
@itemx (smax:@var{m} @var{x} @var{y})
@var{x} と @var{y} の小さいほう(@code{smin}の場合)または大きいほう
(@code{smax} の場合)を表す。この場合、
モード @var{m} の符号付き整数として解釈が行なわれる。

@findex umin
@findex umax
@cindex unsigned minimum and maximum
@item (umin:@var{m} @var{x} @var{y})
@itemx (umax:@var{m} @var{x} @var{y})
@code{smin} や @code{smax} とほぼ同じだが、符号無しの整数として解釈が
行なわれる。


@findex not
@cindex complement, bitwise
@cindex bitwise complement
@item (not:@var{m} @var{x})
@var{x} で表される値のビット毎の補数を表現する。
この演算はモード @var{m} で行なわれる。
@var{m} は、固定小数点モードでなければならない。

@findex and
@cindex logical-and, bitwise
@cindex bitwise logical-and
@item (and:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の論理積を表現する。
ビット毎の論理積はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex ior
@cindex inclusive-or, bitwise
@cindex bitwise inclusive-or
@item (ior:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の論理和を表現する。
ビット毎の論理和はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex xor
@cindex exclusive-or, bitwise
@cindex bitwise exclusive-or
@item (xor:@var{m} @var{x} @var{y})
@var{x} と @var{y} で表される値のビット毎の排他的論理和を表現する。
ビット毎の排他的論理和はモード @var{m} で実行される。
このモードは、固定少数点数のモードでなければならない。

@findex ashift
@findex ss_ashift
@findex us_ashift
@cindex left shift
@cindex shift
@cindex arithmetic shift
@cindex arithmetic shift with signed saturation
@cindex arithmetic shift with unsigned saturation
@item (ashift:@var{m} @var{x} @var{c})
@itemx (ss_ashift:@var{m} @var{x} @var{c})
@itemx (us_ashift:@var{m} @var{x} @var{c})
@var{x} を左に @var{c} 回算術シフトした結果を表現する。
@var{x} のモードは @var{m} であり、固定少数点数のモードである。
@var{c} は、固定小数点数モードか、モードが @code{VOIDmode} の定数である。
@var{c} のモードがどちらになるかは、
マシン記述中の左シフト命令のエントリに対して
呼び出されるモードにより決定される。
例えば、Vax では、@var{c} のモードは、@var{m} に関わらず、
@code{QImode} である。

@findex lshiftrt
@cindex right shift
@findex ashiftrt
@item (lshiftrt:@var{m} @var{x} @var{c})
@itemx (ashiftrt:@var{m} @var{x} @var{c})
右シフトである点を除いて、@code{ashift} と同じである。
左シフトの場合と違って、この二つの演算は異なる物である。

@findex rotate
@cindex rotate
@cindex left rotate
@findex rotatert
@cindex right rotate
@item (rotate:@var{m} @var{x} @var{c})
@itemx (rotatert:@var{m} @var{x} @var{c})
同様に、左右のローテーションを表す。@var{c} が定数なら、
@code{rotate} の方を使うこと。

@findex abs
@findex ss_abs
@cindex absolute value
@item (abs:@var{m} @var{x})
@item (ss_abs:@var{m} @var{x})
モード @var{m} で計算した、@var{x}の絶対値を表現する。

@findex sqrt
@cindex square root
@item (sqrt:@var{m} @var{x})
モード @var{m} で計算した、@var{x} の平方根を表現する。
ほとんどの場合、@var{m} は浮動小数点モードになる。

@findex ffs
@item (ffs:@var{m} @var{x})
@var{x} の、 1 であるビットのうちの最下位のビットの位置に 1 を足したものを、
モード @var{m} の整数として表現する。(@var{x} がゼロであれば、この値は
0 になる。)
@var{x} のモードは @var{m} でなくても良い。
ターゲットの機種により、色々なモードの組合せが有効である。
@end table

@node Comparisons
@section Comparison Operations
@cindex RTL comparison operations

Comparison operators test a relation on two operands and are considered
to represent a machine-dependent nonzero value described by, but not
necessarily equal to, @code{STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or zero if it does not, for comparison operators
whose results have a `MODE_INT' mode,
@code{FLOAT_STORE_FLAG_VALUE} (@pxref{Misc}) if the relation holds, or
zero if it does not, for comparison operators that return floating-point
values, and a vector of either @code{VECTOR_STORE_FLAG_VALUE} (@pxref{Misc})
if the relation holds, or of zeros if it does not, for comparison operators
that return vector results.
The mode of the comparison operation is independent of the mode
of the data being compared.  If the comparison operation is being tested
(e.g., the first operand of an @code{if_then_else}), the mode must be
@code{VOIDmode}.

@cindex condition codes
There are two ways that comparison operations may be used.  The
comparison operators may be used to compare the condition codes
@code{(cc0)} against zero, as in @code{(eq (cc0) (const_int 0))}.  Such
a construct actually refers to the result of the preceding instruction
in which the condition codes were set.  The instruction setting the
condition code must be adjacent to the instruction using the condition
code; only @code{note} insns may separate them.

Alternatively, a comparison operation may directly compare two data
objects.  The mode of the comparison is determined by the operands; they
must both be valid for a common machine mode.  A comparison with both
operands constant would be invalid as the machine mode could not be
deduced from it, but such a comparison should never exist in RTL due to
constant folding.

In the example above, if @code{(cc0)} were last set to
@code{(compare @var{x} @var{y})}, the comparison operation is
identical to @code{(eq @var{x} @var{y})}.  Usually only one style
of comparisons is supported on a particular machine, but the combine
pass will try to merge the operations to produce the @code{eq} shown
in case it exists in the context of the particular insn involved.

Inequality comparisons come in two flavors, signed and unsigned.  Thus,
there are distinct expression codes @code{gt} and @code{gtu} for signed and
unsigned greater-than.  These can produce different results for the same
pair of integer values: for example, 1 is signed greater-than @minus{}1 but not
unsigned greater-than, because @minus{}1 when regarded as unsigned is actually
@code{0xffffffff} which is greater than 1.

The signed comparisons are also used for floating point values.  Floating
point comparisons are distinguished by the machine modes of the operands.

@table @code
@findex eq
@cindex equal
@item (eq:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are equal, otherwise 0.

@findex ne
@cindex not equal
@item (ne:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the values represented by @var{x} and @var{y}
are not equal, otherwise 0.

@findex gt
@cindex greater than
@item (gt:@var{m} @var{x} @var{y})
@code{STORE_FLAG_VALUE} if the @var{x} is greater than @var{y}.  If they
are fixed-point, the comparison is done in a signed sense.

@findex gtu
@cindex greater than
@cindex unsigned greater than
@item (gtu:@var{m} @var{x} @var{y})
Like @code{gt} but does unsigned comparison, on fixed-point numbers only.

@findex lt
@cindex less than
@findex ltu
@cindex unsigned less than
@item (lt:@var{m} @var{x} @var{y})
@itemx (ltu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than''.

@findex ge
@cindex greater than
@findex geu
@cindex unsigned greater than
@item (ge:@var{m} @var{x} @var{y})
@itemx (geu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``greater than or equal''.

@findex le
@cindex less than or equal
@findex leu
@cindex unsigned less than
@item (le:@var{m} @var{x} @var{y})
@itemx (leu:@var{m} @var{x} @var{y})
Like @code{gt} and @code{gtu} but test for ``less than or equal''.

@findex if_then_else
@item (if_then_else @var{cond} @var{then} @var{else})
This is not a comparison operation but is listed here because it is
always used in conjunction with a comparison operation.  To be
precise, @var{cond} is a comparison expression.  This expression
represents a choice, according to @var{cond}, between the value
represented by @var{then} and the one represented by @var{else}.

On most machines, @code{if_then_else} expressions are valid only
to express conditional jumps.

@findex cond
@item (cond [@var{test1} @var{value1} @var{test2} @var{value2} @dots{}] @var{default})
Similar to @code{if_then_else}, but more general.  Each of @var{test1},
@var{test2}, @dots{} is performed in turn.  The result of this expression is
the @var{value} corresponding to the first nonzero test, or @var{default} if
none of the tests are nonzero expressions.

This is currently not valid for instruction patterns and is supported only
for insn attributes.  @xref{Insn Attributes}.
@end table

@node Bit-Fields
@section Bit-Fields
@cindex bit-fields

特別な式コードがあり、ビットフィールド命令を表現することができる。
この型の式は、RTL 中で左辺値となる。代入式の左辺に置くことが可能で、
その式で指定されたビットフィールドにある値を代入することを指示する。

@table @code
@findex sign_extract
@cindex @code{BITS_BIG_ENDIAN}, effect on @code{sign_extract}
@item (sign_extract:@var{m} @var{loc} @var{size} @var{pos})
これは、@var{loc}(メモリかレジスタの参照)に含まれるか、そこで始まっている
符号拡張されたビットフィールドへの参照を表す。
このビットフィールドは幅が @var{size} ビットで、ビット位置 @var{pos} から
始まっている。コンパイル時の選択により、@code{BITS_BIG_ENDIAN} が、
メモリ単位のどちらの端から @var{pos} を数えるかを指定する。

@var{loc} がメモリ中に置かれているなら、そのモードは一バイト整数のモードで
なければならない。
@var{loc} がレジスタに置かれているなら、使うべきモードは、
パターン @code{insv} または @code{extv} (@pxref{Standard Names})
のオペランドとして指定されたものになり、通常は全語の整数モードである。
何も指定がないときのデフォルトは全語の整数モードになる。

@var{pos} のモードはマシン固有であり、パターン @code{insv} または
@code{extv} でも指定される。

モード @var{m} は、@var{loc} がレジスタなら、それに使われるモードと
同じである。

@findex zero_extract
@item (zero_extract:@var{m} @var{loc} @var{size} @var{pos})

@code{sign_extract} と同様だが、符号なし、あるいはゼロ拡張された
ビットフィールドを参照する。
同じビット列が抽出されるが、符号拡張ではなくゼロで埋め尽くされる。
@end table

@node Conversions
@section Conversions
@cindex conversions
@cindex machine mode conversions

マシンモード間の変換は全て、明示的な変換演算で表す必要がある。
例えば、あるバイトとある全語の和を表す式を、
@code{(plus:SI (reg:QI 34) (reg:SI 80))} と書くことはできない。
なぜなら、@code{plus} という演算では、二つのオペランドは同じマシンモード
を持つ必要があるからである。
このため、バイトの大きさのオペランドを変換演算で以下のように包む必要がある。

@smallexample
(plus:SI (sign_extend:SI (reg:QI 34)) (reg:SI 80))
@end smallexample

変換演算は単なるプレースホルダーではない。というのは、指定された
変換前のモードから変換後のモードへ変換する方法はひとつだけでは
ないからである。変換演算のコードで、変換方法を指定するのである。

以下のどの変換演算でも、@var{x} は @code{VOIDmode} であってはならない。
変換を行なうべきがモードが判らないからである。
変換は、コンパイル時に行なうか、@var{x} をレジスタに保持するかのどちらかで
なければならない。

@table @code
@findex sign_extend
@item (sign_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へ符号拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex zero_extend
@item (zero_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} へゼロ拡張した結果を
表現する。@var{m} は固定小数点モードでなければならず、
@var{x} は、@var{m} より幅の狭いモードの固定小数点値でなければならない。

@findex float_extend
@item (float_extend:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に拡張した結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は、@var{m} より
幅の狭いモードの浮動小数点数値でなければならない。

@findex truncate
@item (truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は固定小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの固定少数点値でなければならない。

@findex float_truncate
@item (float_truncate:@var{m} @var{x})
値 @var{x} をマシンモード @var{m} に打切った結果を表現する。
@var{m} は浮動小数点モードでなければならず、@var{x} は
@var{m} より幅の広いモードの浮動少数点値でなければならない。

@findex float
@item (float:@var{m} @var{x})
固定小数点値 @var{x} を符号付きとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex unsigned_float
@item (unsigned_float:@var{m} @var{x})
固定小数点値 @var{x} を符号無しとみなし、浮動小数点モード @var{m} に
変換した結果を表す。

@findex fix
@item (fix:@var{m} @var{x})
@var{m} が固定小数点モードの場合、浮動小数点値 @var{x} をモード @var{m} の
符号付き整数に変換した結果を表現する。
丸めをどのように行なうかは規定されないので、C プログラムをコンパイルする
ときにこの演算が正しく使えるのは、オペランドが整数値を持つ時だけである。

@findex unsigned_fix
@item (unsigned_fix:@var{m} @var{x})
浮動小数点値 @var{x} をモード @var{m} の符号なし整数に変換した結果を表現する。
丸めをどのように行なうかは規定されない。
@end table

@node RTL Declarations
@section Declarations
@cindex RTL declarations
@cindex declarations, RTL

宣言式コードは、算術演算を表すのではなく、オペランドの状態に関する
表明を表す。

@table @code
@findex strict_low_part
@cindex @code{subreg}, in @code{strict_low_part}
@item (strict_low_part (subreg:@var{m} (reg:@var{n} @var{r}) 0))
この式コードはただ一つの文脈でのみ使われる。
@code{set} 式の目的オペランドとしてだけ使われる。
さらに、この式のオペランドは矛盾のない @code{subreg} 式でなければ
ならない。

@code{strict_low_part} があると、モード @var{n} では意味があるが、
モード @var{m} の一部ではないようなレジスタの一部が、変更すべきで
ないことを示す。
通常、@var{m} の幅がワードより狭いときは、このようなサブレジスタに
代入を行なうと、そのレジスタの他の部分に予期しない影響を与える。
@end table

@node Side Effects
@section Side Effect Expressions
@cindex RTL side effect expressions

ここまで説明してきた式コードは値を表すものであり、動作を
表すものではなかった。
しかし機械命令というものは決して値を生み出すものではない。
機械命令は、マシンの状態に副作用を与えるという点でのみ意味を持つ。
特別な式コードを使って、副作用を表現する。

命令の本体は、必ず以下の副作用を表すコードの一つである。
これまで説明してきた、値を表現するコードは、これらのオペランドとしてのみ
現れるのである。

@table @code
@findex set
@item (set @var{lval} @var{x})
@var{x} の値を @var{lval} で表される場所に格納する動作を表現する。
@var{lval} は、その中に格納可能であるような場所を表す式である。
すなわち、@code{reg}(あるいは @code{subreg}、または @code{strict_low_part})、
@code{mem}、@code{pc}、@code{cc0} のどれかである。

@var{lval} が、@code{reg}、@code{subreg}、@code{mem} のどれかなら、
マシンモードを持つ必要がある。その場合、@var{x} は、そのモードで
有効でなければならない。

@var{lval} が、マシンモードがそのレジスタの全幅より小さいような
@code{reg} であれば、そのマシンモードにより指定されたレジスタの部分には
指定された値が与えられ、レジスタのその他の部分は未定義値となる。
同様に、@var{lval} が、レジスタのモードより狭いモードの @code{subreg} なら、
レジスタのその他の部分がどのように変更されるかは不定である。

@var{lval} が、@code{subreg} の @code{strict_low_part} なら、
@code{subreg} のマシンモードで指定されたレジスタの部分は、
値 @var{x} が与えられ、その他の部分は変更されない。

@var{lval} が @code{(cc0)} なら、マシンモードがないので、
@var{x} は @code{compare} 式か、任意のモードを持つ値で良い。
後者の場合は、``test'' 命令を表現する。
@code{(set (cc0) (reg:@var{m} @var{n}))} という式は、
@code{(set (cc0) (compare (reg:@var{m} @var{n}) (const_int 0)))} という
式に等価である。
前者の式を使ったほうが、コンパイル中のメモリを節約できる。

@cindex jump instructions and @code{set}
@cindex @code{if_then_else} usage
@var{lval} が @code{(pc)} なら、それはジャンプ命令であり、
@var{x} の取りうる値は非常に限られてくる。
@var{x} は、@code{label_ref} 式とすることができる(無条件ジャンプ)。
@code{if_then_else} (条件ジャンプ)とすることもでき、その場合、
第二オペランドか第三オペランドのどちらかが @code{(pc)} (ジャンプしない場合に
使われる)でなければならず、またもう一方は @code{label_ref}
(ジャンプする場合に使われる)でなければならない。
また、@var{x} は @code{mem} または @code{(plus:SI (pc) @var{y})} でも
良い。ここで、@var{y} は @code{reg} か @code{mem} である。
この最後のパターンは分岐テーブル経由のジャンプを表現するのに使われる。

@var{lval} が @code{(cc0)} でも @code{(pc)} でもなければ、
@var{lval} のモードは @code{VOIDmode} としてはならず、@var{x} のモードは
@var{lval} のモードとして有効でなければならない。

@findex SET_DEST
@findex SET_SRC
@var{lval} は @code{SET_DEST} マクロで、@var{x} は @code{SET_SRC} マクロで
アクセスするようにするのが良い。

@findex return
@item (return)
パターン中に単独の式として書くことで、現在の関数から戻ることを
表す。ただし、VAX のように一命令で戻ることができるマシンに
限られる。
関数から戻るためには、複数の命令からなる「エピローグ」を実行する必要が
あるマシンでは、関数からの復帰は、エピローグの直前に置かれるラベルへ
ジャンプすることで行なわれるので、@code{return} 式コードが使われることはない。

@code{if_then_else} 式の中に置いた場合は、呼び出し元に戻るための @code{pc}
に置かれる値を表す。

@code{(return)} というパターンは、論理的には @code{(set (pc) (return))}
と等価であるが、後者の形式が使われることはない。

@findex call
@item (call @var{function} @var{nargs})
関数呼び出しを表現する。@var{function} は @code{mem} 式であり、
この式のアドレスは、呼び出される関数のアドレスである。
@var{nargs} は二つの目的で使われる式である。
あるマシンでは、スタックに積まれた引数のバイト数を表現する。
あるいは、引数レジスタの数を表現する。

どのマシンも @var{function} が持たなければならない標準的な
マシンモードを持っている。マシン記述では、
@code{FUNCTION_MODE} というマクロを、その不可欠のモード名に
展開されるように定義している。
このモードの目的は、どの種類のアドレッシングが許されるかが
アドレスの対象となるマシンモードに依存するマシンにおいて、
どの種類のアドレッシングが許されているかを指定することである。

@findex clobber
@item (clobber @var{x})
予期できない値を @var{x} に格納すること、または格納する可能性が
あることを表す。@var{x} は、@code{reg} 式か、@code{scratch} 式か、
@code{mem} 式のどれかでなければならない。

これが使われるのは一つは、標準的な値を特定のハードレジスタに格納する
文字列命令においてである。
格納される値を記述する手間をかける必要はないが、
文字列命令を越えてその値を保持しようとしないように、
コンパイラにレジスタの値が変更されることを知らせるのが本質的な
事である。

もし @var{x} が @code{(mem:BLK (const_int 0))} なら、
全メモリ位置が上書きされると見なされなければならないことを意味する。

マシン記述では、ある種類のハードレジスタを「呼びだし時破壊」
(``call-clobbered'') として分類していることに注意。
全ての関数の呼びだし命令は、デフォルトでこれらのレジスタを破壊すると
仮定されているので、この事実を示すために @code{clobber} 式を
使う必要はない。
また、各関数呼び出しは、その関数が @code{const} と宣言されていない限り、
任意のメモリ位置を変更する可能性があると仮定されている。

@code{parallel} の最後の組の式が、それぞれ @code{reg} か
@code{match_scratch} 式 (@pxref{RTL Template})を引数とする
@code{clobber} 式なら、組合せフェーズは、そうすることでパターンが
マッチするようになるなら、適切な @code{clobber} 式を、構築されたばかりの
insn に追加する。

この機能は、例えば、乗算命令と加算命令は MQ レジスタを使わないが、
アキュムレータへの加算命令が MQ レジスタを上書きするようなマシンで
使うことができる。
一個の組み合わされた命令(? combined instruction)は一時レジスタを
必要とするが、一方、それを構成する命令は一時レジスタを必要としない
場合も同様である。

あるレジスタに対する @code{clobber} 式が、他に副作用のある @code{parallel}
の中に現れた場合は、レジスタ確保部が、そのレジスタがその insn の前後
どちらにおいても占有されることがないことを保証する。
しかし、選ばれた選択肢に対して制約 @samp{&} が指定されていない限り、
再ロードパスが入力の一つとして使われたレジスタを確保する場合がある
(@pxref{Modifiers})。
特定のハードレジスタ、または疑似レジスタ、あるいは @code{scratch} 式の
どれかを上書きすることができる。後の二つの場合には、
GNU CC は、その時点で一時的に使用可能なハードレジスタを確保する

一時レジスタを必要とする命令については、疑似レジスタの代わりに
@code{scratch} を使うべきである。
そうしておくと、組合せフェーズが必要なときに @code{clobber} を追加すること
を許すからである。
このためには (@code{clobber} (@code{match_scratch} @dots{})) と
書けば良い。
疑似レジスタを上書きするなら、他のどこにも現れていないものを
使うこと。つまり、そのたびに新しいものを生成して使うこと。
そうしないと、CSE のフェーズが混乱する。

@code{parallel} 中で疑似レジスタを上書きすることのもう一つの使い道が
ある。insn の入力オペランドの一つがやりその insn により上書きされる
場合である。
この場合、insn 中の clobber の中と、別のところとに同じ疑似レジスタを
使うと期待どおりの結果が得られる。

@findex use
@item (use @var{x})
@var{x} の値が使われるということを表す。
プログラムのこの時点での @var{x} の値が必要であることを示す。
たとえ、なぜ必要であるかがはっきりしていなくてもである。
このため、GCC は、@var{x} に値を格納するという
効果しか持たない命令が直前にあっても、その命令を削除しない。
@var{x} は、@code{reg} 式でなければならない。

再ロードフェーズの間、パターンとして @code{use} がある insn は、
@code{reg_equal} ノートを保持することが可能である。
このような @code{use} insn は、再ロードフェーズが終了する前に
削除される。

遅延分岐スケジューリングのフェーズの間は、@var{x} は insn でも良い。
これは、@var{x} が以前にコード中のこの場所にあって、そのデータ依存関係
を考慮する必要があるということを意味する。
このような @code{use} insn は、遅延分岐スケジューリングのフェーズの
終了前に削除される。

@findex parallel
@item (parallel [@var{x0} @var{x1} @dots{}])
Represents several side effects performed in parallel.  The square
brackets stand for a vector; the operand of @code{parallel} is a
vector of expressions.  @var{x0}, @var{x1} and so on are individual
side effect expressions---expressions of code @code{set}, @code{call},
@code{return}, @code{simple_return}, @code{clobber} or @code{use}.

``In parallel'' means that first all the values used in the individual
side-effects are computed, and second all the actual side-effects are
performed.  For example,

@smallexample
(parallel [(set (reg:SI 1) (mem:SI (reg:SI 1)))
           (set (mem:SI (reg:SI 1)) (reg:SI 1))])
@end smallexample

@noindent
says unambiguously that the values of hard register 1 and the memory
location addressed by it are interchanged.  In both places where
@code{(reg:SI 1)} appears as a memory address it refers to the value
in register 1 @emph{before} the execution of the insn.

It follows that it is @emph{incorrect} to use @code{parallel} and
expect the result of one @code{set} to be available for the next one.
For example, people sometimes attempt to represent a jump-if-zero
instruction this way:

@smallexample
(parallel [(set (cc0) (reg:SI 34))
           (set (pc) (if_then_else
                        (eq (cc0) (const_int 0))
                        (label_ref @dots{})
                        (pc)))])
@end smallexample

@noindent
But this is incorrect, because it says that the jump condition depends
on the condition code value @emph{before} this instruction, not on the
new value that is set by this instruction.

@cindex peephole optimization, RTL representation
Peephole optimization, which takes place together with final assembly
code output, can produce insns whose patterns consist of a @code{parallel}
whose elements are the operands needed to output the resulting
assembler code---often @code{reg}, @code{mem} or constant expressions.
This would not be well-formed RTL at any other stage in compilation,
but it is OK then because no further optimization remains to be done.
However, the definition of the macro @code{NOTICE_UPDATE_CC}, if
any, must deal with such insns if you define any peephole optimizations.

@findex cond_exec
@item (cond_exec [@var{cond} @var{expr}])
Represents a conditionally executed expression.  The @var{expr} is
executed only if the @var{cond} is nonzero.  The @var{cond} expression
must not have side-effects, but the @var{expr} may very well have
side-effects.

@findex sequence
@item (sequence [@var{insns} @dots{}])
Represents a sequence of insns.  If a @code{sequence} appears in the
chain of insns, then each of the @var{insns} that appears in the sequence
must be suitable for appearing in the chain of insns, i.e. must satisfy
the @code{INSN_P} predicate.

After delay-slot scheduling is completed, an insn and all the insns that
reside in its delay slots are grouped together into a @code{sequence}.
The insn requiring the delay slot is the first insn in the vector;
subsequent insns are to be placed in the delay slot.

@code{INSN_ANNULLED_BRANCH_P} is set on an insn in a delay slot to
indicate that a branch insn should be used that will conditionally annul
the effect of the insns in the delay slots.  In such a case,
@code{INSN_FROM_TARGET_P} indicates that the insn is from the target of
the branch and should be executed only if the branch is taken; otherwise
the insn should be executed only if the branch is not taken.
@xref{Delay Slots}.

Some back ends also use @code{sequence} objects for purposes other than
delay-slot groups.  This is not supported in the common parts of the
compiler, which treat such sequences as delay-slot groups.

DWARF2 Call Frame Address (CFA) adjustments are sometimes also expressed
using @code{sequence} objects as the value of a @code{RTX_FRAME_RELATED_P}
note.  This only happens if the CFA adjustments cannot be easily derived
from the pattern of the instruction to which the note is attached.  In
such cases, the value of the note is used instead of best-guesing the
semantics of the instruction.  The back end can attach notes containing
a @code{sequence} of @code{set} patterns that express the effect of the
parent instruction.
@end table

These expression codes appear in place of a side effect, as the body of
an insn, though strictly speaking they do not always describe side
effects as such:

@table @code
@findex asm_input
@item (asm_input @var{s})
Represents literal assembler code as described by the string @var{s}.

@findex unspec
@findex unspec_volatile
@item (unspec [@var{operands} @dots{}] @var{index})
@itemx (unspec_volatile [@var{operands} @dots{}] @var{index})
Represents a machine-specific operation on @var{operands}.  @var{index}
selects between multiple machine-specific operations.
@code{unspec_volatile} is used for volatile operations and operations
that may trap; @code{unspec} is used for other operations.

These codes may appear inside a @code{pattern} of an
insn, inside a @code{parallel}, or inside an expression.

@findex addr_vec
@item (addr_vec:@var{m} [@var{lr0} @var{lr1} @dots{}])
Represents a table of jump addresses.  The vector elements @var{lr0},
etc., are @code{label_ref} expressions.  The mode @var{m} specifies
how much space is given to each address; normally @var{m} would be
@code{Pmode}.

@findex addr_diff_vec
@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})
Represents a table of jump addresses expressed as offsets from
@var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref}
expressions and so is @var{base}.  The mode @var{m} specifies how much
space is given to each address-difference.  @var{min} and @var{max}
are set up by branch shortening and hold a label with a minimum and a
maximum address, respectively.  @var{flags} indicates the relative
position of @var{base}, @var{min} and @var{max} to the containing insn
and of @var{min} and @var{max} to @var{base}.  See rtl.def for details.

@findex prefetch
@item (prefetch:@var{m} @var{addr} @var{rw} @var{locality})
Represents prefetch of memory at address @var{addr}.
Operand @var{rw} is 1 if the prefetch is for data to be written, 0 otherwise;
targets that do not support write prefetches should treat this as a normal
prefetch.
Operand @var{locality} specifies the amount of temporal locality; 0 if there
is none or 1, 2, or 3 for increasing levels of temporal locality;
targets that do not support locality hints should ignore this.

This insn is used to minimize cache-miss latency by moving data into a
cache before it is accessed.  It should use only non-faulting data prefetch
instructions.
@end table

@node Incdec
@section Embedded Side-Effects on Addresses
@cindex RTL preincrement
@cindex RTL postincrement
@cindex RTL predecrement
@cindex RTL postdecrement

メモリアドレスとして現れる、特別な副作用式コードが 6 つある。

@table @code
@findex pre_dec
@item (pre_dec:@var{m} @var{x})
@var{x} を標準量だけデクリメントする副作用を表す。
また、@var{x} がデクリンメントされた後の値も表す。
@var{x} は @code{reg} か @code{mem} でなければならず、
ほとんどのマシンでは @code{reg} しか許していない。
@var{m} はそのマシンのポインタ用のマシンモードでなければならない。
@var{x} のデクリメントされる量は、アドレスとして振る舞う式の
メモリ参照を含むマシンモードの長さをバイト数で表したものである。
以下に使い方の例を示す。

@smallexample
(mem:DF (pre_dec:SI (reg:SI 39)))
@end smallexample

@noindent
これは、疑似レジスタ 39 を @code{DFmode} の値の長さだけデクリメントし、
その結果を @code{DFmode} の値のアドレスとして使う事を示している。

@findex pre_inc
@item (pre_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_dec
@item (post_dec:@var{m} @var{x})
@code{pre_dec} と同じ副作用を表すが、異なる値になる。
これにより表される値は、デクリメントされる前の @var{x} の値である。

@findex post_inc
@item (post_inc:@var{m} @var{x})
同様だが、デクリンメントではなく @var{x} のインクリメントを指定する。

@findex post_modify
@item (post_modify:@var{m} @var{x} @var{y})

@var{x} を @var{y} に設定する副作用を表現し、かつ @var{x} が修正を受ける前の
@var{x} を表現する。@var{x} は @code{reg} か @code{mem} でなければならない。
だが、多くの機種では @code{reg} しか許していない。
@var{m} は使われている機種でのポインタのマシンモードでなければならない。
@var{x} がデクリメントされる量は、この式がアドレスの役割をする
メモリ参照のマシンモードの長さをバイトで表したものである。
これは、現在実装されていないことに注意。

式 @var{y} は次の三つの形式のうちの一つでなければならない。
@table @code
@code{(plus:@var{m} @var{x} @var{z})}
@code{(minus:@var{m} @var{x} @var{z})}
@code{(plus:@var{m} @var{x} @var{i})}
@end table
ここで @var{z} はインデックス・レジスタで、@var{i} は定数である。

使い方の例を示す。

@smallexample
(mem:SF (post_modify:SI (reg:SI 42) (plus (reg:SI 42)
                                          (reg:SI 48))))
@end smallexample

これは、疑似レジスタ 42 を、疑似レジスタ 48 の内容をそれに加算する形で
変更することを示している。ただし、42 が指し示していた内容が使われた後で
行われる。

@findex pre_modify
@item (pre_modify:@var{m} @var{x} @var{expr})
同様に、@var{x} の内容を使う前に副作用が発生する。
@end table

これらの組み込み副作用式は注意して使わなければならない。
命令パターンでは使わない。コンパイラの @samp{flow} パスに至るまでは、
スタックへのプッシュを表現するのに使われるだけである。
@samp{flow} パスは、レジスタが一個の命令でインクリメントまたはデクリメント
され、かつ、その直前または直後でアドレスとして使われている場合を
探す。そのような場合は、プリ／ポスト・インクリメント／デクリメントを
使うように変換する。

これらの式のオペランドとして使われているレジスタが、
ある insn の別のアドレス中で使われていると、そのレジスタの元の値が使われる。
レジスタをアドレス以外に使うことは、同一 insn 内で埋め込み副作用式として
使うのは許されない。なぜなら、そういう式は、
異なる機種では異なる振る舞いをし、そのため、取扱いが曖昧になるので
許されない。

組み込み副作用式で表現可能な命令は、また、
アドレスレジスタがどのように変更されるかを記述する追加の @code{set}
を含む @code{parallel} を使って表現することもできる。
だが、これは行なわれない。何故ならこのような操作をともかく許す機種では、
典型的には、メモリアドレスが要求される場所ならどこでもそういう操作を
許すからである。
これらの操作を付加的な並列格納として記述すると、
マシン記述のエントリ数が二倍必要になる。

@node Assembler
@section Assembler Instructions as Expressions
@cindex assembler instructions in RTL

@cindex @code{asm_operands}, usage
RTX コード @code{asm_operands} は、ユーザが指定したアセンブラ命令に
より生成される値を表現する。引数付きの @code{asm} 文を表現するのに
使われる。出力オペランドが一つの @code{asm} 文は以下のようになる。

@smallexample
asm ("foo %1,%2,%0" : "=a" (outputvar) : "g" (x + y), "di" (*z));
@end smallexample

@noindent
この @code{asm} 文は、値が @code{outputvar} に格納されることを
表現する、一個の @code{asm_operands} RTX を使って以下のように表現される。

@smallexample
(set @var{rtx-for-outputvar}
     (asm_operands "foo %1,%2,%0" "a" 0
                   [@var{rtx-for-addition-result} @var{rtx-for-*z}]
                   [(asm_input:@var{m1} "g")
                    (asm_input:@var{m2} "di")]))
@end smallexample

@noindent
ここで、@code{asm_operands} RTX のオペランドは、アセンブラテンプレート文字列、
出力オペランドについての制限子、指定されたオペランドの中での出力オペランド
の番号、入力オペランド RTX のベクトル、それに、入力オペランドのモードと
制約のベクトルからなる。モード @var{m1} は、和 @code{x+y} のモードであり、
@var{m2} は、@code{*z} のモードである。

@code{asm} 文に複数の出力値がある場合は、その insn は @code{parallel} の
内側に幾つかの @code{set} RTX を持つ。
@code{set}はそれぞれ @code{asm_operands} を含んでいる。
これらの @code{set} は全て、同じアセンブラテンプレートとベクトルを
共有しているが、それぞれ出力オペランドに応じた制約を保持している。

@node Insns
@section Insns
@cindex insns

関数のコードの RTL 表現は、@dfn{insn} と呼ばれるオブジェクトの
二重線形リストである。insn は他に用途のない特別なコードを持つ式である。
insn の一部は実際の命令である。@code{switch} 文のための分岐テーブル
を表現するものもある。その他、分岐先ラベルや様々な宣言的な情報を
表現するものもある。

各 insn は、それ自身固有のデータを持つほか、現在の関数内の他の insn と
区別するための一意的な識別番号(遅延分岐スケジューリングの後で、
同じ識別番号を持つ insn のコピーが一つの関数内で複数存在することがあるが、
これらのコピーは全く同じであり、@code{sequence} の中にしか現れない)、
それに直前と直後の insn を指すポインタを持っている。
この三つのフィールドはどの insn においても、insn の式コードによらずに、
同じ位置にある。
この三つのフィールドは @code{XEXP} と @code{XINT} を使ってアクセスしても
良いが、以下のような特別なマクロが三つあり、いつでも使うことができる。

@table @code
@findex INSN_UID
@item INSN_UID (@var{i})
Accesses the unique id of insn @var{i}.

@findex PREV_INSN
@item PREV_INSN (@var{i})
Accesses the chain pointer to the insn preceding @var{i}.
If @var{i} is the first insn, this is a null pointer.

@findex NEXT_INSN
@item NEXT_INSN (@var{i})
Accesses the chain pointer to the insn following @var{i}.
If @var{i} is the last insn, this is a null pointer.
@end table

@findex get_insns
@findex get_last_insn
The first insn in the chain is obtained by calling @code{get_insns}; the
last insn is the result of calling @code{get_last_insn}.  Within the
chain delimited by these insns, the @code{NEXT_INSN} and
@code{PREV_INSN} pointers must always correspond: if @var{insn} is not
the first insn,

@smallexample
NEXT_INSN (PREV_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true and if @var{insn} is not the last insn,

@smallexample
PREV_INSN (NEXT_INSN (@var{insn})) == @var{insn}
@end smallexample

@noindent
is always true.

After delay slot scheduling, some of the insns in the chain might be
@code{sequence} expressions, which contain a vector of insns.  The value
of @code{NEXT_INSN} in all but the last of these insns is the next insn
in the vector; the value of @code{NEXT_INSN} of the last insn in the vector
is the same as the value of @code{NEXT_INSN} for the @code{sequence} in
which it is contained.  Similar rules apply for @code{PREV_INSN}.

This means that the above invariants are not necessarily true for insns
inside @code{sequence} expressions.  Specifically, if @var{insn} is the
first insn in a @code{sequence}, @code{NEXT_INSN (PREV_INSN (@var{insn}))}
is the insn containing the @code{sequence} expression, as is the value
of @code{PREV_INSN (NEXT_INSN (@var{insn}))} if @var{insn} is the last
insn in the @code{sequence} expression.  You can use these expressions
to find the containing @code{sequence} expression.

Every insn has one of the following expression codes:

@table @code
@findex insn
@item insn
The expression code @code{insn} is used for instructions that do not jump
and do not do function calls.  @code{sequence} expressions are always
contained in insns with code @code{insn} even if one of those insns
should jump or do function calls.

Insns with code @code{insn} have four additional fields beyond the three
mandatory ones listed above.  These four are described in a table below.

@findex jump_insn
@item jump_insn
The expression code @code{jump_insn} is used for instructions that may
jump (or, more generally, may contain @code{label_ref} expressions to
which @code{pc} can be set in that instruction).  If there is an
instruction to return from the current function, it is recorded as a
@code{jump_insn}.

@findex JUMP_LABEL
@code{jump_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{JUMP_LABEL} which is defined once jump optimization has completed.

For simple conditional and unconditional jumps, this field contains
the @code{code_label} to which this insn will (possibly conditionally)
branch.  In a more complex jump, @code{JUMP_LABEL} records one of the
labels that the insn refers to; other jump target labels are recorded
as @code{REG_LABEL_TARGET} notes.  The exception is @code{addr_vec}
and @code{addr_diff_vec}, where @code{JUMP_LABEL} is @code{NULL_RTX}
and the only way to find the labels is to scan the entire body of the
insn.

Return insns count as jumps, but since they do not refer to any
labels, their @code{JUMP_LABEL} is @code{NULL_RTX}.

@findex call_insn
@item call_insn
The expression code @code{call_insn} is used for instructions that may do
function calls.  It is important to distinguish these instructions because
they imply that certain registers and memory locations may be altered
unpredictably.

@findex CALL_INSN_FUNCTION_USAGE
@code{call_insn} insns have the same extra fields as @code{insn} insns,
accessed in the same way and in addition contain a field
@code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of
@code{expr_list} expressions) containing @code{use}, @code{clobber} and
sometimes @code{set} expressions that denote hard registers and
@code{mem}s used or clobbered by the called function.

A @code{mem} generally points to a stack slot in which arguments passed
to the libcall by reference (@pxref{Register Arguments,
TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is
caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),
the stack slot will be mentioned in @code{clobber} and @code{use}
entries; if it's callee-copied, only a @code{use} will appear, and the
@code{mem} may point to addresses that are not stack slots.

Registers occurring inside a @code{clobber} in this list augment
registers specified in @code{CALL_USED_REGISTERS} (@pxref{Register
Basics}).

If the list contains a @code{set} involving two registers, it indicates
that the function returns one of its arguments.  Such a @code{set} may
look like a no-op if the same register holds the argument and the return
value.

@findex code_label
@findex CODE_LABEL_NUMBER
@item code_label
A @code{code_label} insn represents a label that a jump insn can jump
to.  It contains two special fields of data in addition to the three
standard ones.  @code{CODE_LABEL_NUMBER} is used to hold the @dfn{label
number}, a number that identifies this label uniquely among all the
labels in the compilation (not just in the current function).
Ultimately, the label is represented in the assembler output as an
assembler label, usually of the form @samp{L@var{n}} where @var{n} is
the label number.

When a @code{code_label} appears in an RTL expression, it normally
appears within a @code{label_ref} which represents the address of
the label, as a number.

Besides as a @code{code_label}, a label can also be represented as a
@code{note} of type @code{NOTE_INSN_DELETED_LABEL}.

@findex LABEL_NUSES
The field @code{LABEL_NUSES} is only defined once the jump optimization
phase is completed.  It contains the number of times this label is
referenced in the current function.

@findex LABEL_KIND
@findex SET_LABEL_KIND
@findex LABEL_ALT_ENTRY_P
@cindex alternate entry points
The field @code{LABEL_KIND} differentiates four different types of
labels: @code{LABEL_NORMAL}, @code{LABEL_STATIC_ENTRY},
@code{LABEL_GLOBAL_ENTRY}, and @code{LABEL_WEAK_ENTRY}.  The only labels
that do not have type @code{LABEL_NORMAL} are @dfn{alternate entry
points} to the current function.  These may be static (visible only in
the containing translation unit), global (exposed to all translation
units), or weak (global, but can be overridden by another symbol with the
same name).

Much of the compiler treats all four kinds of label identically.  Some
of it needs to know whether or not a label is an alternate entry point;
for this purpose, the macro @code{LABEL_ALT_ENTRY_P} is provided.  It is
equivalent to testing whether @samp{LABEL_KIND (label) == LABEL_NORMAL}.
The only place that cares about the distinction between static, global,
and weak alternate entry points, besides the front-end code that creates
them, is the function @code{output_alternate_entry_point}, in
@file{final.c}.

To set the kind of a label, use the @code{SET_LABEL_KIND} macro.

@findex jump_table_data
@item jump_table_data
A @code{jump_table_data} insn is a placeholder for the jump-table data
of a @code{casesi} or @code{tablejump} insn.  They are placed after
a @code{tablejump_p} insn.  A @code{jump_table_data} insn is not part o
a basic blockm but it is associated with the basic block that ends with
the @code{tablejump_p} insn.  The @code{PATTERN} of a @code{jump_table_data}
is always either an @code{addr_vec} or an @code{addr_diff_vec}, and a
@code{jump_table_data} insn is always preceded by a @code{code_label}.
The @code{tablejump_p} insn refers to that @code{code_label} via its
@code{JUMP_LABEL}.

@findex barrier
@item barrier
Barriers are placed in the instruction stream when control cannot flow
past them.  They are placed after unconditional jump instructions to
indicate that the jumps are unconditional and after calls to
@code{volatile} functions, which do not return (e.g., @code{exit}).
They contain no information beyond the three standard fields.

@findex note
@findex NOTE_LINE_NUMBER
@findex NOTE_SOURCE_FILE
@item note
@code{note} insns are used to represent additional debugging and
declarative information.  They contain two nonstandard fields, an
integer which is accessed with the macro @code{NOTE_LINE_NUMBER} and a
string accessed with @code{NOTE_SOURCE_FILE}.

If @code{NOTE_LINE_NUMBER} is positive, the note represents the
position of a source line and @code{NOTE_SOURCE_FILE} is the source file name
that the line came from.  These notes control generation of line
number data in the assembler output.

Otherwise, @code{NOTE_LINE_NUMBER} is not really a line number but a
code with one of the following values (and @code{NOTE_SOURCE_FILE}
must contain a null pointer):

@table @code
@findex NOTE_INSN_DELETED
@item NOTE_INSN_DELETED
Such a note is completely ignorable.  Some passes of the compiler
delete insns by altering them into notes of this kind.

@findex NOTE_INSN_DELETED_LABEL
@item NOTE_INSN_DELETED_LABEL
This marks what used to be a @code{code_label}, but was not used for other
purposes than taking its address and was transformed to mark that no
code jumps to it.

@findex NOTE_INSN_BLOCK_BEG
@findex NOTE_INSN_BLOCK_END
@item NOTE_INSN_BLOCK_BEG
@itemx NOTE_INSN_BLOCK_END
These types of notes indicate the position of the beginning and end
of a level of scoping of variable names.  They control the output
of debugging information.

@findex NOTE_INSN_EH_REGION_BEG
@findex NOTE_INSN_EH_REGION_END
@item NOTE_INSN_EH_REGION_BEG
@itemx NOTE_INSN_EH_REGION_END
These types of notes indicate the position of the beginning and end of a
level of scoping for exception handling.  @code{NOTE_EH_HANDLER}
identifies which region is associated with these notes.

@findex NOTE_INSN_FUNCTION_BEG
@item NOTE_INSN_FUNCTION_BEG
Appears at the start of the function body, after the function
prologue.

@findex NOTE_INSN_VAR_LOCATION
@findex NOTE_VAR_LOCATION
@item NOTE_INSN_VAR_LOCATION
This note is used to generate variable location debugging information.
It indicates that the user variable in its @code{VAR_LOCATION} operand
is at the location given in the RTL expression, or holds a value that
can be computed by evaluating the RTL expression from that static
point in the program up to the next such note for the same user
variable.

@end table

これらのコードは、デバッギングダンプにはシンボルで表示される。

@end table

@cindex @code{TImode}, in @code{insn}
@cindex @code{HImode}, in @code{insn}
@cindex @code{QImode}, in @code{insn}
The machine mode of an insn is normally @code{VOIDmode}, but some
phases use the mode for various purposes.

The common subexpression elimination pass sets the mode of an insn to
@code{QImode} when it is the first insn in a block that has already
been processed.

The second Haifa scheduling pass, for targets that can multiple issue,
sets the mode of an insn to @code{TImode} when it is believed that the
instruction begins an issue group.  That is, when the instruction
cannot issue simultaneously with the previous.  This may be relied on
by later passes, in particular machine-dependent reorg.

Here is a table of the extra fields of @code{insn}, @code{jump_insn}
and @code{call_insn} insns:

@table @code
@findex PATTERN
@item PATTERN (@var{i})
An expression for the side effect performed by this insn.  This must
be one of the following codes: @code{set}, @code{call}, @code{use},
@code{clobber}, @code{return}, @code{simple_return}, @code{asm_input},
@code{asm_output}, @code{addr_vec}, @code{addr_diff_vec},
@code{trap_if}, @code{unspec}, @code{unspec_volatile},
@code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a
@code{parallel}, each element of the @code{parallel} must be one these
codes, except that @code{parallel} expressions cannot be nested and
@code{addr_vec} and @code{addr_diff_vec} are not permitted inside a
@code{parallel} expression.

@findex INSN_CODE
@item INSN_CODE (@var{i})
An integer that says which pattern in the machine description matches
this insn, or @minus{}1 if the matching has not yet been attempted.

Such matching is never attempted and this field remains @minus{}1 on an insn
whose pattern consists of a single @code{use}, @code{clobber},
@code{asm_input}, @code{addr_vec} or @code{addr_diff_vec} expression.

@findex asm_noperands
Matching is also never attempted on insns that result from an @code{asm}
statement.  These contain at least one @code{asm_operands} expression.
The function @code{asm_noperands} returns a non-negative value for
such insns.

In the debugging output, this field is printed as a number followed by
a symbolic representation that locates the pattern in the @file{md}
file as some small positive or negative offset from a named pattern.

@findex LOG_LINKS
@item LOG_LINKS (@var{i})
A list (chain of @code{insn_list} expressions) giving information about
dependencies between instructions within a basic block.  Neither a jump
nor a label may come between the related insns.  These are only used by
the schedulers and by combine.  This is a deprecated data structure.
Def-use and use-def chains are now preferred.

@findex REG_NOTES
@item REG_NOTES (@var{i})
A list (chain of @code{expr_list}, @code{insn_list} and @code{int_list}
expressions) giving miscellaneous information about the insn.  It is often
information pertaining to the registers used in this insn.
@end table

The @code{LOG_LINKS} field of an insn is a chain of @code{insn_list}
expressions.  Each of these has two operands: the first is an insn,
and the second is another @code{insn_list} expression (the next one in
the chain).  The last @code{insn_list} in the chain has a null pointer
as second operand.  The significant thing about the chain is which
insns appear in it (as first operands of @code{insn_list}
expressions).  Their order is not significant.

This list is originally set up by the flow analysis pass; it is a null
pointer until then.  Flow only adds links for those data dependencies
which can be used for instruction combination.  For each insn, the flow
analysis pass adds a link to insns which store into registers values
that are used for the first time in this insn.

The @code{REG_NOTES} field of an insn is a chain similar to the
@code{LOG_LINKS} field but it includes @code{expr_list} and @code{int_list}
expressions in addition to @code{insn_list} expressions.  There are several
kinds of register notes, which are distinguished by the machine mode, which
in a register note is really understood as being an @code{enum reg_note}.
The first operand @var{op} of the note is data whose meaning depends on
the kind of note.

@findex REG_NOTE_KIND
@findex PUT_REG_NOTE_KIND
The macro @code{REG_NOTE_KIND (@var{x})} returns the kind of
register note.  Its counterpart, the macro @code{PUT_REG_NOTE_KIND
(@var{x}, @var{newkind})} sets the register note type of @var{x} to be
@var{newkind}.

Register notes are of three classes: They may say something about an
input to an insn, they may say something about an output of an insn, or
they may create a linkage between two insns.  There are also a set
of values that are only used in @code{LOG_LINKS}.

These register notes annotate inputs to an insn:

@table @code
@findex REG_DEAD
@item REG_DEAD
The value in @var{op} dies in this insn; that is to say, altering the
value immediately after this insn would not affect the future behavior
of the program.

It does not follow that the register @var{op} has no useful value after
this insn since @var{op} is not necessarily modified by this insn.
Rather, no subsequent instruction uses the contents of @var{op}.

@findex REG_UNUSED
@item REG_UNUSED
The register @var{op} being set by this insn will not be used in a
subsequent insn.  This differs from a @code{REG_DEAD} note, which
indicates that the value in an input will not be used subsequently.
These two notes are independent; both may be present for the same
register.

@findex REG_INC
@item REG_INC
The register @var{op} is incremented (or decremented; at this level
there is no distinction) by an embedded side effect inside this insn.
This means it appears in a @code{post_inc}, @code{pre_inc},
@code{post_dec} or @code{pre_dec} expression.

@findex REG_NONNEG
@item REG_NONNEG
The register @var{op} is known to have a nonnegative value when this
insn is reached.  This is used so that decrement and branch until zero
instructions, such as the m68k dbra, can be matched.

The @code{REG_NONNEG} note is added to insns only if the machine
description has a @samp{decrement_and_branch_until_zero} pattern.

@findex REG_LABEL_OPERAND
@item REG_LABEL_OPERAND
This insn uses @var{op}, a @code{code_label} or a @code{note} of type
@code{NOTE_INSN_DELETED_LABEL}, but is not a @code{jump_insn}, or it
is a @code{jump_insn} that refers to the operand as an ordinary
operand.  The label may still eventually be a jump target, but if so
in an indirect jump in a subsequent insn.  The presence of this note
allows jump optimization to be aware that @var{op} is, in fact, being
used, and flow optimization to build an accurate flow graph.

@findex REG_LABEL_TARGET
@item REG_LABEL_TARGET
This insn is a @code{jump_insn} but not an @code{addr_vec} or
@code{addr_diff_vec}.  It uses @var{op}, a @code{code_label} as a
direct or indirect jump target.  Its purpose is similar to that of
@code{REG_LABEL_OPERAND}.  This note is only present if the insn has
multiple targets; the last label in the insn (in the highest numbered
insn-field) goes into the @code{JUMP_LABEL} field and does not have a
@code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.

@findex REG_CROSSING_JUMP
@item REG_CROSSING_JUMP
This insn is a branching instruction (either an unconditional jump or
an indirect jump) which crosses between hot and cold sections, which
could potentially be very far apart in the executable.  The presence
of this note indicates to other optimizations that this branching
instruction should not be ``collapsed'' into a simpler branching
construct.  It is used when the optimization to partition basic blocks
into hot and cold sections is turned on.

@findex REG_SETJMP
@item REG_SETJMP
Appears attached to each @code{CALL_INSN} to @code{setjmp} or a
related function.
@end table

The following notes describe attributes of outputs of an insn:

@table @code
@findex REG_EQUIV
@findex REG_EQUAL
@item REG_EQUIV
@itemx REG_EQUAL
This note is only valid on an insn that sets only one register and
indicates that that register will be equal to @var{op} at run time; the
scope of this equivalence differs between the two types of notes.  The
value which the insn explicitly copies into the register may look
different from @var{op}, but they will be equal at run time.  If the
output of the single @code{set} is a @code{strict_low_part} expression,
the note refers to the register that is contained in @code{SUBREG_REG}
of the @code{subreg} expression.

For @code{REG_EQUIV}, the register is equivalent to @var{op} throughout
the entire function, and could validly be replaced in all its
occurrences by @var{op}.  (``Validly'' here refers to the data flow of
the program; simple replacement may make some insns invalid.)  For
example, when a constant is loaded into a register that is never
assigned any other value, this kind of note is used.

When a parameter is copied into a pseudo-register at entry to a function,
a note of this kind records that the register is equivalent to the stack
slot where the parameter was passed.  Although in this case the register
may be set by other insns, it is still valid to replace the register
by the stack slot throughout the function.

A @code{REG_EQUIV} note is also used on an instruction which copies a
register parameter into a pseudo-register at entry to a function, if
there is a stack slot where that parameter could be stored.  Although
other insns may set the pseudo-register, it is valid for the compiler to
replace the pseudo-register by stack slot throughout the function,
provided the compiler ensures that the stack slot is properly
initialized by making the replacement in the initial copy instruction as
well.  This is used on machines for which the calling convention
allocates stack space for register parameters.  See
@code{REG_PARM_STACK_SPACE} in @ref{Stack Arguments}.

In the case of @code{REG_EQUAL}, the register that is set by this insn
will be equal to @var{op} at run time at the end of this insn but not
necessarily elsewhere in the function.  In this case, @var{op}
is typically an arithmetic expression.  For example, when a sequence of
insns such as a library call is used to perform an arithmetic operation,
this kind of note is attached to the insn that produces or copies the
final value.

These two notes are used in different ways by the compiler passes.
@code{REG_EQUAL} is used by passes prior to register allocation (such as
common subexpression elimination and loop optimization) to tell them how
to think of that value.  @code{REG_EQUIV} notes are used by register
allocation to indicate that there is an available substitute expression
(either a constant or a @code{mem} expression for the location of a
parameter on the stack) that may be used in place of a register if
insufficient registers are available.

Except for stack homes for parameters, which are indicated by a
@code{REG_EQUIV} note and are not useful to the early optimization
passes and pseudo registers that are equivalent to a memory location
throughout their entire life, which is not detected until later in
the compilation, all equivalences are initially indicated by an attached
@code{REG_EQUAL} note.  In the early stages of register allocation, a
@code{REG_EQUAL} note is changed into a @code{REG_EQUIV} note if
@var{op} is a constant and the insn represents the only set of its
destination register.

Thus, compiler passes prior to register allocation need only check for
@code{REG_EQUAL} notes and passes subsequent to register allocation
need only check for @code{REG_EQUIV} notes.
@end table

These notes describe linkages between insns.  They occur in pairs: one
insn has one of a pair of notes that points to a second insn, which has
the inverse note pointing back to the first insn.

@table @code
@findex REG_CC_SETTER
@findex REG_CC_USER
@item REG_CC_SETTER
@itemx REG_CC_USER
On machines that use @code{cc0}, the insns which set and use @code{cc0}
set and use @code{cc0} are adjacent.  However, when branch delay slot
filling is done, this may no longer be true.  In this case a
@code{REG_CC_USER} note will be placed on the insn setting @code{cc0} to
point to the insn using @code{cc0} and a @code{REG_CC_SETTER} note will
be placed on the insn using @code{cc0} to point to the insn setting
@code{cc0}.
@end table

These values are only used in the @code{LOG_LINKS} field, and indicate
the type of dependency that each link represents.  Links which indicate
a data dependence (a read after write dependence) do not use any code,
they simply have mode @code{VOIDmode}, and are printed without any
descriptive text.

@table @code
@findex REG_DEP_TRUE
@item REG_DEP_TRUE
This indicates a true dependence (a read after write dependence).

@findex REG_DEP_OUTPUT
@item REG_DEP_OUTPUT
This indicates an output dependence (a write after write dependence).

@findex REG_DEP_ANTI
@item REG_DEP_ANTI
This indicates an anti dependence (a write after read dependence).

@end table

These notes describe information gathered from gcov profile data.  They
are stored in the @code{REG_NOTES} field of an insn.

@table @code
@findex REG_BR_PROB
@item REG_BR_PROB
This is used to specify the ratio of branches to non-branches of a
branch insn according to the profile data.  The note is represented
as an @code{int_list} expression whose integer value is between 0 and
REG_BR_PROB_BASE.  Larger values indicate a higher probability that
the branch will be taken.

@findex REG_BR_PRED
@item REG_BR_PRED
These notes are found in JUMP insns after delayed branch scheduling
has taken place.  They indicate both the direction and the likelihood
of the JUMP@.  The format is a bitmask of ATTR_FLAG_* values.

@findex REG_FRAME_RELATED_EXPR
@item REG_FRAME_RELATED_EXPR
This is used on an RTX_FRAME_RELATED_P insn wherein the attached expression
is used in place of the actual insn pattern.  This is done in cases where
the pattern is either complex or misleading.
@end table

For convenience, the machine mode in an @code{insn_list} or
@code{expr_list} is printed using these symbolic codes in debugging dumps.

@findex insn_list
@findex expr_list
The only difference between the expression codes @code{insn_list} and
@code{expr_list} is that the first operand of an @code{insn_list} is
assumed to be an insn and is printed in debugging dumps as the insn's
unique id; the first operand of an @code{expr_list} is printed in the
ordinary way as an expression.

@node Calls
@section RTL Representation of Function-Call Insns
@cindex calling functions in RTL
@cindex RTL function-call insns
@cindex function-call insns

サブルーチンを呼び出す insn は、RTL 式コードが @code{call_insn} になる。
サブルーチン呼び出し insn は特別な規則に従う必要があり、
本体部分で特別な RTL 式コード @code{call} を使わなければならない。

@cindex @code{call} usage
@code{call} 式は、以下のようにオペランドを二つ取る。

@smallexample
(call (mem:@var{fm} @var{addr}) @var{nbytes})
@end smallexample

@noindent
ここで、@var{nbytes} は、サブルーチンに渡される引数データのバイト数を
表すオペランドである。@var{fm} はマシンモードであり、
@var{addr} はサブルーチンのアドレスを表す。
@var{fm} は、マシン記述の @code{FUNCTION_MODE} マクロの定義と
同じでなければならない。

値を返さないサブルーチンについては、上に示した @code{call} 式そのものが
insn の全体になる。ただし、@code{use} 式か @code{clobber} 式を
その他に含んでいる必要がある。

@cindex @code{BLKmode}, and function return values
戻り値があり、そのモードが @code{BLKmode} でないサブルーチンについては、
戻り値はハードレジスタに置かれる。このレジスタの番号が @var{r} なら、
call insn の本体は以下のようになる。

@smallexample
(set (reg:@var{m} @var{r})
     (call (mem:@var{fm} @var{addr}) @var{nbytes}))
@end smallexample

@noindent
この RTL 式は、この insn で、適切なレジスタに有効な値が置かれる
ことを(最適化パスに対して)はっきりさせる。

サブルーチンが @code{BLKmode} の値を返すなら、
その値を格納すべき位置のアドレスをサブルーチンに渡すという処理が
行なわれる。このため、call insn 自身はどんな値も返さないので、
値を返さない呼び出しと同じ形式の RTL になる。

マシンによっては、call 命令自身が幾つかのレジスタを、例えば
戻り先アドレスを保持するために、破壊する。
そういうマシンでの @code{call_insn} insn の本体は、
@code{call} 式と @code{clobber} 式の両方を持つ、一個の @code{parallel}
とすべきである。この @code{clobber} 式は、どのレジスタが破壊されるかを
示す。
同様に、call 命令が、スタックポインタ以外に、RTL で明示的に指定
されていないレジスタを必要とするときは、@code{use} 副式がそのレジスタに
ついて言及すべきである。

呼び出される関数は、コンフィギュレーションマクロ @code{CALL_USED_REGISTERS}
(@pxref{Register Basics})に列挙されている全てのレジスタを修正し、
@code{const} 関数とライブラリ呼びだしを例外として、全メモリを
修正すると仮定される。

単に @code{use} 式を含む insn は、どのレジスタが関数への入力を
保持しているかを示す @code{call_insn} の直前に位置する。
同様に、@code{CALL_USED_REGISTERS} で指定されている以外のレジスタが
呼び出された関数により上書きされるなら、単独の @code{clobber} を
含む insn は、それがどのレジスタかを示すために、その呼び出しの直後に
置かれる。

@node Sharing
@section Structure Sharing Assumptions
@cindex sharing of RTL components
@cindex RTL structure sharing assumptions

GNU CC は、ある種類の RTL 式は一意的であることを仮定している。
すなわち、同じ値を表す二つの異なるオブジェクトは存在しないと
仮定しているのである。
一方、それとは逆の、
ある種類の RTL 式オブジェクトは、それを含む構造の中では 2 回以上
現れることはないという仮定をしている場合もある。

これらの仮定は一個の関数に関するものである。
グローバル変数や外部関数を記述する RTL オブジェクト、
それに小さな整数定数のような2,3の基本的なオブジェクトを除いて、
二つの関数に共通の RTL オブジェクトは存在しない。

@itemize @bullet
@cindex @code{reg}, RTL sharing
@item
各疑似レジスタは、それを表現する @code{reg} オブジェクトは一個しか
持たず、そのため、マシンモードも一個しかない。

@cindex symbolic label
@cindex @code{symbol_ref}, RTL sharing
@item
記号名ラベルはどれも、それを参照する @code{symbol_ref} オブジェクトは
一個しかない。

@cindex @code{const_int}, RTL sharing
@item
値が 0、1、@minus{}1 の @code{const_int} 式はそれぞれ一個だけである。
それ以外の幾つかの整数値も一意的に格納される。

@cindex @code{pc}, RTL sharing
@item
@code{pc} 式は一個しかない。

@cindex @code{cc0}, RTL sharing
@item
@code{cc0} 式は一個しかない。

@cindex @code{const_double}, RTL sharing
@item
それぞれの浮動小数点モードで、値 0 の @code{const_double} 式は
それぞれ一個しかない。値が 1 と 2 についても同様である。

@cindex @code{label_ref}, RTL sharing
@cindex @code{scratch}, RTL sharing
@item
@code{label_ref} や @code{scratch} は、RTL 構造体の中で
二箇所以上は現れない。言い換えると、関数の中の全 insn をツリーウォーク
したときに、@code{label_ref} や @code{scratch} が見つかるたびに、
すでに見た他の全てとは違ったものであると仮定しても良い。

@cindex @code{mem}, RTL sharing
@item
各静的変数やスタックスロットについては、普通はただ一個の @code{mem}
オブジェクトが作られる。このため、これらのオブジェクトはそれが現れる
全ての場所で共用されることが多い。
しかし、これらの変数に対して、等価であるが別の独立したオブジェクトが
作られることがたまにある。

@cindex @code{asm_operands}, RTL sharing
@item
一個の @code{asm} 文に複数の出力オペランドがあると、
出力オペランド毎に別々の @code{asm_operands} 式が作られる。
しかし、これらの式は全て、入力オペランドの列を含むベクトルを共有する。
この共有は後で、二つの @code{asm_operands} 式が同じ文に由来するものか
どうかを調べるのに使われる。このため、全ての最適化で、
ベクトルを全部コピーした場合には注意深く共有を維持しなくては
ならない。

@item
上で説明したものを除いて、RTL 構造体に RTL オブジェクトが二箇所以上に
現れることはない。コンパイラのパスの多くが、このことに依存しており、
他の insn に不要な副作用を与えることなく RTL オブジェクトを直接
修正可能であるということを仮定している。

@findex unshare_all_rtl
@item
最初の RTL 生成の間は、共有される構造体が自由に導入される。
ある関数についての 全 RTL 生成が完了した後で、
全ての共有される構造体が @file{emit-rtl.c} の @code{unshare_all_rtl}
関数によりコピーされる。その後で上記のルールが成り立つことが保証される。

@findex copy_rtx_if_shared
@item
組合せパスの間、ある insn 中の共有構造体が一時的に存在できる。
しかし、共有構造体は、組合せパスがその insn についての処理を終了
する前に、コピーされる。
これは @code{copy_rtx_if_shared} を呼び出すことにより行なわれる。
この関数は @code{unshare_all_rtl} のサブルーチンである。
@end itemize

@node Reading RTL
@section Reading RTL

ファイルから RTL オブジェクトを読み込むには、@code{read_rtx} 関数を
使う。引数は、標準入力ストリーム一つであり、一個の RTL オブジェクトを
返す。

ファイルから RTL を読む処理は非常に遅い。現時点ではこれは問題ではない。
RTL の読み込みは、コンパイラを構築するときにのみ行われるからである。

RTL をテキストとしてファイルにセーブして、GNU CC の言語フロントエンドと
その他の部分とのインターフェースとして使おうと考える人が良くいるが、
これは実現不可能である。

GNU CC は、RTL を内部表現として使うようにしか設計されていない。
ある与えられたプログラムに対する正しい RTL は、特定のターゲットマシンに
著しく依存する。しかも、RTL は、そのプログラムについての情報を
全部は含んでいないのである。

GNU CC と新しい言語フロントエンドのインターフェースを取る正しい方法は、
「tree」データ構造を使う事である。このデータ構造について書いたマニュアルは
ないが、@file{tree.h} と @file{tree.def} で説明されている
