@c Copyright (C) 1988-2015 Free Software Foundation, Inc.
@c This is part of the GCC manual.
@c For copying conditions, see the file gcc.texi.

@ifset INTERNALS
@node Machine Desc
@chapter Machine Descriptions
@cindex machine descriptions

マシン記述は二つの部分からなる。機械命令のパターンを記述する
ファイル(@file{.md} ファイル) と C のマクロ定義を記述するヘッダファイル
である。

あるターゲットマシン向けの @file{.md} ファイルは、そのマシンがサポート
している各機械命令(あるいは、少なくとも、GCC が知っていたほうが良い機械命令) 
のパターンを記述する。このファイルにはコメントを書くことができる。
コメントはセミコロンから始まり行末までとなる。ただし、セミコロンが
引用符つき文字列中にある場合を除く。

C のヘッダファイルについては、次章を見ていただきたい

@menu
* Overview::            How the machine description is used.
* Patterns::            命令パターンの書き方
* Example::             @code{define_insn} の例
* RTL Template::        RTL テンプレート
* Output Template::     アセンブラコードの出力方法を指定する出力テンプレート
* Output Statement::    アセンブラコードの出力を行なう C のコード
* Constraints::         オペランド制約
* Standard Names::      コード生成で使われるパターン名
* Pattern Ordering::    パターンの順序が意味を持つ時
* Dependent Patterns::  一つのパターンが別のパターンを必要とするとき
* Jump Patterns::       ジャンプ命令のパターンに関する特別な注意
* Insn Canonicalizations::命令の正規化
* Peephole Definitions::機種固有のピープホール最適化の定義方法
* Expander Definitions::標準の演算向けの各種 RTL insn 列の生成
* Insn Splitting::    複数命令への分割
* Insn Attributes::     生成された insn の属性値を指定する
@end menu

@node Overview
@section Overview of How the Machine Description is Used

There are three main conversions that happen in the compiler:

@enumerate

@item
The front end reads the source code and builds a parse tree.

@item
The parse tree is used to generate an RTL insn list based on named
instruction patterns.

@item
The insn list is matched against the RTL templates to produce assembler
code.

@end enumerate

For the generate pass, only the names of the insns matter, from either a
named @code{define_insn} or a @code{define_expand}.  The compiler will
choose the pattern with the right name and apply the operands according
to the documentation later in this chapter, without regard for the RTL
template or operand constraints.  Note that the names the compiler looks
for are hard-coded in the compiler---it will ignore unnamed patterns and
patterns with names it doesn't know about, but if you don't provide a
named pattern it needs, it will abort.

If a @code{define_insn} is used, the template given is inserted into the
insn list.  If a @code{define_expand} is used, one of three things
happens, based on the condition logic.  The condition logic may manually
create new insns for the insn list, say via @code{emit_insn()}, and
invoke @code{DONE}.  For certain named patterns, it may invoke @code{FAIL} to tell the
compiler to use an alternate way of performing that task.  If it invokes
neither @code{DONE} nor @code{FAIL}, the template given in the pattern
is inserted, as if the @code{define_expand} were a @code{define_insn}.

Once the insn list is generated, various optimization passes convert,
replace, and rearrange the insns in the insn list.  This is where the
@code{define_split} and @code{define_peephole} patterns get used, for
example.

Finally, the insn list's RTL is matched up with the RTL templates in the
@code{define_insn} patterns, and those patterns are used to emit the
final assembly code.  For this purpose, each named @code{define_insn}
acts like it's unnamed, since the names are ignored.

@node Patterns
@section Everything about Instruction Patterns
@cindex patterns
@cindex instruction patterns

@findex define_insn
各命令パターンには、後で埋められる部分を持つ不完全な RTL 式と、各部分が
どのように埋められるかを限定するオペランド制約、それに、出力パターンまたは
アセンブラ出力を生成する C コードが含まれており、全て @code{define_insn} 式
中に記述される。

@code{define_insn} は一つの RTL 式で、四つか五つのオペランドを持つ。
それぞれのオペランドは以下の通りである。

@enumerate
@item
名前。無くても良い。名前があると、
その命令パターンが、GCC の RTL生成パスにおいてある決まった仕事を
成しうるということを意味する。RTL生成パスは一定のパターン名を知っていて、
マシン記述に定義されている名前であれば、その名前の命令パターンを
使おうとする。

名前を書くべき位置に空文字列を書くと名前がないということになる。
名無しの命令パターンは RTL コードの生成に使われることはありえない。
しかし、名無しの命令パターンを使うと、様々なより単純な insn を後で
結合させることが出来る。

つまり、RTL生成時に知られていない、あるいは使われもしない名前は
何の効果ももたらさない。名無しと全く同じである。
@c !!! 「知られていないのに使っても駄目」という意味か?

@item
@dfn{RTL テンプレート} (@pxref{RTL Template}) は、不完全な RTL 式を
要素とするベクトルであり、命令がどのように見えるかを示す。
不完全というのは、その命令のオペランドの代理である、@code{match_operand}
や @code{match_operator}、@code{match_dup} 等の式を含むからである。

RTL テンプレート・ベクトルに要素が一つしかなければ、その要素は命令パターンの
テンプレートである。ベクトルに要素が複数あれば、その命令パターンは
列挙された要素を含む @code{parallel} 式である。

@item
@cindex pattern conditions
@cindex conditions, in patterns
条件。これは文字列であり、insn 本体がパターンにマッチするかどうかを
最終的に決定するための条件を C 言語の式で表したものである。

@cindex named patterns and conditions
名前を持つパターンについては、条件は(もしあれば)、
マッチする insn 中のデータには依存せず、ターゲット機種の型のフラグに
のみ依存する。GCC は、初期化時にこの条件を調べて、どういう名前の
命令が一回毎の実行時に利用できるのかを厳密に調べる必要がある。


@findex operands
名無しのパターンについては、条件は個々の insn とのマッチングを行なう時と、
insn が、そのパターンの評価テンプレートにマッチした後にのみ
適用される。insn のオペランドは、ベクトル @code{operands} に入っている。

@item
出力テンプレート。 マッチした insn をどのようにアセンブラコードとして
出力するかを指示する文字列である。文字列中の @samp{%} は、オペランドの値を
どこに代入するかを指示する。@xref{Output Template}.

単なる置き換えでは充分でないときは、C コードの断片を指定して、計算を
行なったうえで出力させることも出来る。@xref{Output Statement}.

@item
このパターンにマッチする insn の属性値を含むベクトル。
省略可能である。 @xref{Insn Attributes}.
@end enumerate

@node Example
@section Example of @code{define_insn}
@cindex @code{define_insn} example

以下は、命令パターンの実例である。68000/68020 向けである。

@smallexample
(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "general_operand" "rm"))]
  ""
  "*
@{
  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))
    return \"tstl %0\";
  return \"cmpl #0,%0\";
@}")
@end smallexample

これは、汎用レジスタの値に基づいて条件コードをセットする命令である。
条件の指定がないので、RTL 記述が指定された形を持つ任意の命令が、
このパターンに従って扱われる。@samp{tstsi} という名前は、
``test a @code{SImode} value''(@code{SImode} の値をテストする)という
意味で、RTL 生成パスに対して、@code{SImode} の値をテストする必要が
あるときは、それを行う命令はこのパターンを使って構成せよということを
指示する。

出力制御文字列は、C コードの断片であり、どの出力テンプレートを
返すかを、オペランドの種類とコードを生成しようとしている CPU の
特定の型に基づいて選択する。

@node RTL Template
@section RTL Template
@cindex RTL insn template
@cindex generating insns
@cindex insns, generating
@cindex recognizing insns
@cindex insns, recognizing

RTL テンプレートを使い、どの insn が特定のパターンにマッチするのか、および、
そのオペランドの見つけ方を定義する。名前付きパターンの場合は、
RTL テンプレートは、指定されたオペランドからどのように insn を構築するかに
ついても指示する。

構築するということには、指定されたオペランドをテンプレートのコピーに
代入することも含まれる。
照合することには、一致しようとしている insn のオペランドの役割を
果たす値を決定することも含まれる。
どちらの動作も、照合とオペランドの代入を指示する特別な式の型に
より制御される。

@table @code
@findex match_operand
@item (match_operand:@var{m} @var{n} @var{predicate} @var{constraint})
この式は、insn の @var{n} 番目のオペランドのプレースホルダーである。
insn の構築時に、@var{n}番目のオペランドがここに挿入される。
insn の照合時には、insn のこの位置に現れるものは何であれ、
@var{n} 番目のオペランドとして扱われる。ただし、その場合 @var{predicate} を
満たしている必要があり、さもなければこの命令パターンは全くマッチしない。

オペランド番号は、各命令パターンにおいて 0 から始まる数字に
ならなければならない。各オペランド番号について、パターンには
@code{match_operand} 式が一個だけ存在し得る。
普通は、オペランドは @code{match_operand} 式群に現れた順に
番号が付く。
@code{define_expand} の場合には、@code{match_dup} 式でのみ
使用されるオペランド番号はどれも、他のどのオペランド番号よりも
大きな値になる。

@var{predicate} は、ある C の関数名を表す文字列でり、その関数は
二つの引数、すなわち一個の式と一個のマシンモードを受け付ける。
照合が行なわれる間に、式として仮想的なオペランド、モード引数として @var{m} を
使ってその関数が呼び出される。(@var{m} が指定されない場合は、
@code{VOIDmode} が使われ、@var{predicate} は任意のモードを受け付けることに
なる。)
この関数が 0 を返した場合は、この命令パターンの照合に失敗することになる。
@var{predicate} は空の文字列であっても良い。
その場合、オペランドについては何のテストも行なわれず、この位置に
現れるものは何でも有効になる。

ほとんどの場合、@var{predicate} は @var{m} 以外のモードを受け付けない。
ただし、いつでも受け付けないわけではない。
例えば、述語(predicate) @code{address_operand} は、@var{m} を、
そのアドレスが有効なメモリ参照のモードとして使う。
多くの述語は、それらのモードが @code{VOIDmode} であっても @code{const_int}
ノードを受け付ける。

@var{constraint} は再ロードとある値に最適なレジスタクラスの選択を
制御する。これについては後で説明する (@pxref{Constraints})。

制約と述語の違いが良く判らないという人が多い。
述語は、ある与えられた insn がパターンにマッチするかどうかを
判断する手助けをする。
一方、制約は、この判断には関与しない。代わりに、
insn がパターンにマッチした場合の色々な判断を制御するのである。

@findex general_operand
CISC では、最も良く出てくる述語は、@code{"general_operand"} 
である。これは、仮想オペランドが、定数であるのか、レジスタなのか、
メモリ参照なのかを調べ、それがモード @var{m} で有効なのものかどうかを
確かめる。

@findex register_operand
レジスタでなければならないオペランドの場合は、述語としては
@code{"register_operand"} を使うべきである。再ロード過程で
@code{"general_operand"} を使っても、
任意の非レジスタオペランドをレジスタにコピーするという処理を行うので
大丈夫だが、そうすると GCC に余計な仕事をさせることになるし、
ループからの不変オペランド(例えば定数)の除去や最適なレジスタ割り付け
の妨げにもなる。
RISC の場合には、述語としては、制約が許す範囲のオブジェクトのみを
受け付けるようにするのが一般には最も効率が良い。

@findex immediate_operand
定数であるはずのオペランドの場合には、述語として @code{"immediate_operand"}
を使うか、命令パターンの付加条件が定数を要求するようにするか、あるいは両方を
行うようにする必要がある。制約を使えば同じことが出来るだろうと考えては
いけない。
制約の方が定数のみを許すようになっていても、述語がそれ以外のものを
許しているなら、実際にそのケースが発生したときに
GCC は落ちてしまうのである。

@findex match_scratch
@item (match_scratch:@var{m} @var{n} @var{constraint})
この式もオペランド番号 @var{n} のプレースホルダであり、オペランドは
@code{scratch} 式か @code{reg} 式でなければならないことを指定する。

パターン照合の際には、これは、以下の式と等価である。

@smallexample
(match_operand:@var{m} @var{n} "scratch_operand" @var{pred})
@end smallexample

しかし、RTL 生成フェーズでは、これは (@code{scratch}:@var{m}) という式を
生成する。

@code{parallel} の中の最後の幾つかの式が @code{clobber} 式であり、
その @code{clobber} 式のオペランドがハードレジスタか @code{match_scratch}
なら、結合器(combiner) は必要なときにそういうオペランドを追加したり、
削除したりすることができる。

@findex match_dup
@item (match_dup @var{n})
この式もオペランド番号 @var{n} のプレースホルダーである。
オペランドが insn の二箇所以上に現れる必要があるときに使われる。

構築の際には、@code{match_dup} はちょうど @code{match_operand}
と同様に動作する。オペランドは、構築されつつある insn に代入される。
しかし、マッチングでは、@code{match_dup} の動作は異なる。
オペランド番号 @var{n} は認識テンプレートに先に現れる @code{match_operand}
により既に決まっており、見た目が同一の式にしかマッチしないということを
想定している。

@findex match_operator
@item (match_operator:@var{m} @var{n} @var{predicate} [@var{operands}@dots{}])
このパターンは、可変な RTL 式コードの一種のプレースホルダーである。

insn 構築の際には、ある RTL 式を表す。
この RTL 式の式コードは、オペランド @var{n} から取られ、
オペランドはパターンの @var{operands} から構築される。

式と照合する際は、関数 @var{predicate} がその式についてゼロでない
値を返し、@emph{かつ} パターンの @var{operands} がその式のオペランドに
マッチしたときに、その式にマッチする。

関数 @code{commutative_operator} が以下のように定義されていると
する。演算子が RTL の交換可能な算術演算子の一つで、モードが @var{mode}
である任意の式にマッチするように定義されている。

@smallexample
int
commutative_operator (x, mode)
     rtx x;
     enum machine_mode mode;
@{
  enum rtx_code code = GET_CODE (x);
  if (GET_MODE (x) != mode)
    return 0;
  return (GET_RTX_CLASS (code) == 'c'
          || code == EQ || code == NE);
@}
@end smallexample

そうすると、以下のパターンは、二つの一般オペランドに適用される交換可能な
演算子を含む任意の RTL 式にマッチする。

@smallexample
(match_operator:SI 3 "commutative_operator"
  [(match_operand:SI 1 "general_operand" "g")
   (match_operand:SI 2 "general_operand" "g")])
@end smallexample

ここでベクトル @code{[@var{operands}@dots{}]} は、二つのパターンを
含んでいる。なぜなら、マッチすべき式は全て二つのオペランドを
含んでいるからである。

このパターンがマッチしたとき、交換可能な演算子の二つのオペランドは、
この insn のオペランド 1 とオペランド 2 として記録される。
(これは、二つの @code{match_operand} により行なわれる。)
この insn のオペランド 3 は、交換可能な式全体である。

@code{match_operator} のマシンモード @var{m} は、@code{match_operand} の
ものと同様に振る舞う。述語関数の二番目の引数として渡され、
その関数だけが、マッチすべき式がそのモードを「持っているか」どうかを
決定する責任がある。

insn を構築する際には、生成関数の第三引数が、作成されるべき式の
演算(すなわち式コード)を指定する。
この引数は一個の RTL 式であるべきで、その式コードが、
生成関数の引数 1 と 2 をオペランドとする新しい式にコピーされる。
引数 3 のサブ式は使われない。式コードだけが問題になる。

@code{match_operator} が、insn と照合されるパターンで使われているとき、
その @code{match_operator} のオペランド番号が、その insn の
実際のオペランド番号よりも大きいのが通常は最善である。
これによりレジスタ割当が改良される。レジスタ割当では、
insn のオペランド 1 と 2 を見て、レジスタの結び付けが可能かどうかを
見るからである。

@code{match_operator} に制約を指定する方法はない。
@code{match_operator} に対応する insn のオペランドは
どんな制約も持つことはない。全体として再ロードされることがないからである。
だが、その @var{operands} の一部が @code{match_operand} パターンに
より照合が行なわれると、その一部はそれ自身の制約があって良い。

@findex match_op_dup
@item (match_op_dup:@var{m} @var{n}[@var{operands}@dots{}])
@code{match_dup} に似ているが、オペランドではなく演算子に適用される。
insn を構築するときは、オペランド番号 @var{n} がここに代入される。
しかし、マッチングの際には @code{match_op_dup} の動作は異なる。
オペランド番号 @var{n} は認識テンプレートに先に現れる @code{match_operator}
により既に決まっており、見た目が同一の式にしかマッチしないということを
想定している。

@findex match_parallel
@item (match_parallel @var{n} @var{predicate} [@var{subpat}@dots{}])
このパターンは、可変数要素の @code{parallel} 式一個からなる insn の
プレースホルダーである。
この式は、insn パターンの最上位レベルにのみ現れるべきである。

insn を構築する際には、オペランド番号 @var{n} がこの点で置き換えられる。
insn との照合の際には、insn 本体が @code{parallel} 式であり、この
@code{parallel} 式が、
少なくとも @code{match_parallel} 中の @var{subpat} 式の insn ベクトルの
要素数と同じ要素数を持つのであれば、各 @var{subpat} が @code{parallel} の
対応する要素に一致し、@emph{かつ}、関数 @var{predicate} が insn の本体で
ある @code{parallel} に対してゼロでない値を返すなら、一致が起きる。
@code{match_parallel} に列挙されたもの以外の @code{parallel} の要素を
確認するのは述語の役割である。@refill

@code{match_parallel} の代表的な使い方は、ロードマルチプル式と
ストアマルチプル式にマッチさせることである。
例えば、

@smallexample
(define_insn ""
  [(match_parallel 0 "load_multiple_operation"
     [(set (match_operand:SI 1 "gpc_reg_operand" "=r")
           (match_operand:SI 2 "memory_operand" "m"))
      (use (reg:SI 179))
      (clobber (reg:SI 179))])]
  ""
  "loadm 0,0,%1,%2")
@end smallexample

この例は、@file{a29k.md} から取ったものである。
関数 @code{load_multiple_operations} は、@file{a29k.c} で
定義されており、@code{parallel} 中の後続の要素が、このパターンの
中の@code{set} と同じであるかどうかを検査している。
その要素が、後続のレジスタとメモリ位置を参照している場合を除く。

このパターンにマッチする insn は以下のような形式である。

@smallexample
(parallel
 [(set (reg:SI 20) (mem:SI (reg:SI 100)))
  (use (reg:SI 179))
  (clobber (reg:SI 179))
  (set (reg:SI 21)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 4))))
  (set (reg:SI 22)
       (mem:SI (plus:SI (reg:SI 100)
                        (const_int 8))))])
@end smallexample

@findex match_par_dup
@item (match_par_dup @var{n} [@var{subpat}@dots{}])
@code{match_op_dup} と同様だが、@code{match_operator} ではなく
@code{match_parallel} 用である。

@findex match_insn
@item (match_insn @var{predicate})
完全な insn にマッチする。他の @code{match_*} 認識器とは異なり、
@code{match_insn} はオペランド番号を取らない。

@code{match_insn} のマシンモード @var{m} は、@code{match_operand}
と同様の働きをする。述語関数の第二引数として渡され、
マッチした式のモードがそのモードになっているかどうかを決定する
責任はその関数にだけある。

@findex match_insn2
@item (match_insn2 @var{n} @var{predicate})
完全な insn にマッチする。

@code{match_insn2} のマシンモード @var{m} は、@code{match_operand}
と同様の働きをする。述語関数の第二引数として渡され、
マッチした式のモードがそのモードになっているかどうかを決定する
責任はその関数にだけある。

@findex address
@item (address (match_operand:@var{m} @var{n} "address_operand" ""))
この複雑な式は、「ロードアドレス」命令中のオペランド番号 @var{n} の
プレースホルダーである。
このオペランドは普通はメモリ位置を指定するが、実際のオペランド値
として使われるのはその位置のアドレスであり、その位置の内容ではない。

@code{address} 式は RTL コードには決して現れず、マシン記述でのみ
使われる。そして、オペランド制約の機能を使わないマシン記述でしか
使われることがない。
オペランド制約が使われる場合は、制約の文字 @samp{p} がこの目的を
果たす。

@var{m} は、@emph{アドレスとなるメモリ位置}のマシンモードであり、
アドレス自身のマシンモードではない。
このモードは、ある与えられたターゲットマシン上では常に同じなので
(@code{Pmode} で、これは普通は @code{SImode} である)、
それをわざわざ明記する意味はない。
つまり、@code{address} 式にはマシンモードは書かないのである。
いつの日か、異なる種類のオブジェクトのアドレスが異なって見えたり、
(PDP-10 のように)使い方が異なっていたりするマシンがサポートされたら、
異なる形式はおそらく異なるマシンモードを必要とし、そのモードを
@code{address} 式に書くことになるだろう。
@end table

@node Output Template
@section Output Templates and Operand Substitution
@cindex output templates
@cindex operand substitution

@dfn{出力テンプレート}は文字列であり、
ある命令パターンに対するアセンブラコードを
どのように出力するかを指定する。
テンプレートのほとんどの部分は、固定文字列であり、そのまま出力される。
文字 @samp{%} を使って、オペランドが代入される位置を指定する。
また、アセンブラに変種があるために異なる構文を必要とする場所を
特定するのにも使われる。

一番単純な場合では、@samp{%} の数字 @var{n} が続いた場合は、
文字列のその部分にオペランド @var{n} を出力することを示す。

@samp{%} の直後に英字1文字と数字1文字が続くと、オペランドの出力形式を
別のものに変えることを意味する。
英字としては四つの文字が標準で組み込み済の意味を持っており、
以下で解説する。マシン記述マクロ @code{PRINT_OPERAND} を
使って、標準ではない意味を持つ文字を追加定義することができる。

@samp{%c@var{digit}} を使うと、
通常は即値オペランドである事を示す構文を使わなくても、
定数値であるオペランドを置き換えることができる。

@samp{%n@var{digit}} は、表示前に定数値が否定を取られることを
除けば @samp{%c@var{digit}} に同じである。

@samp{%a@var{digit}} を使ってそれがあたかもメモリ参照であるかのように、
あるオペランドをアドレスとして扱われる実際のオペランドと置き換えることが
できる。これは、「ロードアドレス」命令を出力する際に役に立つ。
そういう命令のアセンブラ構文では、オペランドをあたかもメモリ参照で
あるかのように書くことを要求することが多いからである。

@samp{%l@var{digit}} は、ジャンプ命令に @code{label_ref} を代入するのに
使われる。

@samp{%=} は、各命令に対し、コンパイルの全過程で一意的な番号を出力する。
これは、複数のアセンブラ命令を生成する一個のテンプレート中で
二回以上参照されるローカルラベルを作るときに便利である。

@samp{%} の後ろに区切り文字が続くと、オペランドを使わない置き換えである
ことを指定する。標準的な使い方は一個だけである。
@samp{%%} とするとアセンブラコードに @samp{%} を出力する。
その他の非標準的な場合は、マクロ @code{PRINT_OPERAND} で定義することが
できる。
また、どの区切り文字が有効かをマクロ @code{PRINT_OPERAND_PUNCT_VALID_P} で
定義しなければならない。

@cindex \
@cindex backslash
テンプレートは複数のアセンブラ命令を生成して良い。
その場合には、各命令を @samp{\;} で区切って書く。

@cindex matching operands
RTL にオペランドが二つあり、制約によりその二つが互いに一致することが
要求されている場合には、出力テンプレートでは、数字の小さい方のオペランド
しか参照してはならない。一致したオペランドはいつも同じではなく、
コンパイラの残りの部分で、数字の小さい方のオペランドに出力する
適切な RTL 式を置くように調整する。

@samp{%} の後ろに標準でない英文字や区切り文字を置く使い方の一つに、
同一のマシンに対する異なるアセンブラ言語を区別することがある。
例えば、68000 には Motorola 形式と MIT 形式がある。
Motorola 形式では、ほとんどのオペコード名にピリオドを使うのに対し、
MIT 形式では使わない。例えば、MIT 形式で @samp{movel} と書くオペコードは、
Motorola 形式では @samp{move.l} となる。
両方の出力形式に対して同じパターンファイルを使用するが、
Motorola 形式でピリオドが必要な場所には文字シーケンス @samp{%.} を
使うようにする。
マクロ @code{PRINT_OPERAND} は、Motorola 形式では、ピリオドを
出力するシーケンスを定義し、MIT 形式向けには何もしないマクロとして
定義する。

@cindex @code{#} in template
特別な場合として、テンプレートが一個の文字 @code{#} から成っていると
コンパイラに対し、最初に insn を分割し、次にその結果の命令を別々に
出力することを指示する。
これは、出力テンプレートの冗長性を消去するのに役立つ。
複数のアセンブラ命令を出力する必要がある @code{define_insn} があり、
マッチする @code{define_split} が既に定義されているなら、
出力テンプレートとして単に @code{#} を使うことができ、
複数のアセンブラ命令を出力する出力テンプレートを書く必要はない。

マクロ @code{ASSEMBLER_DIALECT} が定義されていれば、
テンプレートで @samp{@{option0|option1|option2@}}という形式の
構文を使うことができる。
アセンブラ言語の文法の複数の方言を記述する。
@xref{Instruction Output}.

@c Most of this node appears by itself (in a different place) even
@c when the INTERNALS flag is clear.  Passages that require the internals
@c manual's context are conditionalized to appear only in the internals manual.
@ifset INTERNALS
@node Constraints
@section Operand Constraints
@cindex operand constraints
@cindex constraints

ある命令パターンにおいて、@code{match_operand} のそれぞれに、
許されるオペランドの型についての制約を指定することができる。

@end ifset
@ifclear INTERNALS
@node Constraints
@section Constraints for @code{asm} Operands
@cindex operand constraints, @code{asm}
@cindex constraints, @code{asm}
@cindex @code{asm} constraints

以下に、@code{asm} オペランドでどんな制約文字が使用可能かの詳細を
示す。

@code{asm} operands.
@end ifclear
制約により、次のような指定が可能である。
あるオペランドがレジスタに置かれているかどうか、置かれているなら
どの種類のレジスタか。
オペランドとしてメモリ参照が可能かどうか、可能ならどの種類の
アドレスか。オペランドとして即値が可能かどうか、可能ならどういう
値が可能か。
制約は二つのオペランドが一致することを要求することもできる。

@ifset INTERNALS
@menu
* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Class Preferences::   Constraints guide which hard register to put things in.
* Modifiers::           More precise control over effects of constraints.
* Machine Constraints:: Existing constraints for some particular machines.
* Disable Insn Alternatives:: Disable insn alternatives using attributes.
* Define Constraints::  How to define machine-specific constraints.
* C Constraint Interface:: How to test constraints from C code.
@end menu
@end ifset

@ifclear INTERNALS
@menu
* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Modifiers::           More precise control over effects of constraints.
* Machine Constraints:: Special constraints for some particular machines.
@end menu
@end ifclear

@node Simple Constraints
@subsection Simple Constraints
@cindex simple constraints

最も単純な種類の制約は全部が英文字からなる文字列である。
その一つ一つの文字が、許されるオペランドの一つの種類を記述する。
以下に許される英文字を示す。

@table @asis
@cindex @samp{m} in constraint
@cindex memory references in constraints
@item @samp{m}
メモリオペランドを指定する。その機種が一般にサポートしている
アドレスならどれでも良い。

@cindex offsettable address
@cindex @samp{o} in constraint
@item @samp{o}
メモリオペランドを指定する。ただし、許されるアドレスは「オフセット指定可能な」
アドレスだけである。
つまり、そのアドレスに小さな整数(実際には、マシンモードにより決まる、
バイト数で表したオペランドの幅に収まる数)を加算した結果も
また有効なメモリアドレスとなる。

@cindex autoincrement/decrement addressing
例えば、アドレスが定数であれば、それはオフセット指定可能である。
一個のレジスタと一個の定数(ちょっと大きめの定数もその機種で
サポートされている範囲のアドレスのオフセットになっている限り)
の和もオフセット指定可能である。
しかし、自動インクリメント、自動デクリメントのアドレスは
オフセット指定可能でない。
もっと複雑な間接／インデックス修飾アドレスがオフセット指定可能か
どうかは、その機種がサポートする他のアドレッシングモードに
依存する。

別のオペランドにマッチ可能な出力オペランドにおいては、
制約文字 @samp{o}は、@samp{<}(ターゲット機種に事前デクリメントアドレッシング
があれば)と@samp{>}(ターゲット機種に事前インクリメントアドレッシングが
あれば)の両方を伴う場合にのみ有効である。

@cindex @samp{V} in constraint
@item @samp{V}
オフセット指定可能でないメモリオペランドを指定する。
言い換えると、制約 @samp{m} には収まるが、@samp{o} には収まらないものは
何でもここに入る。

@cindex @samp{<} in constraint
@item @samp{<}
自動デクリメントのアドレスのメモリオペランドを指定する。
プリデクリメントでもポストデクリメントのどちらでも良い。

@cindex @samp{>} in constraint
@item @samp{>}
自動インクリメントのアドレスのメモリオペランドを指定する。
プリインクリメントでもポストインクリメントのどちらでも良い。

@cindex @samp{r} in constraint
@cindex registers in constraints
@item @samp{r}
レジスタオペランドが許される。ただし、レジスタは汎用レジスタである。

@cindex @samp{d} in constraint
@item @samp{d}, @samp{a}, @samp{f}, @dots{}
他の文字は、機種依存の方法で、特定のレジスタクラスを表すように
定義することができる。
68000/68020 では、@samp{d}、@samp{a}、@samp{f} が
定義されており、それぞれ、データレジスタ、アドレスレジスタ、
浮動小数点レジスタを表す。

@cindex constants in constraints
@cindex @samp{i} in constraint
@item @samp{i}
整数の即値オペランド(定数値のもの)が許される。
これには、値がアセンブル時にならないとわからないシンボリックな定数も
含まれる。

@cindex @samp{n} in constraint
@item @samp{n}
既知の数値を持つ整数即値のオペランドが許される。
多くのシステムでは、語長よりも小さいオペランドにはアセンブル時の定数は
使えない。そのようなオペランドの制約には @samp{i} ではなく @samp{n} を
使うべきである。

@cindex @samp{I} in constraint
@item @samp{I}, @samp{J}, @samp{K}, @dots{} @samp{P}
他の、@samp{I} と @samp{P} の間にある文字は、機種依存の方法で、
指定された範囲の明示された整数値を持つ整数の即値オペランドを許すように
定義することができる。
例えば、68000 では、@samp{I} は、1 〜 8 の範囲の値を表すと
定義されている。これは、シフト命令で許されているシフト幅の範囲である。

@cindex @samp{E} in constraint
@item @samp{E}
浮動小数点の即値オペランド(式コードは @code{const_double})が
許される。ただし、ターゲットの浮動小数点形式がホストマシン(コンパイラが
動作するマシン)のものと同じ場合に限られる。

@cindex @samp{F} in constraint
@item @samp{F}
浮動小数点の即値オペランド(式コードは @code{const_double})が
許される。

@cindex @samp{G} in constraint
@cindex @samp{H} in constraint
@item @samp{G}, @samp{H}
@samp{G} と @samp{H} は、機種依存の方法で、特定の範囲の値の
浮動小数点即値オペランドを許すように定義することができる。

@cindex @samp{s} in constraint
@item @samp{s}
値が明示的な整数ではない、整数即値オペランドが許される。

これは奇異に聞こえるかもしれない。
もし、ある insn がコンパイル時には決まっていない値をもつ定数オペランドを
許すなら、当然、どんな既知の値でも許さなければならないはずだ。
どうして、@samp{i} の代わりに @samp{s} を使うのか?
その方が、良いコードが生成されることがあるからなのだ。

例えば、68000 の全ワードの命令では即値オペランドを使うことができる。
しかし、即値の範囲が -128 と 127 の間にあるなら、その値をレジスタに
ロードして、そのレジスタを使った方が良いコードになるのである。
これは、レジスタへのロードが @samp{moveq} 命令で行なえるからである。
我々はこれが起きるように、文字 @samp{K} が「-128 と 127 の範囲の
外側の整数」という意味を持つように定義し、オペランドの制約に
@samp{Ks} と指定している。

@cindex @samp{g} in constraint
@item @samp{g}
任意のレジスタ、メモリ、整数の即値のオペランドが許される。
ただし、汎用レジスタでないレジスタは除く。

@cindex @samp{X} in constraint
@item @samp{X}
@ifset INTERNALS
どんなオペランドでも、たとえ @code{general_operand} を満たさないもので
あっても許される。
これは、通常、特定の選択肢が実際にはスクラッチレジスタを必要としないときに、
@code{match_scratch} の制約で使われる。
@end ifset
@ifclear INTERNALS
どんなオペランドでも許される。
@end ifclear

@cindex @samp{0} in constraint
@cindex digits in constraint
@item @samp{0}, @samp{1}, @samp{2}, @dots{} @samp{9}
指定したオペランド番号にマッチするオペランドが許される。
数字を同じ選択肢の中で英文字と組み合わせて使うなら、数字は
最後に書くこと。

@cindex matching constraint
@cindex constraint, matching
これは、@dfn{照合制約}と呼ばれており、それが実際に意味することは、
アセンブラには二つの役割を果たす一個のオペランドしかないということである。
@ifset INTERNALS
この二つの役割は RTL insn で別のものと考えられている。
例えば、add insn は RTL には、二つの入力オペランドと一つのオペランドを
持っているが、多くの CISC
@end ifset
@ifclear INTERNALS
@code{asm} は二つの役割を区別する。例えば、add 命令は二つの
入力オペランドと出力オペランドを使うが、多くの CISC
@end ifclear
マシンでは、add 命令にはオペランドが二つしかなく、その一つは
入力と出力兼用オペランドである。

@smallexample
addl #35,r12
@end smallexample

照合制約は以下の状況で使われる。
もっと正確に言えば、マッチする二つのオペランドのうち、一つは入力専用で、
もう一つは出力専用でなければならない。さらに、数字は制約で使われている
オペランド数より小さな数でなければならない。

@ifset INTERNALS
ある特定の場合にマッチするオペランドは普通それらが見かけが同じである
RTL 式になっているということを意味する。しかし、2,3の特別な場合には
特定の種類の違いは許される。例えば、入力オペランドとしての @code{*x} は
出力オペランドとしての @code{*x++} にマッチする。
このような場合に正しい結果を得るには、出力テンプレートでは
オペランドを出力するさいに常に出力オペランドの番号を使う必要がある。
@end ifset

@cindex load address instruction
@cindex push address instruction
@cindex address constraints
@cindex @samp{p} in constraint
@item @samp{p}
有効なメモリアドレスであるオペランドが許される。
これは、「ロード・アドレス」命令と「プッシュ・アドレス」命令向けである。

@findex address_operand
制約の中の @samp{p} には、@code{match_operand} の述語のように、
@code{address_operand} が付随しなければならない。
この述語は、@code{match_operand} で指定されたモードを、
アドレスが有効であるメモリ参照のモードとして解釈する。

@cindex extensible constraints
@cindex @samp{Q}, in constraint
@item @samp{Q}, @samp{R}, @samp{S}, @dots{} @samp{U}
@samp{Q} から @samp{U} の範囲の文字は、機種依存の形式で
定義して、任意のオペランド型を表すのに使える。
@ifset INTERNALS
マシン記述マクロ @code{EXTRA_CONSTRAINT} には、一番目の引数として
そのオペランドが、二番目の引数として制約文字が渡される。

これの典型的な使い方は、他の insn のオペランドに影響する
メモリ参照の一定の型を区別することである。

これらの制約文字は、レジスタ選択(@code{reg})を受け付けるようには
定義しないこと。再ロードパスが想定していないことであり、正しく扱え
ないだろう。
@end ifset
@end table

@ifset INTERNALS
アセンブラコードを正しいものにするために、各オペランドはその制約を
満たさなければならない。
しかし、制約を満たさなくても、そのパターンがある insn に適用されるのを
妨げるものではない。
代わりに、コンパイラがコードを修正して、制約が満足されるようにする。
通常これはオペランドをレジスタにコピーすることにより行なわれる。

このため、以下の二つの命令パターンを比べてみよう。

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_dup 0)
                 (match_operand:SI 1 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@noindent
これにはオペランドが二つあり、そのうちの一つは二箇所に現れなければならない。
そして、

@smallexample
(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r")
        (plus:SI (match_operand:SI 1 "general_operand" "0")
                 (match_operand:SI 2 "general_operand" "r")))]
  ""
  "@dots{}")
@end smallexample

@noindent
こちらは、オペランドが三つあり、そのうちの二つは制約により等しいことが
要求される。以下の形の insn を考えてみると、

@smallexample
(insn @var{n} @var{prev} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 6) (reg:SI 109)))
  @dots{})
@end smallexample

@noindent
最初のパターンは全く適合しない。この insn には、正しい場所に二つの
同じ部分式がないからである。
最初のパターンは、「加算命令には見えないので、他のパターンを試してね。」
と言うだろう。
一方、二番目のパターンは、「うん、これは加算命令だ。だけどちょっと
間違ってるな。」と言うだろう。
コンパイラの再ロードパスに対して insn を追加で生成させ、制約が
満たされるようにすることを指示する。
その結果は以下のようになるだろう。

@smallexample
(insn @var{n2} @var{prev} @var{n}
  (set (reg:SI 3) (reg:SI 6))
  @dots{})

(insn @var{n} @var{n2} @var{next}
  (set (reg:SI 3)
       (plus:SI (reg:SI 3) (reg:SI 109)))
  @dots{})
@end smallexample

各パターンの各オペランドが、それぞれのオペランド向けに存在
しうる、どんな RTL 式も扱えるような制約を持つことを保証するのは
読者の責任である。
(複数の選択肢が使われている場合は、各パターンは、オペランド式の
可能な組合せ毎に、その組合せを扱うことが出来る選択肢を少なくとも
一つ持たなければならない。)
その制約は可能なオペランドをなんでも許す必要はない。なんでも許すのであれば
それは制約ではない。だが、その制約は少なくとも、それに適するような
何らかの可能なオペランドを再ロードする方法を指し示す必要がある。

@itemize @bullet
@item
もし制約が、述語が許すオペランドなら何でも受け付けるなら何の問題も
ない。このオペランドは再ロードを全く必要としない。

例えば、レジスタ以外のあらゆるものを許す制約を持つオペランドは、
その述語がレジスタを拒絶するなら安全である。

定数値だけを受け付ける述語を持つオペランドは、その制約に文字 @samp{i} が
入っていれば安全である。
任意の可能な定数値を受け付けたなら、@samp{i} がするであろう以上のことは
なにもしない。もし述語がもっと選択的なら、制約もまたもっと
選択的にして良い。

@item
任意のオペランド式は、レジスタにコピーすることにより再ロード可能である。
そのため、オペランドの制約がどの種類かのレジスタを許していれば、
間違いなく安全である。全てのクラスのレジスタを許す必要はない。
コンパイラは、命令を正しいものにするために、
あるレジスタを別の適切なクラスのレジスタにコピーする方法を知っている。

@cindex nonoffsettable memory reference
@cindex memory reference, nonoffsettable
@item
オフセット可能でないメモリ参照は、そのアドレスをレジスタにコピーすることで
再ロード可能である。そのため、制約が文字 @samp{o} を使っていれば、
全てのメモリ参照の面倒を見てくれる。

@item
定数オペランドは、それを事前に初期化されたデータとして保持するために、
メモリスペースを獲得することで、再ロード可能である。
そうすると、定数の代わりにメモリ参照が使える。
そのため、制約が文字 @samp{o} や @samp{m} を使っていれば、
定数オペランドは問題ではない。

@item
制約が一個の定数とある insn で使われている一個の疑似レジスタを
許しているものとする。
このとき、その疑似レジスタがハードレジスタに割り当てられておらず、
定数に等価であるなら、そのレジスタは定数に置き換えられる。
述語が一個の定数と何らかの理由により再認識される insn を認めていなければ、
GNU CC が異常終了する。
すなわち、述語は、制約により許されるオブジェクトはどんなものであれ
常に認識しなければならない。

@end itemize

オペランドの述語はレジスタを認識できるが、制約の方はレジスタを許さない場合は
コンパイラが落ちる可能性がある。
このオペランドがレジスタになったとき、再ロードパスがうまくいかなくなる。
レジスタを一時的にメモリにコピーする方法が分からないためである。

述語が単項演算子を受け付けるなら、制約はそのオペランドに適用される。
例えば、ISA レベル 3 の MIPS プロセッサは、@code{SImode} の二つの
レジスタを加算して、@code{DImode} の結果を生成する命令をサポートしているが、
これはレジスタが正しく符号拡張される場合だけである。
入力オペランドに対するこの述語は、ある @code{SImode} のレジスタの
@code{sign_extend} を受け付ける。@code{sign_extend} の
オペランドとして必要なレジスタのタイプを示すように制約を書くこと。
@end ifset

@node Multi-Alternative
@subsection Multiple Alternative Constraints
@cindex multiple alternative constraints

Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can combine
register or an immediate value into memory, or it can combine any kind of
operand into a register; but it cannot combine one memory location into
another.

These constraints are represented as multiple alternatives.  An alternative
can be described by a series of letters for each operand.  The overall
constraint for an operand is made from the letters for this operand
from the first alternative, a comma, the letters for this operand from
the second alternative, a comma, and so on until the last alternative.
@ifset INTERNALS
Here is how it is done for fullword logical-or on the 68000:

@smallexample
(define_insn "iorsi3"
  [(set (match_operand:SI 0 "general_operand" "=m,d")
        (ior:SI (match_operand:SI 1 "general_operand" "%0,0")
                (match_operand:SI 2 "general_operand" "dKs,dmKs")))]
  @dots{})
@end smallexample

The first alternative has @samp{m} (memory) for operand 0, @samp{0} for
operand 1 (meaning it must match operand 0), and @samp{dKs} for operand
2.  The second alternative has @samp{d} (data register) for operand 0,
@samp{0} for operand 1, and @samp{dmKs} for operand 2.  The @samp{=} and
@samp{%} in the constraints apply to all the alternatives; their
meaning is explained in the next section (@pxref{Class Preferences}).
@end ifset

@c FIXME Is this ? and ! stuff of use in asm()?  If not, hide unless INTERNAL
If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many instructions
must be added to copy the operands so that that alternative applies.
The alternative requiring the least copying is chosen.  If two alternatives
need the same amount of copying, the one that comes first is chosen.
These choices can be altered with the @samp{?} and @samp{!} characters:

@table @code
@cindex @samp{?} in constraint
@cindex question mark
@item ?
Disparage slightly the alternative that the @samp{?} appears in,
as a choice when no alternative applies exactly.  The compiler regards
this alternative as one unit more costly for each @samp{?} that appears
in it.

@cindex @samp{!} in constraint
@cindex exclamation point
@item !
Disparage severely the alternative that the @samp{!} appears in.
This alternative can still be used if it fits without reloading,
but if reloading is needed, some other alternative will be used.

@cindex @samp{^} in constraint
@cindex caret
@item ^
This constraint is analogous to @samp{?} but it disparages slightly
the alternative only if the operand with the @samp{^} needs a reload.

@cindex @samp{$} in constraint
@cindex dollar sign
@item $
This constraint is analogous to @samp{!} but it disparages severely
the alternative only if the operand with the @samp{$} needs a reload.
@end table

@ifset INTERNALS
When an insn pattern has multiple alternatives in its constraints, often
the appearance of the assembler code is determined mostly by which
alternative was matched.  When this is so, the C code for writing the
assembler code can use the variable @code{which_alternative}, which is
the ordinal number of the alternative that was actually satisfied (0 for
the first, 1 for the second alternative, etc.).  @xref{Output Statement}.
@end ifset

@ifset INTERNALS
@node Class Preferences
@subsection Register Class Preferences
@cindex class preference constraints
@cindex register class preference constraints

@cindex voting between constraint alternatives
The operand constraints have another function: they enable the compiler
to decide which kind of hardware register a pseudo register is best
allocated to.  The compiler examines the constraints that apply to the
insns that use the pseudo register, looking for the machine-dependent
letters such as @samp{d} and @samp{a} that specify classes of registers.
The pseudo register is put in whichever class gets the most ``votes''.
The constraint letters @samp{g} and @samp{r} also vote: they vote in
favor of a general register.  The machine description says which registers
are considered general.

Of course, on some machines all registers are equivalent, and no register
classes are defined.  Then none of this complexity is relevant.
@end ifset

@node Modifiers
@subsection Constraint Modifier Characters
@cindex modifiers in constraints
@cindex constraint modifier characters

@c prevent bad page break with this line
Here are constraint modifier characters.

@table @samp
@cindex @samp{=} in constraint
@item =
Means that this operand is written to by this instruction:
the previous value is discarded and replaced by new data.

@cindex @samp{+} in constraint
@item +
Means that this operand is both read and written by the instruction.

When the compiler fixes up the operands to satisfy the constraints,
it needs to know which operands are read by the instruction and
which are written by it.  @samp{=} identifies an operand which is only
written; @samp{+} identifies an operand that is both read and written; all
other operands are assumed to only be read.

If you specify @samp{=} or @samp{+} in a constraint, you put it in the
first character of the constraint string.

@cindex @samp{&} in constraint
@cindex earlyclobber operand
@item &
Means (in a particular alternative) that this operand is an
@dfn{earlyclobber} operand, which is written before the instruction is
finished using the input operands.  Therefore, this operand may not lie
in a register that is read by the instruction or as part of any memory
address.

@samp{&} applies only to the alternative in which it is written.  In
constraints with multiple alternatives, sometimes one alternative
requires @samp{&} while others do not.  See, for example, the
@samp{movdf} insn of the 68000.

A operand which is read by the instruction can be tied to an earlyclobber
operand if its only use as an input occurs before the early result is
written.  Adding alternatives of this form often allows GCC to produce
better code when only some of the read operands can be affected by the
earlyclobber. See, for example, the @samp{mulsi3} insn of the ARM@.

Furthermore, if the @dfn{earlyclobber} operand is also a read/write
operand, then that operand is written only after it's used.

@samp{&} does not obviate the need to write @samp{=} or @samp{+}.  As
@dfn{earlyclobber} operands are always written, a read-only
@dfn{earlyclobber} operand is ill-formed and will be rejected by the
compiler.

@cindex @samp{%} in constraint
@item %
Declares the instruction to be commutative for this operand and the
following operand.  This means that the compiler may interchange the
two operands if that is the cheapest way to make all operands fit the
constraints.  @samp{%} applies to all alternatives and must appear as
the first character in the constraint.  Only read-only operands can use
@samp{%}.

@ifset INTERNALS
This is often used in patterns for addition instructions
that really have only two operands: the result must go in one of the
arguments.  Here for example, is how the 68000 halfword-add
instruction is defined:

@smallexample
(define_insn "addhi3"
  [(set (match_operand:HI 0 "general_operand" "=m,r")
     (plus:HI (match_operand:HI 1 "general_operand" "%0,0")
              (match_operand:HI 2 "general_operand" "di,g")))]
  @dots{})
@end smallexample
@end ifset
GCC can only handle one commutative pair in an asm; if you use more,
the compiler may fail.  Note that you need not use the modifier if
the two alternatives are strictly identical; this would only waste
time in the reload pass.  The modifier is not operational after
register allocation, so the result of @code{define_peephole2}
and @code{define_split}s performed after reload cannot rely on
@samp{%} to make the intended insn match.

@cindex @samp{#} in constraint
@item #
Says that all following characters, up to the next comma, are to be
ignored as a constraint.  They are significant only for choosing
register preferences.

@cindex @samp{*} in constraint
@item *
Says that the following character should be ignored when choosing
register preferences.  @samp{*} has no effect on the meaning of the
constraint as a constraint, and no effect on reloading.  For LRA
@samp{*} additionally disparages slightly the alternative if the
following character matches the operand.

@ifset INTERNALS
Here is an example: the 68000 has an instruction to sign-extend a
halfword in a data register, and can also sign-extend a value by
copying it into an address register.  While either kind of register is
acceptable, the constraints on an address-register destination are
less strict, so it is best if register allocation makes an address
register its goal.  Therefore, @samp{*} is used so that the @samp{d}
constraint letter (for data register) is ignored when computing
register preferences.

@smallexample
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "=*d,a")
        (sign_extend:SI
         (match_operand:HI 1 "general_operand" "0,g")))]
  @dots{})
@end smallexample
@end ifset
@end table

@node Machine Constraints
@subsection Constraints for Particular Machines
@cindex machine specific constraints
@cindex constraints, machine specific

@code{asm} の引数には、可能な限り、汎用の制約文字を使ったほうが良い。
その方が読む人に意味が伝わりやすくなるからだ。
汎用の制約文字では駄目な場合は、色々なアーキテクチャで同じような
意味を持つ制約文字を使うようにする。最も共通して良く使われるのは、
@samp{m} と @samp{r} である。それぞれ、メモリと汎用レジスタを表す。
@pxref{Simple Constraints}
それに、@samp{I} が、最も一般的な即値定数の形式を表す文字として使われる。

マシンアーキテクチャ毎に、@file{config/@var{machine}.h} というファイルで、
固有の制約を追加定義している。これらの制約は、@code{asm} 文だけでなく、
コンパイラ自身の命令の生成に使われる。
このため、制約のうちいくつかは、@code{asm} 文に使うにはあまり意味の
ないものがある。
制約は以下のマクロ群によって定義される。

@table @code
@item REG_CLASS_FROM_LETTER
レジスタクラスの制約(普通は小文字だけである)。

@item CONST_OK_FOR_LETTER_P
即値定数の制約。ワード長、あるいはそれより短い精度の、非浮動小数点定数
向けである。通常、大文字である。

@item CONST_DOUBLE_OK_FOR_LETTER_P
即値定数の制約。全ての浮動小数点定数とワード長を越える精度の定数
向けである。通常、大文字である。

@item EXTRA_CONSTRAINT
レジスタまたはメモリの特別な場合。
このマクロは必須ではなく、少数のマシンでのみ定義されている。
@end table

本コンパイラのソースの、読者のマシン向けのマクロ定義を調べるのが、
正しい制約を使っているかどうかを確認するのに一番良い方法である。
とはいうものの、以下に幾つかの特定の機種で使える機種依存の制約を
要約しておく。

@c Please keep this table alphabetized by target!
@table @emph

@item ARM family---@file{arm.h}
@table @code

@item f
浮動小数点レジスタ

@item F
浮動小数点定数 0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 10.0 のどれか一つ

@item G
符号反転したときに制約 @samp{F} を満たす浮動小数点定数

@item z
FPR-GPR 間移動用の @samp{FPMEM} スタックメモリ

@item I
データ処理命令の即値オペランドとして有効な整数。
すなわち、0 から 255 の間の整数を 2 の倍数分回転したものである。

@item J
-4095 〜 4095 の範囲の整数

@item K
ビット反転(1の補数)したときに制約 @samp{I} を満たす整数

@item L
符号反転(2の補数)したときに制約 @samp{I} を満たす整数

@item M
0 〜 32 の範囲の整数

@item Q
正確なアドレスが一個のレジスタにある場合のメモリ参照
(@code{asm} 文の場合には、@samp{m} の方が良い)。

@item R
定数領域に置かれるデータ

@item S
現在ファイルのテキストセグメント中のシンボル
@end table

@item AMD 29000 family---@file{a29k.h}
@table @code
@item l
ローカルレジスタ 0

@item b
バイトポインタ(@samp{BP})レジスタ

@item q
@samp{Q} レジスタ

@item h
特殊目的のレジスタ

@item A
第一アキュムレータレジスタ

@item a
他のアキュムレータレジスタ

@item f
浮動小数点レジスタ

@item I
0 より大きく、0x100 より小さい定数

@item J
0 より大きく、0x1000 より小さい定数

@item K
上位 24 ビットがオン(1)の定数

@item L
上位 8 ビットがオン(1) の 16 ビット定数

@item M
上位 16 ビットがオン(1) の 32 ビット定数

@item N
8ビットに収まる 32ビットの負の定数。

@item O
定数 0x80000000か、あるいは、29050 の場合は、下位16ビットが 0 である
任意の32ビット定数。

@item P
8ビットに収まる 16ビットの負の定数。

@item G
@itemx H
浮動小数点定数(@code{asm} 文では、代わりに機種独立の @samp{E} か @samp{F}
を使うこと。)
@end table

@item MIPS---@file{mips.h}
@table @code
@item d
汎用整数レジスタ

@item f
浮動小数点レジスタ(もしあれば)

@item h
@samp{Hi} レジスタ

@item l
@samp{Lo} レジスタ

@item x
@samp{Hi} または @samp{Lo} レジスタ

@item y
汎用整数レジスタ

@item z
浮動小数点ステータスレジスタ

@item I
符号付き 16 ビット定数(算術演算命令向け)

@item J
ゼロ

@item K
ゼロ拡張された 16 ビット定数(論理命令向け)

@item L
下位16ビットがゼロの定数(@code{lui} でロード可能)

@item M
32ビット定数のうち、ロードするのに 2 命令必要なもの(@samp{I} でも
@samp{K} でも @samp{L} でもない定数)

@item N
負の16ビット定数

@item O
二の冪乗

@item P
正の 16 ビット定数

@item G
浮動小数点のゼロ

@item Q
一個以上の命令でロード可能なメモリ参照
(@code{asm} 文の場合は、@samp{m} の方が良い)。

@item R
一個の命令でロード可能なメモリ参照
(@code{asm} 文の場合は、@samp{m} の方が良い)。

@item S
外部 OSF/rose PIC 形式でのメモリ参照
(@code{asm} 文の場合は、@samp{m} の方が良い)。
@end table

@item Motorola 680x0---@file{m68k.h}
@table @code
@item a
アドレスレジスタ

@item d
データレジスタ

@item f
利用可能なら、68881 の浮動小数点レジスタ

@item x
利用可能なら、Sun の FPA の浮動小数点レジスタ。

@item y
利用可能なら、Sun の FPA の浮動小数点レジスタの最初の 16 個。

@item I
1 〜 8 までの整数

@item J
16 ビットの符号付きの数

@item K
絶対値が 0x80 より大きい符号付き整数。

@item L
-8 〜 -1 の整数

@item M

@item G
68881 の定数ではない浮動小数点定数。

@item H
Sun の FPA で使用可能な浮動小数点定数。
@end table

@item IBM RS6000---@file{rs6000.h}
@table @code
@item b
アドレスベースレジスタ

@item f
浮動小数点レジスタ

@item h
@samp{MQ}, @samp{CTR},  @samp{LINK} レジスタ

@item q
@samp{MQ} レジスタ

@item c
@samp{CTR} レジスタ

@item l
@samp{LINK} レジスタ

@item x
@samp{CR} レジスタ(条件レジスタ)の 0 番

@item y
@samp{CR} レジスタ(条件レジスタ)

@item z
FPR-GPR 間転送用の @samp{FPMEM} スタックメモリ

@item I
符号付きの 16 ビット定数

@item J
下位16ビットが 0 の定数

@item K
上位の 16 ビットが 0 の定数

@item L
マスク用オペランドとして適切な定数

@item M
31 より大きい定数

@item N
2 の正確な冪乗

@item O
ゼロ

@item P
符号反転したものが符号付き 16 ビット定数になる定数

@item G
一ワードにつき一回の命令でレジスタにロード可能な浮動小数点定数。

@item Q
あるレジスタからのオフセットであるメモリオペランド
(@code{asm} 文の場合は、@samp{m} の方が良い)。

@item R
AIX の TOC エントリ

@item S
64ビットのマスク・オペランドとして適した定数。

@item U
System V Release 4 の小データ領域の参照
@end table

@need 1000
@item SPARC---@file{sparc.h}
@table @code
@item f
32 ビットまたは 64 ビットの値を保持できる浮動小数点レジスタ。

@item e
64 ビットまたは 128 ビットの値を保持できる浮動小数点レジスタ。

@item I
13ビットの符号付き定数

@item J
ゼロ

@item K
下位12ビットが 0 の 32ビット定数(@code{sethi} 命令でロード可能な
定数)

@item G
浮動小数点数のゼロ。

@item H
13 ビットの符号付き定数で、32 ビットまたは 64 ビットに符号拡張される。

@item Q
1命令でロード可能なメモリ参照(@samp{m} の方が、@code{asm} 文には
もっと適している。)

@item S
定数、またはメモリアドレス

@item T
8バイト境界に整合されたメモリアドレス

@item U
偶数レジスタ
@end table

@item Intel 386---@file{i386.h}
@table @code
@item q
@samp{a}、@code{b}、@code{c}、@code{d} レジスタ

@item A
@samp{a}、@code{d} レジスタ(64ビット int 向け)

@item f
浮動小数点レジスタ

@item t
第一(スタックの一番上の)浮動小数点レジスタ

@item u
第二浮動小数点レジスタ

@item a
@samp{a} レジスタ

@item b
@samp{b} レジスタ

@item c
@samp{c} レジスタ

@item d
@samp{d} レジスタ

@item D
@samp{di} レジスタ

@item S
@samp{si} レジスタ

@item I
0〜31 の定数(32ビットのシフト用)

@item J
0〜63 の定数(64ビットのシフト用)

@item K
@samp{0xff}

@item L
@samp{0xffff}

@item M
0、1、2、3(@code{lea} 命令のシフト数である)

@item N
0 から 255 の範囲の定数(@code{out} 命令用)

@item G
80387 標準の浮動小数点定数
@end table

@item Intel 960---@file{i960.h}
@table @code
@item f
浮動小数点レジスタ(@code{fp0} から @code{fp3})

@item l
ローカルレジスタ(@code{r0} から @code{r15})

@item b
グローバルレジスタ(@code{g0} から @code{g15})

@item d
任意のローカルまたはグローバルレジスタ

@item I
0 から 31 の整数

@item J
0

@item K
-31 から 0 の整数

@item G
浮動小数点の 0

@item H
浮動小数点の 1
@end table

@end table

@node Standard Names
@section Standard Pattern Names For Generation
@cindex standard pattern names
@cindex pattern names
@cindex names, pattern

Here is a table of the instruction names that are meaningful in the RTL
generation pass of the compiler.  Giving one of these names to an
instruction pattern tells the RTL generation pass that it can use the
pattern to accomplish a certain task.

@table @asis
@cindex @code{mov@var{m}} instruction pattern
@item @samp{mov@var{m}}
Here @var{m} stands for a two-letter machine mode name, in lowercase.
This instruction pattern moves data with that machine mode from operand
1 to operand 0.  For example, @samp{movsi} moves full-word data.

If operand 0 is a @code{subreg} with mode @var{m} of a register whose
own mode is wider than @var{m}, the effect of this instruction is
to store the specified value in the part of the register that corresponds
to mode @var{m}.  Bits outside of @var{m}, but which are within the
same target word as the @code{subreg} are undefined.  Bits which are
outside the target word are left unchanged.

This class of patterns is special in several ways.  First of all, each
of these names up to and including full word size @emph{must} be defined,
because there is no other way to copy a datum from one place to another.
If there are patterns accepting operands in larger modes,
@samp{mov@var{m}} must be defined for integer modes of those sizes.

Second, these patterns are not used solely in the RTL generation pass.
Even the reload pass can generate move insns to copy values from stack
slots into temporary registers.  When it does so, one of the operands is
a hard register and the other is an operand that can need to be reloaded
into a register.

@findex force_reg
Therefore, when given such a pair of operands, the pattern must generate
RTL which needs no reloading and needs no temporary registers---no
registers other than the operands.  For example, if you support the
pattern with a @code{define_expand}, then in such a case the
@code{define_expand} mustn't call @code{force_reg} or any other such
function which might generate new pseudo registers.

This requirement exists even for subword modes on a RISC machine where
fetching those modes from memory normally requires several insns and
some temporary registers.

@findex change_address
During reload a memory reference with an invalid address may be passed
as an operand.  Such an address will be replaced with a valid address
later in the reload pass.  In this case, nothing may be done with the
address except to use it as it stands.  If it is copied, it will not be
replaced with a valid address.  No attempt should be made to make such
an address into a valid address and no routine (such as
@code{change_address}) that will do so may be called.  Note that
@code{general_operand} will fail when applied to such an address.

@findex reload_in_progress
The global variable @code{reload_in_progress} (which must be explicitly
declared if required) can be used to determine whether such special
handling is required.

The variety of operands that have reloads depends on the rest of the
machine description, but typically on a RISC machine these can only be
pseudo registers that did not get hard registers, while on other
machines explicit memory references will get optional reloads.

If a scratch register is required to move an object to or from memory,
it can be allocated using @code{gen_reg_rtx} prior to life analysis.

If there are cases which need scratch registers during or after reload,
you must provide an appropriate secondary_reload target hook.

@findex can_create_pseudo_p
The macro @code{can_create_pseudo_p} can be used to determine if it
is unsafe to create new pseudo registers.  If this variable is nonzero, then
it is unsafe to call @code{gen_reg_rtx} to allocate a new pseudo.

The constraints on a @samp{mov@var{m}} must permit moving any hard
register to any other hard register provided that
@code{HARD_REGNO_MODE_OK} permits mode @var{m} in both registers and
@code{TARGET_REGISTER_MOVE_COST} applied to their classes returns a value
of 2.

It is obligatory to support floating point @samp{mov@var{m}}
instructions into and out of any registers that can hold fixed point
values, because unions and structures (which have modes @code{SImode} or
@code{DImode}) can be in those registers and they may have floating
point members.

There may also be a need to support fixed point @samp{mov@var{m}}
instructions in and out of floating point registers.  Unfortunately, I
have forgotten why this was so, and I don't know whether it is still
true.  If @code{HARD_REGNO_MODE_OK} rejects fixed point values in
floating point registers, then the constraints of the fixed point
@samp{mov@var{m}} instructions must be designed to avoid ever trying to
reload into a floating point register.

@cindex @code{reload_in} instruction pattern
@cindex @code{reload_out} instruction pattern
@item @samp{reload_in@var{m}}
@itemx @samp{reload_out@var{m}}
These named patterns have been obsoleted by the target hook
@code{secondary_reload}.

Like @samp{mov@var{m}}, but used when a scratch register is required to
move between operand 0 and operand 1.  Operand 2 describes the scratch
register.  See the discussion of the @code{SECONDARY_RELOAD_CLASS}
macro in @pxref{Register Classes}.

There are special restrictions on the form of the @code{match_operand}s
used in these patterns.  First, only the predicate for the reload
operand is examined, i.e., @code{reload_in} examines operand 1, but not
the predicates for operand 0 or 2.  Second, there may be only one
alternative in the constraints.  Third, only a single register class
letter may be used for the constraint; subsequent constraint letters
are ignored.  As a special exception, an empty constraint string
matches the @code{ALL_REGS} register class.  This may relieve ports
of the burden of defining an @code{ALL_REGS} constraint letter just
for these patterns.

@cindex @code{movstrict@var{m}} instruction pattern
@item @samp{movstrict@var{m}}
Like @samp{mov@var{m}} except that if operand 0 is a @code{subreg}
with mode @var{m} of a register whose natural mode is wider,
the @samp{movstrict@var{m}} instruction is guaranteed not to alter
any of the register except the part which belongs to mode @var{m}.

@cindex @code{movmisalign@var{m}} instruction pattern
@item @samp{movmisalign@var{m}}
This variant of a move pattern is designed to load or store a value
from a memory address that is not naturally aligned for its mode.
For a store, the memory will be in operand 0; for a load, the memory
will be in operand 1.  The other operand is guaranteed not to be a
memory, so that it's easy to tell whether this is a load or store.

This pattern is used by the autovectorizer, and when expanding a
@code{MISALIGNED_INDIRECT_REF} expression.

@cindex @code{load_multiple} instruction pattern
@item @samp{load_multiple}
Load several consecutive memory locations into consecutive registers.
Operand 0 is the first of the consecutive registers, operand 1
is the first memory location, and operand 2 is a constant: the
number of consecutive registers.

Define this only if the target machine really has such an instruction;
do not define this if the most efficient way of loading consecutive
registers from memory is to do them one at a time.

On some machines, there are restrictions as to which consecutive
registers can be stored into memory, such as particular starting or
ending register numbers or only a range of valid counts.  For those
machines, use a @code{define_expand} (@pxref{Expander Definitions})
and make the pattern fail if the restrictions are not met.

Write the generated insn as a @code{parallel} with elements being a
@code{set} of one register from the appropriate memory location (you may
also need @code{use} or @code{clobber} elements).  Use a
@code{match_parallel} (@pxref{RTL Template}) to recognize the insn.  See
@file{rs6000.md} for examples of the use of this insn pattern.

@cindex @samp{store_multiple} instruction pattern
@item @samp{store_multiple}
Similar to @samp{load_multiple}, but store several consecutive registers
into consecutive memory locations.  Operand 0 is the first of the
consecutive memory locations, operand 1 is the first register, and
operand 2 is a constant: the number of consecutive registers.

@cindex @code{vec_load_lanes@var{m}@var{n}} instruction pattern
@item @samp{vec_load_lanes@var{m}@var{n}}
Perform an interleaved load of several vectors from memory operand 1
into register operand 0.  Both operands have mode @var{m}.  The register
operand is viewed as holding consecutive vectors of mode @var{n},
while the memory operand is a flat array that contains the same number
of elements.  The operation is equivalent to:

@smallexample
int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});
for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)
  for (i = 0; i < c; i++)
    operand0[i][j] = operand1[j * c + i];
@end smallexample

For example, @samp{vec_load_lanestiv4hi} loads 8 16-bit values
from memory into a register of mode @samp{TI}@.  The register
contains two consecutive vectors of mode @samp{V4HI}@.

This pattern can only be used if:
@smallexample
TARGET_ARRAY_MODE_SUPPORTED_P (@var{n}, @var{c})
@end smallexample
is true.  GCC assumes that, if a target supports this kind of
instruction for some mode @var{n}, it also supports unaligned
loads for vectors of mode @var{n}.

@cindex @code{vec_store_lanes@var{m}@var{n}} instruction pattern
@item @samp{vec_store_lanes@var{m}@var{n}}
Equivalent to @samp{vec_load_lanes@var{m}@var{n}}, with the memory
and register operands reversed.  That is, the instruction is
equivalent to:

@smallexample
int c = GET_MODE_SIZE (@var{m}) / GET_MODE_SIZE (@var{n});
for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)
  for (i = 0; i < c; i++)
    operand0[j * c + i] = operand1[i][j];
@end smallexample

for a memory operand 0 and register operand 1.

@cindex @code{vec_set@var{m}} instruction pattern
@item @samp{vec_set@var{m}}
Set given field in the vector value.  Operand 0 is the vector to modify,
operand 1 is new value of field and operand 2 specify the field index.

@cindex @code{vec_extract@var{m}} instruction pattern
@item @samp{vec_extract@var{m}}
Extract given field from the vector value.  Operand 1 is the vector, operand 2
specify field index and operand 0 place to store value into.

@cindex @code{vec_init@var{m}} instruction pattern
@item @samp{vec_init@var{m}}
Initialize the vector to given values.  Operand 0 is the vector to initialize
and operand 1 is parallel containing values for individual fields.

@cindex @code{vcond@var{m}@var{n}} instruction pattern
@item @samp{vcond@var{m}@var{n}}
Output a conditional vector move.  Operand 0 is the destination to
receive a combination of operand 1 and operand 2, which are of mode @var{m},
dependent on the outcome of the predicate in operand 3 which is a
vector comparison with operands of mode @var{n} in operands 4 and 5.  The
modes @var{m} and @var{n} should have the same size.  Operand 0
will be set to the value @var{op1} & @var{msk} | @var{op2} & ~@var{msk}
where @var{msk} is computed by element-wise evaluation of the vector
comparison with a truth value of all-ones and a false value of all-zeros.

@cindex @code{vec_perm@var{m}} instruction pattern
@item @samp{vec_perm@var{m}}
Output a (variable) vector permutation.  Operand 0 is the destination
to receive elements from operand 1 and operand 2, which are of mode
@var{m}.  Operand 3 is the @dfn{selector}.  It is an integral mode
vector of the same width and number of elements as mode @var{m}.

The input elements are numbered from 0 in operand 1 through
@math{2*@var{N}-1} in operand 2.  The elements of the selector must
be computed modulo @math{2*@var{N}}.  Note that if
@code{rtx_equal_p(operand1, operand2)}, this can be implemented
with just operand 1 and selector elements modulo @var{N}.

In order to make things easy for a number of targets, if there is no
@samp{vec_perm} pattern for mode @var{m}, but there is for mode @var{q}
where @var{q} is a vector of @code{QImode} of the same width as @var{m},
the middle-end will lower the mode @var{m} @code{VEC_PERM_EXPR} to
mode @var{q}.

@cindex @code{vec_perm_const@var{m}} instruction pattern
@item @samp{vec_perm_const@var{m}}
Like @samp{vec_perm} except that the permutation is a compile-time
constant.  That is, operand 3, the @dfn{selector}, is a @code{CONST_VECTOR}.

Some targets cannot perform a permutation with a variable selector,
but can efficiently perform a constant permutation.  Further, the
target hook @code{vec_perm_ok} is queried to determine if the 
specific constant permutation is available efficiently; the named
pattern is never expanded without @code{vec_perm_ok} returning true.

There is no need for a target to supply both @samp{vec_perm@var{m}}
and @samp{vec_perm_const@var{m}} if the former can trivially implement
the operation with, say, the vector constant loaded into a register.

@cindex @code{push@var{m}1} instruction pattern
@item @samp{push@var{m}1}
Output a push instruction.  Operand 0 is value to push.  Used only when
@code{PUSH_ROUNDING} is defined.  For historical reason, this pattern may be
missing and in such case an @code{mov} expander is used instead, with a
@code{MEM} expression forming the push operation.  The @code{mov} expander
method is deprecated.

@cindex @code{add@var{m}3} instruction pattern
@item @samp{add@var{m}3}
Add operand 2 and operand 1, storing the result in operand 0.  All operands
must have mode @var{m}.  This can be used even on two-address machines, by
means of constraints requiring operands 1 and 0 to be the same location.

@cindex @code{addptr@var{m}3} instruction pattern
@item @samp{addptr@var{m}3}
Like @code{add@var{m}3} but is guaranteed to only be used for address
calculations.  The expanded code is not allowed to clobber the
condition code.  It only needs to be defined if @code{add@var{m}3}
sets the condition code.  If adds used for address calculations and
normal adds are not compatible it is required to expand a distinct
pattern (e.g. using an unspec).  The pattern is used by LRA to emit
address calculations.  @code{add@var{m}3} is used if
@code{addptr@var{m}3} is not defined.

@cindex @code{ssadd@var{m}3} instruction pattern
@cindex @code{usadd@var{m}3} instruction pattern
@cindex @code{sub@var{m}3} instruction pattern
@cindex @code{sssub@var{m}3} instruction pattern
@cindex @code{ussub@var{m}3} instruction pattern
@cindex @code{mul@var{m}3} instruction pattern
@cindex @code{ssmul@var{m}3} instruction pattern
@cindex @code{usmul@var{m}3} instruction pattern
@cindex @code{div@var{m}3} instruction pattern
@cindex @code{ssdiv@var{m}3} instruction pattern
@cindex @code{udiv@var{m}3} instruction pattern
@cindex @code{usdiv@var{m}3} instruction pattern
@cindex @code{mod@var{m}3} instruction pattern
@cindex @code{umod@var{m}3} instruction pattern
@cindex @code{umin@var{m}3} instruction pattern
@cindex @code{umax@var{m}3} instruction pattern
@cindex @code{and@var{m}3} instruction pattern
@cindex @code{ior@var{m}3} instruction pattern
@cindex @code{xor@var{m}3} instruction pattern
@item @samp{ssadd@var{m}3}, @samp{usadd@var{m}3}
@itemx @samp{sub@var{m}3}, @samp{sssub@var{m}3}, @samp{ussub@var{m}3}
@itemx @samp{mul@var{m}3}, @samp{ssmul@var{m}3}, @samp{usmul@var{m}3}
@itemx @samp{div@var{m}3}, @samp{ssdiv@var{m}3}
@itemx @samp{udiv@var{m}3}, @samp{usdiv@var{m}3}
@itemx @samp{mod@var{m}3}, @samp{umod@var{m}3}
@itemx @samp{umin@var{m}3}, @samp{umax@var{m}3}
@itemx @samp{and@var{m}3}, @samp{ior@var{m}3}, @samp{xor@var{m}3}
Similar, for other arithmetic operations.

@cindex @code{fma@var{m}4} instruction pattern
@item @samp{fma@var{m}4}
Multiply operand 2 and operand 1, then add operand 3, storing the
result in operand 0 without doing an intermediate rounding step.  All
operands must have mode @var{m}.  This pattern is used to implement
the @code{fma}, @code{fmaf}, and @code{fmal} builtin functions from
the ISO C99 standard.

@cindex @code{fms@var{m}4} instruction pattern
@item @samp{fms@var{m}4}
Like @code{fma@var{m}4}, except operand 3 subtracted from the
product instead of added to the product.  This is represented
in the rtl as

@smallexample
(fma:@var{m} @var{op1} @var{op2} (neg:@var{m} @var{op3}))
@end smallexample

@cindex @code{fnma@var{m}4} instruction pattern
@item @samp{fnma@var{m}4}
Like @code{fma@var{m}4} except that the intermediate product
is negated before being added to operand 3.  This is represented
in the rtl as

@smallexample
(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} @var{op3})
@end smallexample

@cindex @code{fnms@var{m}4} instruction pattern
@item @samp{fnms@var{m}4}
Like @code{fms@var{m}4} except that the intermediate product
is negated before subtracting operand 3.  This is represented
in the rtl as

@smallexample
(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} (neg:@var{m} @var{op3}))
@end smallexample

@cindex @code{min@var{m}3} instruction pattern
@cindex @code{max@var{m}3} instruction pattern
@item @samp{smin@var{m}3}, @samp{smax@var{m}3}
Signed minimum and maximum operations.  When used with floating point,
if both operands are zeros, or if either operand is @code{NaN}, then
it is unspecified which of the two operands is returned as the result.

@cindex @code{reduc_smin_@var{m}} instruction pattern
@cindex @code{reduc_smax_@var{m}} instruction pattern
@item @samp{reduc_smin_@var{m}}, @samp{reduc_smax_@var{m}}
Find the signed minimum/maximum of the elements of a vector. The vector is
operand 1, and the result is stored in the least significant bits of
operand 0 (also a vector). The output and input vector should have the same
modes. These are legacy optabs, and platforms should prefer to implement
@samp{reduc_smin_scal_@var{m}} and @samp{reduc_smax_scal_@var{m}}.

@cindex @code{reduc_umin_@var{m}} instruction pattern
@cindex @code{reduc_umax_@var{m}} instruction pattern
@item @samp{reduc_umin_@var{m}}, @samp{reduc_umax_@var{m}}
Find the unsigned minimum/maximum of the elements of a vector. The vector is
operand 1, and the result is stored in the least significant bits of
operand 0 (also a vector). The output and input vector should have the same
modes. These are legacy optabs, and platforms should prefer to implement
@samp{reduc_umin_scal_@var{m}} and @samp{reduc_umax_scal_@var{m}}.

@cindex @code{reduc_splus_@var{m}} instruction pattern
@cindex @code{reduc_uplus_@var{m}} instruction pattern
@item @samp{reduc_splus_@var{m}}, @samp{reduc_uplus_@var{m}}
Compute the sum of the signed/unsigned elements of a vector. The vector is
operand 1, and the result is stored in the least significant bits of operand 0
(also a vector). The output and input vector should have the same modes.
These are legacy optabs, and platforms should prefer to implement
@samp{reduc_plus_scal_@var{m}}.

@cindex @code{reduc_smin_scal_@var{m}} instruction pattern
@cindex @code{reduc_smax_scal_@var{m}} instruction pattern
@item @samp{reduc_smin_scal_@var{m}}, @samp{reduc_smax_scal_@var{m}}
Find the signed minimum/maximum of the elements of a vector. The vector is
operand 1, and operand 0 is the scalar result, with mode equal to the mode of
the elements of the input vector.

@cindex @code{reduc_umin_scal_@var{m}} instruction pattern
@cindex @code{reduc_umax_scal_@var{m}} instruction pattern
@item @samp{reduc_umin_scal_@var{m}}, @samp{reduc_umax_scal_@var{m}}
Find the unsigned minimum/maximum of the elements of a vector. The vector is
operand 1, and operand 0 is the scalar result, with mode equal to the mode of
the elements of the input vector.

@cindex @code{reduc_plus_scal_@var{m}} instruction pattern
@item @samp{reduc_plus_scal_@var{m}}
Compute the sum of the elements of a vector. The vector is operand 1, and
operand 0 is the scalar result, with mode equal to the mode of the elements of
the input vector.

@cindex @code{sdot_prod@var{m}} instruction pattern
@item @samp{sdot_prod@var{m}}
@cindex @code{udot_prod@var{m}} instruction pattern
@itemx @samp{udot_prod@var{m}}
Compute the sum of the products of two signed/unsigned elements.
Operand 1 and operand 2 are of the same mode. Their product, which is of a
wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or
wider than the mode of the product. The result is placed in operand 0, which
is of the same mode as operand 3.

@cindex @code{ssad@var{m}} instruction pattern
@item @samp{ssad@var{m}}
@cindex @code{usad@var{m}} instruction pattern
@item @samp{usad@var{m}}
Compute the sum of absolute differences of two signed/unsigned elements.
Operand 1 and operand 2 are of the same mode. Their absolute difference, which
is of a wider mode, is computed and added to operand 3. Operand 3 is of a mode
equal or wider than the mode of the absolute difference. The result is placed
in operand 0, which is of the same mode as operand 3.

@cindex @code{ssum_widen@var{m3}} instruction pattern
@item @samp{ssum_widen@var{m3}}
@cindex @code{usum_widen@var{m3}} instruction pattern
@itemx @samp{usum_widen@var{m3}}
Operands 0 and 2 are of the same mode, which is wider than the mode of
operand 1. Add operand 1 to operand 2 and place the widened result in
operand 0. (This is used express accumulation of elements into an accumulator
of a wider mode.)

@cindex @code{vec_shr_@var{m}} instruction pattern
@item @samp{vec_shr_@var{m}}
Whole vector right shift in bits, i.e. towards element 0.
Operand 1 is a vector to be shifted.
Operand 2 is an integer shift amount in bits.
Operand 0 is where the resulting shifted vector is stored.
The output and input vectors should have the same modes.

@cindex @code{vec_pack_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_trunc_@var{m}}
Narrow (demote) and merge the elements of two vectors. Operands 1 and 2
are vectors of the same mode having N integral or floating point elements
of size S@.  Operand 0 is the resulting vector in which 2*N elements of
size N/2 are concatenated after narrowing them down using truncation.

@cindex @code{vec_pack_ssat_@var{m}} instruction pattern
@cindex @code{vec_pack_usat_@var{m}} instruction pattern
@item @samp{vec_pack_ssat_@var{m}}, @samp{vec_pack_usat_@var{m}}
Narrow (demote) and merge the elements of two vectors.  Operands 1 and 2
are vectors of the same mode having N integral elements of size S.
Operand 0 is the resulting vector in which the elements of the two input
vectors are concatenated after narrowing them down using signed/unsigned
saturating arithmetic.

@cindex @code{vec_pack_sfix_trunc_@var{m}} instruction pattern
@cindex @code{vec_pack_ufix_trunc_@var{m}} instruction pattern
@item @samp{vec_pack_sfix_trunc_@var{m}}, @samp{vec_pack_ufix_trunc_@var{m}}
Narrow, convert to signed/unsigned integral type and merge the elements
of two vectors.  Operands 1 and 2 are vectors of the same mode having N
floating point elements of size S@.  Operand 0 is the resulting vector
in which 2*N elements of size N/2 are concatenated.

@cindex @code{vec_unpacks_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_hi_@var{m}}, @samp{vec_unpacks_lo_@var{m}}
Extract and widen (promote) the high/low part of a vector of signed
integral or floating point elements.  The input vector (operand 1) has N
elements of size S@.  Widen (promote) the high/low elements of the vector
using signed or floating point extension and place the resulting N/2
values of size 2*S in the output vector (operand 0).

@cindex @code{vec_unpacku_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_lo_@var{m}} instruction pattern
@item @samp{vec_unpacku_hi_@var{m}}, @samp{vec_unpacku_lo_@var{m}}
Extract and widen (promote) the high/low part of a vector of unsigned
integral elements.  The input vector (operand 1) has N elements of size S.
Widen (promote) the high/low elements of the vector using zero extension and
place the resulting N/2 values of size 2*S in the output vector (operand 0).

@cindex @code{vec_unpacks_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacks_float_lo_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_hi_@var{m}} instruction pattern
@cindex @code{vec_unpacku_float_lo_@var{m}} instruction pattern
@item @samp{vec_unpacks_float_hi_@var{m}}, @samp{vec_unpacks_float_lo_@var{m}}
@itemx @samp{vec_unpacku_float_hi_@var{m}}, @samp{vec_unpacku_float_lo_@var{m}}
Extract, convert to floating point type and widen the high/low part of a
vector of signed/unsigned integral elements.  The input vector (operand 1)
has N elements of size S@.  Convert the high/low elements of the vector using
floating point conversion and place the resulting N/2 values of size 2*S in
the output vector (operand 0).

@cindex @code{vec_widen_umult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_umult_lo_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_lo_@var{m}} instruction pattern
@cindex @code{vec_widen_umult_even_@var{m}} instruction pattern
@cindex @code{vec_widen_umult_odd_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_even_@var{m}} instruction pattern
@cindex @code{vec_widen_smult_odd_@var{m}} instruction pattern
@item @samp{vec_widen_umult_hi_@var{m}}, @samp{vec_widen_umult_lo_@var{m}}
@itemx @samp{vec_widen_smult_hi_@var{m}}, @samp{vec_widen_smult_lo_@var{m}}
@itemx @samp{vec_widen_umult_even_@var{m}}, @samp{vec_widen_umult_odd_@var{m}}
@itemx @samp{vec_widen_smult_even_@var{m}}, @samp{vec_widen_smult_odd_@var{m}}
Signed/Unsigned widening multiplication.  The two inputs (operands 1 and 2)
are vectors with N signed/unsigned elements of size S@.  Multiply the high/low
or even/odd elements of the two vectors, and put the N/2 products of size 2*S
in the output vector (operand 0). A target shouldn't implement even/odd pattern
pair if it is less efficient than lo/hi one.

@cindex @code{vec_widen_ushiftl_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_ushiftl_lo_@var{m}} instruction pattern
@cindex @code{vec_widen_sshiftl_hi_@var{m}} instruction pattern
@cindex @code{vec_widen_sshiftl_lo_@var{m}} instruction pattern
@item @samp{vec_widen_ushiftl_hi_@var{m}}, @samp{vec_widen_ushiftl_lo_@var{m}}
@itemx @samp{vec_widen_sshiftl_hi_@var{m}}, @samp{vec_widen_sshiftl_lo_@var{m}}
Signed/Unsigned widening shift left.  The first input (operand 1) is a vector
with N signed/unsigned elements of size S@.  Operand 2 is a constant.  Shift
the high/low elements of operand 1, and put the N/2 results of size 2*S in the
output vector (operand 0).

@cindex @code{mulhisi3} instruction pattern
@item @samp{mulhisi3}
Multiply operands 1 and 2, which have mode @code{HImode}, and store
a @code{SImode} product in operand 0.

@cindex @code{mulqihi3} instruction pattern
@cindex @code{mulsidi3} instruction pattern
@item @samp{mulqihi3}, @samp{mulsidi3}
Similar widening-multiplication instructions of other widths.

@cindex @code{umulqihi3} instruction pattern
@cindex @code{umulhisi3} instruction pattern
@cindex @code{umulsidi3} instruction pattern
@item @samp{umulqihi3}, @samp{umulhisi3}, @samp{umulsidi3}
Similar widening-multiplication instructions that do unsigned
multiplication.

@cindex @code{usmulqihi3} instruction pattern
@cindex @code{usmulhisi3} instruction pattern
@cindex @code{usmulsidi3} instruction pattern
@item @samp{usmulqihi3}, @samp{usmulhisi3}, @samp{usmulsidi3}
Similar widening-multiplication instructions that interpret the first
operand as unsigned and the second operand as signed, then do a signed
multiplication.

@cindex @code{smul@var{m}3_highpart} instruction pattern
@item @samp{smul@var{m}3_highpart}
Perform a signed multiplication of operands 1 and 2, which have mode
@var{m}, and store the most significant half of the product in operand 0.
The least significant half of the product is discarded.

@cindex @code{umul@var{m}3_highpart} instruction pattern
@item @samp{umul@var{m}3_highpart}
Similar, but the multiplication is unsigned.

@cindex @code{madd@var{m}@var{n}4} instruction pattern
@item @samp{madd@var{m}@var{n}4}
Multiply operands 1 and 2, sign-extend them to mode @var{n}, add
operand 3, and store the result in operand 0.  Operands 1 and 2
have mode @var{m} and operands 0 and 3 have mode @var{n}.
Both modes must be integer or fixed-point modes and @var{n} must be twice
the size of @var{m}.

In other words, @code{madd@var{m}@var{n}4} is like
@code{mul@var{m}@var{n}3} except that it also adds operand 3.

These instructions are not allowed to @code{FAIL}.

@cindex @code{umadd@var{m}@var{n}4} instruction pattern
@item @samp{umadd@var{m}@var{n}4}
Like @code{madd@var{m}@var{n}4}, but zero-extend the multiplication
operands instead of sign-extending them.

@cindex @code{ssmadd@var{m}@var{n}4} instruction pattern
@item @samp{ssmadd@var{m}@var{n}4}
Like @code{madd@var{m}@var{n}4}, but all involved operations must be
signed-saturating.

@cindex @code{usmadd@var{m}@var{n}4} instruction pattern
@item @samp{usmadd@var{m}@var{n}4}
Like @code{umadd@var{m}@var{n}4}, but all involved operations must be
unsigned-saturating.

@cindex @code{msub@var{m}@var{n}4} instruction pattern
@item @samp{msub@var{m}@var{n}4}
Multiply operands 1 and 2, sign-extend them to mode @var{n}, subtract the
result from operand 3, and store the result in operand 0.  Operands 1 and 2
have mode @var{m} and operands 0 and 3 have mode @var{n}.
Both modes must be integer or fixed-point modes and @var{n} must be twice
the size of @var{m}.

In other words, @code{msub@var{m}@var{n}4} is like
@code{mul@var{m}@var{n}3} except that it also subtracts the result
from operand 3.

These instructions are not allowed to @code{FAIL}.

@cindex @code{umsub@var{m}@var{n}4} instruction pattern
@item @samp{umsub@var{m}@var{n}4}
Like @code{msub@var{m}@var{n}4}, but zero-extend the multiplication
operands instead of sign-extending them.

@cindex @code{ssmsub@var{m}@var{n}4} instruction pattern
@item @samp{ssmsub@var{m}@var{n}4}
Like @code{msub@var{m}@var{n}4}, but all involved operations must be
signed-saturating.

@cindex @code{usmsub@var{m}@var{n}4} instruction pattern
@item @samp{usmsub@var{m}@var{n}4}
Like @code{umsub@var{m}@var{n}4}, but all involved operations must be
unsigned-saturating.

@cindex @code{divmod@var{m}4} instruction pattern
@item @samp{divmod@var{m}4}
Signed division that produces both a quotient and a remainder.
Operand 1 is divided by operand 2 to produce a quotient stored
in operand 0 and a remainder stored in operand 3.

For machines with an instruction that produces both a quotient and a
remainder, provide a pattern for @samp{divmod@var{m}4} but do not
provide patterns for @samp{div@var{m}3} and @samp{mod@var{m}3}.  This
allows optimization in the relatively common case when both the quotient
and remainder are computed.

If an instruction that just produces a quotient or just a remainder
exists and is more efficient than the instruction that produces both,
write the output routine of @samp{divmod@var{m}4} to call
@code{find_reg_note} and look for a @code{REG_UNUSED} note on the
quotient or remainder and generate the appropriate instruction.

@cindex @code{udivmod@var{m}4} instruction pattern
@item @samp{udivmod@var{m}4}
Similar, but does unsigned division.

@anchor{shift patterns}
@cindex @code{ashl@var{m}3} instruction pattern
@cindex @code{ssashl@var{m}3} instruction pattern
@cindex @code{usashl@var{m}3} instruction pattern
@item @samp{ashl@var{m}3}, @samp{ssashl@var{m}3}, @samp{usashl@var{m}3}
Arithmetic-shift operand 1 left by a number of bits specified by operand
2, and store the result in operand 0.  Here @var{m} is the mode of
operand 0 and operand 1; operand 2's mode is specified by the
instruction pattern, and the compiler will convert the operand to that
mode before generating the instruction.  The meaning of out-of-range shift
counts can optionally be specified by @code{TARGET_SHIFT_TRUNCATION_MASK}.
@xref{TARGET_SHIFT_TRUNCATION_MASK}.  Operand 2 is always a scalar type.

@cindex @code{ashr@var{m}3} instruction pattern
@cindex @code{lshr@var{m}3} instruction pattern
@cindex @code{rotl@var{m}3} instruction pattern
@cindex @code{rotr@var{m}3} instruction pattern
@item @samp{ashr@var{m}3}, @samp{lshr@var{m}3}, @samp{rotl@var{m}3}, @samp{rotr@var{m}3}
Other shift and rotate instructions, analogous to the
@code{ashl@var{m}3} instructions.  Operand 2 is always a scalar type.

@cindex @code{vashl@var{m}3} instruction pattern
@cindex @code{vashr@var{m}3} instruction pattern
@cindex @code{vlshr@var{m}3} instruction pattern
@cindex @code{vrotl@var{m}3} instruction pattern
@cindex @code{vrotr@var{m}3} instruction pattern
@item @samp{vashl@var{m}3}, @samp{vashr@var{m}3}, @samp{vlshr@var{m}3}, @samp{vrotl@var{m}3}, @samp{vrotr@var{m}3}
Vector shift and rotate instructions that take vectors as operand 2
instead of a scalar type.

@cindex @code{bswap@var{m}2} instruction pattern
@item @samp{bswap@var{m}2}
Reverse the order of bytes of operand 1 and store the result in operand 0.

@cindex @code{neg@var{m}2} instruction pattern
@cindex @code{ssneg@var{m}2} instruction pattern
@cindex @code{usneg@var{m}2} instruction pattern
@item @samp{neg@var{m}2}, @samp{ssneg@var{m}2}, @samp{usneg@var{m}2}
Negate operand 1 and store the result in operand 0.

@cindex @code{abs@var{m}2} instruction pattern
@item @samp{abs@var{m}2}
Store the absolute value of operand 1 into operand 0.

@cindex @code{sqrt@var{m}2} instruction pattern
@item @samp{sqrt@var{m}2}
Store the square root of operand 1 into operand 0.

The @code{sqrt} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{sqrtf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{fmod@var{m}3} instruction pattern
@item @samp{fmod@var{m}3}
Store the remainder of dividing operand 1 by operand 2 into
operand 0, rounded towards zero to an integer.

The @code{fmod} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{fmodf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{remainder@var{m}3} instruction pattern
@item @samp{remainder@var{m}3}
Store the remainder of dividing operand 1 by operand 2 into
operand 0, rounded to the nearest integer.

The @code{remainder} built-in function of C always uses the mode
which corresponds to the C data type @code{double} and the
@code{remainderf} built-in function uses the mode which corresponds
to the C data type @code{float}.

@cindex @code{cos@var{m}2} instruction pattern
@item @samp{cos@var{m}2}
Store the cosine of operand 1 into operand 0.

The @code{cos} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{cosf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{sin@var{m}2} instruction pattern
@item @samp{sin@var{m}2}
Store the sine of operand 1 into operand 0.

The @code{sin} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{sinf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{sincos@var{m}3} instruction pattern
@item @samp{sincos@var{m}3}
Store the cosine of operand 2 into operand 0 and the sine of
operand 2 into operand 1.

The @code{sin} and @code{cos} built-in functions of C always use the
mode which corresponds to the C data type @code{double} and the
@code{sinf} and @code{cosf} built-in function use the mode which
corresponds to the C data type @code{float}.
Targets that can calculate the sine and cosine simultaneously can
implement this pattern as opposed to implementing individual
@code{sin@var{m}2} and @code{cos@var{m}2} patterns.  The @code{sin}
and @code{cos} built-in functions will then be expanded to the
@code{sincos@var{m}3} pattern, with one of the output values
left unused.

@cindex @code{exp@var{m}2} instruction pattern
@item @samp{exp@var{m}2}
Store the exponential of operand 1 into operand 0.

The @code{exp} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{expf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{log@var{m}2} instruction pattern
@item @samp{log@var{m}2}
Store the natural logarithm of operand 1 into operand 0.

The @code{log} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{logf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{pow@var{m}3} instruction pattern
@item @samp{pow@var{m}3}
Store the value of operand 1 raised to the exponent operand 2
into operand 0.

The @code{pow} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{powf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{atan2@var{m}3} instruction pattern
@item @samp{atan2@var{m}3}
Store the arc tangent (inverse tangent) of operand 1 divided by
operand 2 into operand 0, using the signs of both arguments to
determine the quadrant of the result.

The @code{atan2} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{atan2f}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{floor@var{m}2} instruction pattern
@item @samp{floor@var{m}2}
Store the largest integral value not greater than argument.

The @code{floor} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{floorf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{btrunc@var{m}2} instruction pattern
@item @samp{btrunc@var{m}2}
Store the argument rounded to integer towards zero.

The @code{trunc} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{truncf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{round@var{m}2} instruction pattern
@item @samp{round@var{m}2}
Store the argument rounded to integer away from zero.

The @code{round} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{roundf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{ceil@var{m}2} instruction pattern
@item @samp{ceil@var{m}2}
Store the argument rounded to integer away from zero.

The @code{ceil} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{ceilf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{nearbyint@var{m}2} instruction pattern
@item @samp{nearbyint@var{m}2}
Store the argument rounded according to the default rounding mode

The @code{nearbyint} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{nearbyintf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{rint@var{m}2} instruction pattern
@item @samp{rint@var{m}2}
Store the argument rounded according to the default rounding mode and
raise the inexact exception when the result differs in value from
the argument

The @code{rint} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{rintf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{lrint@var{m}@var{n}2}
@item @samp{lrint@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number according to the current
rounding mode and store in operand 0 (which has mode @var{n}).

@cindex @code{lround@var{m}@var{n}2}
@item @samp{lround@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding to nearest and away
from zero and store in operand 0 (which has mode @var{n}).

@cindex @code{lfloor@var{m}@var{n}2}
@item @samp{lfloor@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding down and store in
operand 0 (which has mode @var{n}).

@cindex @code{lceil@var{m}@var{n}2}
@item @samp{lceil@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number rounding up and store in
operand 0 (which has mode @var{n}).

@cindex @code{copysign@var{m}3} instruction pattern
@item @samp{copysign@var{m}3}
Store a value with the magnitude of operand 1 and the sign of operand
2 into operand 0.

The @code{copysign} built-in function of C always uses the mode which
corresponds to the C data type @code{double} and the @code{copysignf}
built-in function uses the mode which corresponds to the C data
type @code{float}.

@cindex @code{ffs@var{m}2} instruction pattern
@item @samp{ffs@var{m}2}
Store into operand 0 one plus the index of the least significant 1-bit
of operand 1.  If operand 1 is zero, store zero.  @var{m} is the mode
of operand 0; operand 1's mode is specified by the instruction
pattern, and the compiler will convert the operand to that mode before
generating the instruction.

The @code{ffs} built-in function of C always uses the mode which
corresponds to the C data type @code{int}.

@cindex @code{clrsb@var{m}2} instruction pattern
@item @samp{clrsb@var{m}2}
Count leading redundant sign bits.
Store into operand 0 the number of redundant sign bits in operand 1, starting
at the most significant bit position.
A redundant sign bit is defined as any sign bit after the first. As such,
this count will be one less than the count of leading sign bits.

@cindex @code{clz@var{m}2} instruction pattern
@item @samp{clz@var{m}2}
Store into operand 0 the number of leading 0-bits in operand 1, starting
at the most significant bit position.  If operand 1 is 0, the
@code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
the result is undefined or has a useful value.
@var{m} is the mode of operand 0; operand 1's mode is
specified by the instruction pattern, and the compiler will convert the
operand to that mode before generating the instruction.

@cindex @code{ctz@var{m}2} instruction pattern
@item @samp{ctz@var{m}2}
Store into operand 0 the number of trailing 0-bits in operand 1, starting
at the least significant bit position.  If operand 1 is 0, the
@code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if
the result is undefined or has a useful value.
@var{m} is the mode of operand 0; operand 1's mode is
specified by the instruction pattern, and the compiler will convert the
operand to that mode before generating the instruction.

@cindex @code{popcount@var{m}2} instruction pattern
@item @samp{popcount@var{m}2}
Store into operand 0 the number of 1-bits in operand 1.  @var{m} is the
mode of operand 0; operand 1's mode is specified by the instruction
pattern, and the compiler will convert the operand to that mode before
generating the instruction.

@cindex @code{parity@var{m}2} instruction pattern
@item @samp{parity@var{m}2}
Store into operand 0 the parity of operand 1, i.e.@: the number of 1-bits
in operand 1 modulo 2.  @var{m} is the mode of operand 0; operand 1's mode
is specified by the instruction pattern, and the compiler will convert
the operand to that mode before generating the instruction.

@cindex @code{one_cmpl@var{m}2} instruction pattern
@item @samp{one_cmpl@var{m}2}
Store the bitwise-complement of operand 1 into operand 0.

@cindex @code{movmem@var{m}} instruction pattern
@item @samp{movmem@var{m}}
Block move instruction.  The destination and source blocks of memory
are the first two operands, and both are @code{mem:BLK}s with an
address in mode @code{Pmode}.

The number of bytes to move is the third operand, in mode @var{m}.
Usually, you specify @code{Pmode} for @var{m}.  However, if you can
generate better code knowing the range of valid lengths is smaller than
those representable in a full Pmode pointer, you should provide
a pattern with a
mode corresponding to the range of values you can handle efficiently
(e.g., @code{QImode} for values in the range 0--127; note we avoid numbers
that appear negative) and also a pattern with @code{Pmode}.

The fourth operand is the known shared alignment of the source and
destination, in the form of a @code{const_int} rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.

Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to @code{(const_int -1)}.

Descriptions of multiple @code{movmem@var{m}} patterns can only be
beneficial if the patterns for smaller modes have fewer restrictions
on their first, second and fourth operands.  Note that the mode @var{m}
in @code{movmem@var{m}} does not impose any restriction on the mode of
individually moved data units in the block.

These patterns need not give special consideration to the possibility
that the source and destination strings might overlap.

@cindex @code{movstr} instruction pattern
@item @samp{movstr}
String copy instruction, with @code{stpcpy} semantics.  Operand 0 is
an output operand in mode @code{Pmode}.  The addresses of the
destination and source strings are operands 1 and 2, and both are
@code{mem:BLK}s with addresses in mode @code{Pmode}.  The execution of
the expansion of this pattern should store in operand 0 the address in
which the @code{NUL} terminator was stored in the destination string.

This patern has also several optional operands that are same as in
@code{setmem}.

@cindex @code{setmem@var{m}} instruction pattern
@item @samp{setmem@var{m}}
Block set instruction.  The destination string is the first operand,
given as a @code{mem:BLK} whose address is in mode @code{Pmode}.  The
number of bytes to set is the second operand, in mode @var{m}.  The value to
initialize the memory with is the third operand. Targets that only support the
clearing of memory should reject any value that is not the constant 0.  See
@samp{movmem@var{m}} for a discussion of the choice of mode.

The fourth operand is the known alignment of the destination, in the form
of a @code{const_int} rtx.  Thus, if the compiler knows that the
destination is word-aligned, it may provide the value 4 for this
operand.

Optional operands 5 and 6 specify expected alignment and size of block
respectively.  The expected alignment differs from alignment in operand 4
in a way that the blocks are not required to be aligned according to it in
all cases. This expected alignment is also in bytes, just like operand 4.
Expected size, when unknown, is set to @code{(const_int -1)}.
Operand 7 is the minimal size of the block and operand 8 is the
maximal size of the block (NULL if it can not be represented as CONST_INT).
Operand 9 is the probable maximal size (i.e. we can not rely on it for correctness,
but it can be used for choosing proper code sequence for a given size).

The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.

@cindex @code{cmpstrn@var{m}} instruction pattern
@item @samp{cmpstrn@var{m}}
String compare instruction, with five operands.  Operand 0 is the output;
it has mode @var{m}.  The remaining four operands are like the operands
of @samp{movmem@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
string.  The instruction is not allowed to prefetch more than one byte
at a time since either string may end in the first byte and reading past
that may access an invalid page or segment and cause a fault.  The
comparison terminates early if the fetched bytes are different or if
they are equal to zero.  The effect of the instruction is to store a
value in operand 0 whose sign indicates the result of the comparison.

@cindex @code{cmpstr@var{m}} instruction pattern
@item @samp{cmpstr@var{m}}
String compare instruction, without known maximum length.  Operand 0 is the
output; it has mode @var{m}.  The second and third operand are the blocks of
memory to be compared; both are @code{mem:BLK} with an address in mode
@code{Pmode}.

The fourth operand is the known shared alignment of the source and
destination, in the form of a @code{const_int} rtx.  Thus, if the
compiler knows that both source and destination are word-aligned,
it may provide the value 4 for this operand.

The two memory blocks specified are compared byte by byte in lexicographic
order starting at the beginning of each string.  The instruction is not allowed
to prefetch more than one byte at a time since either string may end in the
first byte and reading past that may access an invalid page or segment and
cause a fault.  The comparison will terminate when the fetched bytes
are different or if they are equal to zero.  The effect of the
instruction is to store a value in operand 0 whose sign indicates the
result of the comparison.

@cindex @code{cmpmem@var{m}} instruction pattern
@item @samp{cmpmem@var{m}}
Block compare instruction, with five operands like the operands
of @samp{cmpstr@var{m}}.  The two memory blocks specified are compared
byte by byte in lexicographic order starting at the beginning of each
block.  Unlike @samp{cmpstr@var{m}} the instruction can prefetch
any bytes in the two memory blocks.  Also unlike @samp{cmpstr@var{m}}
the comparison will not stop if both bytes are zero.  The effect of
the instruction is to store a value in operand 0 whose sign indicates
the result of the comparison.

@cindex @code{strlen@var{m}} instruction pattern
@item @samp{strlen@var{m}}
Compute the length of a string, with three operands.
Operand 0 is the result (of mode @var{m}), operand 1 is
a @code{mem} referring to the first character of the string,
operand 2 is the character to search for (normally zero),
and operand 3 is a constant describing the known alignment
of the beginning of the string.

@cindex @code{float@var{m}@var{n}2} instruction pattern
@item @samp{float@var{m}@var{n}2}
Convert signed integer operand 1 (valid for fixed point mode @var{m}) to
floating point mode @var{n} and store in operand 0 (which has mode
@var{n}).

@cindex @code{floatuns@var{m}@var{n}2} instruction pattern
@item @samp{floatuns@var{m}@var{n}2}
Convert unsigned integer operand 1 (valid for fixed point mode @var{m})
to floating point mode @var{n} and store in operand 0 (which has mode
@var{n}).

@cindex @code{fix@var{m}@var{n}2} instruction pattern
@item @samp{fix@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as a signed number and store in operand 0 (which
has mode @var{n}).  This instruction's result is defined only when
the value of operand 1 is an integer.

If the machine description defines this pattern, it also needs to
define the @code{ftrunc} pattern.

@cindex @code{fixuns@var{m}@var{n}2} instruction pattern
@item @samp{fixuns@var{m}@var{n}2}
Convert operand 1 (valid for floating point mode @var{m}) to fixed
point mode @var{n} as an unsigned number and store in operand 0 (which
has mode @var{n}).  This instruction's result is defined only when the
value of operand 1 is an integer.

@cindex @code{ftrunc@var{m}2} instruction pattern
@item @samp{ftrunc@var{m}2}
Convert operand 1 (valid for floating point mode @var{m}) to an
integer value, still represented in floating point mode @var{m}, and
store it in operand 0 (valid for floating point mode @var{m}).

@cindex @code{fix_trunc@var{m}@var{n}2} instruction pattern
@item @samp{fix_trunc@var{m}@var{n}2}
Like @samp{fix@var{m}@var{n}2} but works for any floating point value
of mode @var{m} by converting the value to an integer.

@cindex @code{fixuns_trunc@var{m}@var{n}2} instruction pattern
@item @samp{fixuns_trunc@var{m}@var{n}2}
Like @samp{fixuns@var{m}@var{n}2} but works for any floating point
value of mode @var{m} by converting the value to an integer.

@cindex @code{trunc@var{m}@var{n}2} instruction pattern
@item @samp{trunc@var{m}@var{n}2}
Truncate operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point or both floating point.

@cindex @code{extend@var{m}@var{n}2} instruction pattern
@item @samp{extend@var{m}@var{n}2}
Sign-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point or both floating point.

@cindex @code{zero_extend@var{m}@var{n}2} instruction pattern
@item @samp{zero_extend@var{m}@var{n}2}
Zero-extend operand 1 (valid for mode @var{m}) to mode @var{n} and
store in operand 0 (which has mode @var{n}).  Both modes must be fixed
point.

@cindex @code{fract@var{m}@var{n}2} instruction pattern
@item @samp{fract@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be fixed-point to fixed-point, signed integer to fixed-point,
fixed-point to signed integer, floating-point to fixed-point,
or fixed-point to floating-point.
When overflows or underflows happen, the results are undefined.

@cindex @code{satfract@var{m}@var{n}2} instruction pattern
@item @samp{satfract@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be fixed-point to fixed-point, signed integer to fixed-point,
or floating-point to fixed-point.
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.

@cindex @code{fractuns@var{m}@var{n}2} instruction pattern
@item @samp{fractuns@var{m}@var{n}2}
Convert operand 1 of mode @var{m} to mode @var{n} and store in
operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}
could be unsigned integer to fixed-point, or
fixed-point to unsigned integer.
When overflows or underflows happen, the results are undefined.

@cindex @code{satfractuns@var{m}@var{n}2} instruction pattern
@item @samp{satfractuns@var{m}@var{n}2}
Convert unsigned integer operand 1 of mode @var{m} to fixed-point mode
@var{n} and store in operand 0 (which has mode @var{n}).
When overflows or underflows happen, the instruction saturates the
results to the maximum or the minimum.

@cindex @code{extv@var{m}} instruction pattern
@item @samp{extv@var{m}}
Extract a bit-field from register operand 1, sign-extend it, and store
it in operand 0.  Operand 2 specifies the width of the field in bits
and operand 3 the starting bit, which counts from the most significant
bit if @samp{BITS_BIG_ENDIAN} is true and from the least significant bit
otherwise.

Operands 0 and 1 both have mode @var{m}.  Operands 2 and 3 have a
target-specific mode.

@cindex @code{extvmisalign@var{m}} instruction pattern
@item @samp{extvmisalign@var{m}}
Extract a bit-field from memory operand 1, sign extend it, and store
it in operand 0.  Operand 2 specifies the width in bits and operand 3
the starting bit.  The starting bit is always somewhere in the first byte of
operand 1; it counts from the most significant bit if @samp{BITS_BIG_ENDIAN}
is true and from the least significant bit otherwise.

Operand 0 has mode @var{m} while operand 1 has @code{BLK} mode.
Operands 2 and 3 have a target-specific mode.

The instruction must not read beyond the last byte of the bit-field.

@cindex @code{extzv@var{m}} instruction pattern
@item @samp{extzv@var{m}}
Like @samp{extv@var{m}} except that the bit-field value is zero-extended.

@cindex @code{extzvmisalign@var{m}} instruction pattern
@item @samp{extzvmisalign@var{m}}
Like @samp{extvmisalign@var{m}} except that the bit-field value is
zero-extended.

@cindex @code{insv@var{m}} instruction pattern
@item @samp{insv@var{m}}
Insert operand 3 into a bit-field of register operand 0.  Operand 1
specifies the width of the field in bits and operand 2 the starting bit,
which counts from the most significant bit if @samp{BITS_BIG_ENDIAN}
is true and from the least significant bit otherwise.

Operands 0 and 3 both have mode @var{m}.  Operands 1 and 2 have a
target-specific mode.

@cindex @code{insvmisalign@var{m}} instruction pattern
@item @samp{insvmisalign@var{m}}
Insert operand 3 into a bit-field of memory operand 0.  Operand 1
specifies the width of the field in bits and operand 2 the starting bit.
The starting bit is always somewhere in the first byte of operand 0;
it counts from the most significant bit if @samp{BITS_BIG_ENDIAN}
is true and from the least significant bit otherwise.

Operand 3 has mode @var{m} while operand 0 has @code{BLK} mode.
Operands 1 and 2 have a target-specific mode.

The instruction must not read or write beyond the last byte of the bit-field.

@cindex @code{extv} instruction pattern
@item @samp{extv}
Extract a bit-field from operand 1 (a register or memory operand), where
operand 2 specifies the width in bits and operand 3 the starting bit,
and store it in operand 0.  Operand 0 must have mode @code{word_mode}.
Operand 1 may have mode @code{byte_mode} or @code{word_mode}; often
@code{word_mode} is allowed only for registers.  Operands 2 and 3 must
be valid for @code{word_mode}.

The RTL generation pass generates this instruction only with constants
for operands 2 and 3 and the constant is never zero for operand 2.

The bit-field value is sign-extended to a full word integer
before it is stored in operand 0.

This pattern is deprecated; please use @samp{extv@var{m}} and
@code{extvmisalign@var{m}} instead.

@cindex @code{extzv} instruction pattern
@item @samp{extzv}
Like @samp{extv} except that the bit-field value is zero-extended.

This pattern is deprecated; please use @samp{extzv@var{m}} and
@code{extzvmisalign@var{m}} instead.

@cindex @code{insv} instruction pattern
@item @samp{insv}
Store operand 3 (which must be valid for @code{word_mode}) into a
bit-field in operand 0, where operand 1 specifies the width in bits and
operand 2 the starting bit.  Operand 0 may have mode @code{byte_mode} or
@code{word_mode}; often @code{word_mode} is allowed only for registers.
Operands 1 and 2 must be valid for @code{word_mode}.

The RTL generation pass generates this instruction only with constants
for operands 1 and 2 and the constant is never zero for operand 1.

This pattern is deprecated; please use @samp{insv@var{m}} and
@code{insvmisalign@var{m}} instead.

@cindex @code{mov@var{mode}cc} instruction pattern
@item @samp{mov@var{mode}cc}
Conditionally move operand 2 or operand 3 into operand 0 according to the
comparison in operand 1.  If the comparison is true, operand 2 is moved
into operand 0, otherwise operand 3 is moved.

The mode of the operands being compared need not be the same as the operands
being moved.  Some machines, sparc64 for example, have instructions that
conditionally move an integer value based on the floating point condition
codes and vice versa.

If the machine does not have conditional move instructions, do not
define these patterns.

@cindex @code{add@var{mode}cc} instruction pattern
@item @samp{add@var{mode}cc}
Similar to @samp{mov@var{mode}cc} but for conditional addition.  Conditionally
move operand 2 or (operands 2 + operand 3) into operand 0 according to the
comparison in operand 1.  If the comparison is false, operand 2 is moved into
operand 0, otherwise (operand 2 + operand 3) is moved.

@cindex @code{cstore@var{mode}4} instruction pattern
@item @samp{cstore@var{mode}4}
Store zero or nonzero in operand 0 according to whether a comparison
is true.  Operand 1 is a comparison operator.  Operand 2 and operand 3
are the first and second operand of the comparison, respectively.
You specify the mode that operand 0 must have when you write the
@code{match_operand} expression.  The compiler automatically sees which
mode you have used and supplies an operand of that mode.

The value stored for a true condition must have 1 as its low bit, or
else must be negative.  Otherwise the instruction is not suitable and
you should omit it from the machine description.  You describe to the
compiler exactly which value is stored by defining the macro
@code{STORE_FLAG_VALUE} (@pxref{Misc}).  If a description cannot be
found that can be used for all the possible comparison operators, you
should pick one and use a @code{define_expand} to map all results
onto the one you chose.

These operations may @code{FAIL}, but should do so only in relatively
uncommon cases; if they would @code{FAIL} for common cases involving
integer comparisons, it is best to restrict the predicates to not
allow these operands.  Likewise if a given comparison operator will
always fail, independent of the operands (for floating-point modes, the
@code{ordered_comparison_operator} predicate is often useful in this case).

If this pattern is omitted, the compiler will generate a conditional
branch---for example, it may copy a constant one to the target and branching
around an assignment of zero to the target---or a libcall.  If the predicate
for operand 1 only rejects some operators, it will also try reordering the
operands and/or inverting the result value (e.g.@: by an exclusive OR).
These possibilities could be cheaper or equivalent to the instructions
used for the @samp{cstore@var{mode}4} pattern followed by those required
to convert a positive result from @code{STORE_FLAG_VALUE} to 1; in this
case, you can and should make operand 1's predicate reject some operators
in the @samp{cstore@var{mode}4} pattern, or remove the pattern altogether
from the machine description.

@cindex @code{cbranch@var{mode}4} instruction pattern
@item @samp{cbranch@var{mode}4}
Conditional branch instruction combined with a compare instruction.
Operand 0 is a comparison operator.  Operand 1 and operand 2 are the
first and second operands of the comparison, respectively.  Operand 3
is a @code{label_ref} that refers to the label to jump to.

@cindex @code{jump} instruction pattern
@item @samp{jump}
A jump inside a function; an unconditional branch.  Operand 0 is the
@code{label_ref} of the label to jump to.  This pattern name is mandatory
on all machines.

@cindex @code{call} instruction pattern
@item @samp{call}
Subroutine call instruction returning no value.  Operand 0 is the
function to call; operand 1 is the number of bytes of arguments pushed
as a @code{const_int}; operand 2 is the number of registers used as
operands.

On most machines, operand 2 is not actually stored into the RTL
pattern.  It is supplied for the sake of some RISC machines which need
to put this information into the assembler code; they can put it in
the RTL instead of operand 1.

Operand 0 should be a @code{mem} RTX whose address is the address of the
function.  Note, however, that this address can be a @code{symbol_ref}
expression even if it would not be a legitimate memory address on the
target machine.  If it is also not a valid argument for a call
instruction, the pattern for this operation should be a
@code{define_expand} (@pxref{Expander Definitions}) that places the
address into a register and uses that register in the call instruction.

@cindex @code{call_value} instruction pattern
@item @samp{call_value}
Subroutine call instruction returning a value.  Operand 0 is the hard
register in which the value is returned.  There are three more
operands, the same as the three operands of the @samp{call}
instruction (but with numbers increased by one).

Subroutines that return @code{BLKmode} objects use the @samp{call}
insn.

@cindex @code{call_pop} instruction pattern
@cindex @code{call_value_pop} instruction pattern
@item @samp{call_pop}, @samp{call_value_pop}
Similar to @samp{call} and @samp{call_value}, except used if defined and
if @code{RETURN_POPS_ARGS} is nonzero.  They should emit a @code{parallel}
that contains both the function call and a @code{set} to indicate the
adjustment made to the frame pointer.

For machines where @code{RETURN_POPS_ARGS} can be nonzero, the use of these
patterns increases the number of functions for which the frame pointer
can be eliminated, if desired.

@cindex @code{untyped_call} instruction pattern
@item @samp{untyped_call}
Subroutine call instruction returning a value of any type.  Operand 0 is
the function to call; operand 1 is a memory location where the result of
calling the function is to be stored; operand 2 is a @code{parallel}
expression where each element is a @code{set} expression that indicates
the saving of a function return value into the result block.

This instruction pattern should be defined to support
@code{__builtin_apply} on machines where special instructions are needed
to call a subroutine with arbitrary arguments or to save the value
returned.  This instruction pattern is required on machines that have
multiple registers that can hold a return value
(i.e.@: @code{FUNCTION_VALUE_REGNO_P} is true for more than one register).

@cindex @code{return} instruction pattern
@item @samp{return}
Subroutine return instruction.  This instruction pattern name should be
defined only if a single instruction can do all the work of returning
from a function.

Like the @samp{mov@var{m}} patterns, this pattern is also used after the
RTL generation phase.  In this case it is to support machines where
multiple instructions are usually needed to return from a function, but
some class of functions only requires one instruction to implement a
return.  Normally, the applicable functions are those which do not need
to save any registers or allocate stack space.

It is valid for this pattern to expand to an instruction using
@code{simple_return} if no epilogue is required.

@cindex @code{simple_return} instruction pattern
@item @samp{simple_return}
Subroutine return instruction.  This instruction pattern name should be
defined only if a single instruction can do all the work of returning
from a function on a path where no epilogue is required.  This pattern
is very similar to the @code{return} instruction pattern, but it is emitted
only by the shrink-wrapping optimization on paths where the function
prologue has not been executed, and a function return should occur without
any of the effects of the epilogue.  Additional uses may be introduced on
paths where both the prologue and the epilogue have executed.

@findex reload_completed
@findex leaf_function_p
For such machines, the condition specified in this pattern should only
be true when @code{reload_completed} is nonzero and the function's
epilogue would only be a single instruction.  For machines with register
windows, the routine @code{leaf_function_p} may be used to determine if
a register window push is required.

Machines that have conditional return instructions should define patterns
such as

@smallexample
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator
                         0 "comparison_operator"
                         [(cc0) (const_int 0)])
                      (return)
                      (pc)))]
  "@var{condition}"
  "@dots{}")
@end smallexample

where @var{condition} would normally be the same condition specified on the
named @samp{return} pattern.

@cindex @code{untyped_return} instruction pattern
@item @samp{untyped_return}
Untyped subroutine return instruction.  This instruction pattern should
be defined to support @code{__builtin_return} on machines where special
instructions are needed to return a value of any type.

Operand 0 is a memory location where the result of calling a function
with @code{__builtin_apply} is stored; operand 1 is a @code{parallel}
expression where each element is a @code{set} expression that indicates
the restoring of a function return value from the result block.

@cindex @code{nop} instruction pattern
@item @samp{nop}
No-op instruction.  This instruction pattern name should always be defined
to output a no-op in assembler code.  @code{(const_int 0)} will do as an
RTL pattern.

@cindex @code{indirect_jump} instruction pattern
@item @samp{indirect_jump}
An instruction to jump to an address which is operand zero.
This pattern name is mandatory on all machines.

@cindex @code{casesi} instruction pattern
@item @samp{casesi}
Instruction to jump through a dispatch table, including bounds checking.
This instruction takes five operands:

@enumerate
@item
The index to dispatch on, which has mode @code{SImode}.

@item
The lower bound for indices in the table, an integer constant.

@item
The total range of indices in the table---the largest index
minus the smallest one (both inclusive).

@item
A label that precedes the table itself.

@item
A label to jump to if the index has a value outside the bounds.
@end enumerate

The table is an @code{addr_vec} or @code{addr_diff_vec} inside of a
@code{jump_table_data}.  The number of elements in the table is one plus the
difference between the upper bound and the lower bound.

@cindex @code{tablejump} instruction pattern
@item @samp{tablejump}
Instruction to jump to a variable address.  This is a low-level
capability which can be used to implement a dispatch table when there
is no @samp{casesi} pattern.

This pattern requires two operands: the address or offset, and a label
which should immediately precede the jump table.  If the macro
@code{CASE_VECTOR_PC_RELATIVE} evaluates to a nonzero value then the first
operand is an offset which counts from the address of the table; otherwise,
it is an absolute address to jump to.  In either case, the first operand has
mode @code{Pmode}.

The @samp{tablejump} insn is always the last insn before the jump
table it uses.  Its assembler code normally has no need to use the
second operand, but you should incorporate it in the RTL pattern so
that the jump optimizer will not delete the table as unreachable code.


@cindex @code{decrement_and_branch_until_zero} instruction pattern
@item @samp{decrement_and_branch_until_zero}
Conditional branch instruction that decrements a register and
jumps if the register is nonzero.  Operand 0 is the register to
decrement and test; operand 1 is the label to jump to if the
register is nonzero.  

This optional instruction pattern is only used by the combiner,
typically for loops reversed by the loop optimizer when strength
reduction is enabled.

@cindex @code{doloop_end} instruction pattern
@item @samp{doloop_end}
Conditional branch instruction that decrements a register and
jumps if the register is nonzero.  Operand 0 is the register to
decrement and test; operand 1 is the label to jump to if the
register is nonzero.


This optional instruction pattern should be defined for machines with
low-overhead looping instructions as the loop optimizer will try to
modify suitable loops to utilize it.  The target hook
@code{TARGET_CAN_USE_DOLOOP_P} controls the conditions under which
low-overhead loops can be used.

@cindex @code{doloop_begin} instruction pattern
@item @samp{doloop_begin}
Companion instruction to @code{doloop_end} required for machines that
need to perform some initialization, such as loading a special counter
register.  Operand 1 is the associated @code{doloop_end} pattern and
operand 0 is the register that it decrements.

If initialization insns do not always need to be emitted, use a
@code{define_expand} (@pxref{Expander Definitions}) and make it fail.

@cindex @code{canonicalize_funcptr_for_compare} instruction pattern
@item @samp{canonicalize_funcptr_for_compare}
Canonicalize the function pointer in operand 1 and store the result
into operand 0.

Operand 0 is always a @code{reg} and has mode @code{Pmode}; operand 1
may be a @code{reg}, @code{mem}, @code{symbol_ref}, @code{const_int}, etc
and also has mode @code{Pmode}.

Canonicalization of a function pointer usually involves computing
the address of the function which would be called if the function
pointer were used in an indirect call.

Only define this pattern if function pointers on the target machine
can have different values but still call the same function when
used in an indirect call.

@cindex @code{save_stack_block} instruction pattern
@cindex @code{save_stack_function} instruction pattern
@cindex @code{save_stack_nonlocal} instruction pattern
@cindex @code{restore_stack_block} instruction pattern
@cindex @code{restore_stack_function} instruction pattern
@cindex @code{restore_stack_nonlocal} instruction pattern
@item @samp{save_stack_block}
@itemx @samp{save_stack_function}
@itemx @samp{save_stack_nonlocal}
@itemx @samp{restore_stack_block}
@itemx @samp{restore_stack_function}
@itemx @samp{restore_stack_nonlocal}
Most machines save and restore the stack pointer by copying it to or
from an object of mode @code{Pmode}.  Do not define these patterns on
such machines.

Some machines require special handling for stack pointer saves and
restores.  On those machines, define the patterns corresponding to the
non-standard cases by using a @code{define_expand} (@pxref{Expander
Definitions}) that produces the required insns.  The three types of
saves and restores are:

@enumerate
@item
@samp{save_stack_block} saves the stack pointer at the start of a block
that allocates a variable-sized object, and @samp{restore_stack_block}
restores the stack pointer when the block is exited.

@item
@samp{save_stack_function} and @samp{restore_stack_function} do a
similar job for the outermost block of a function and are used when the
function allocates variable-sized objects or calls @code{alloca}.  Only
the epilogue uses the restored stack pointer, allowing a simpler save or
restore sequence on some machines.

@item
@samp{save_stack_nonlocal} is used in functions that contain labels
branched to by nested functions.  It saves the stack pointer in such a
way that the inner function can use @samp{restore_stack_nonlocal} to
restore the stack pointer.  The compiler generates code to restore the
frame and argument pointer registers, but some machines require saving
and restoring additional data such as register window information or
stack backchains.  Place insns in these patterns to save and restore any
such required data.
@end enumerate

When saving the stack pointer, operand 0 is the save area and operand 1
is the stack pointer.  The mode used to allocate the save area defaults
to @code{Pmode} but you can override that choice by defining the
@code{STACK_SAVEAREA_MODE} macro (@pxref{Storage Layout}).  You must
specify an integral mode, or @code{VOIDmode} if no save area is needed
for a particular type of save (either because no save is needed or
because a machine-specific save area can be used).  Operand 0 is the
stack pointer and operand 1 is the save area for restore operations.  If
@samp{save_stack_block} is defined, operand 0 must not be
@code{VOIDmode} since these saves can be arbitrarily nested.

A save area is a @code{mem} that is at a constant offset from
@code{virtual_stack_vars_rtx} when the stack pointer is saved for use by
nonlocal gotos and a @code{reg} in the other two cases.

@cindex @code{allocate_stack} instruction pattern
@item @samp{allocate_stack}
Subtract (or add if @code{STACK_GROWS_DOWNWARD} is undefined) operand 1 from
the stack pointer to create space for dynamically allocated data.

Store the resultant pointer to this space into operand 0.  If you
are allocating space from the main stack, do this by emitting a
move insn to copy @code{virtual_stack_dynamic_rtx} to operand 0.
If you are allocating the space elsewhere, generate code to copy the
location of the space to operand 0.  In the latter case, you must
ensure this space gets freed when the corresponding space on the main
stack is free.

Do not define this pattern if all that must be done is the subtraction.
Some machines require other operations such as stack probes or
maintaining the back chain.  Define this pattern to emit those
operations in addition to updating the stack pointer.

@cindex @code{check_stack} instruction pattern
@item @samp{check_stack}
If stack checking (@pxref{Stack Checking}) cannot be done on your system by
probing the stack, define this pattern to perform the needed check and signal
an error if the stack has overflowed.  The single operand is the address in
the stack farthest from the current stack pointer that you need to validate.
Normally, on platforms where this pattern is needed, you would obtain the
stack limit from a global or thread-specific variable or register.

@cindex @code{probe_stack_address} instruction pattern
@item @samp{probe_stack_address}
If stack checking (@pxref{Stack Checking}) can be done on your system by
probing the stack but without the need to actually access it, define this
pattern and signal an error if the stack has overflowed.  The single operand
is the memory address in the stack that needs to be probed.

@cindex @code{probe_stack} instruction pattern
@item @samp{probe_stack}
If stack checking (@pxref{Stack Checking}) can be done on your system by
probing the stack but doing it with a ``store zero'' instruction is not valid
or optimal, define this pattern to do the probing differently and signal an
error if the stack has overflowed.  The single operand is the memory reference
in the stack that needs to be probed.

@cindex @code{nonlocal_goto} instruction pattern
@item @samp{nonlocal_goto}
Emit code to generate a non-local goto, e.g., a jump from one function
to a label in an outer function.  This pattern has four arguments,
each representing a value to be used in the jump.  The first
argument is to be loaded into the frame pointer, the second is
the address to branch to (code to dispatch to the actual label),
the third is the address of a location where the stack is saved,
and the last is the address of the label, to be placed in the
location for the incoming static chain.

On most machines you need not define this pattern, since GCC will
already generate the correct code, which is to load the frame pointer
and static chain, restore the stack (using the
@samp{restore_stack_nonlocal} pattern, if defined), and jump indirectly
to the dispatcher.  You need only define this pattern if this code will
not work on your machine.

@cindex @code{nonlocal_goto_receiver} instruction pattern
@item @samp{nonlocal_goto_receiver}
This pattern, if defined, contains code needed at the target of a
nonlocal goto after the code already generated by GCC@.  You will not
normally need to define this pattern.  A typical reason why you might
need this pattern is if some value, such as a pointer to a global table,
must be restored when the frame pointer is restored.  Note that a nonlocal
goto only occurs within a unit-of-translation, so a global table pointer
that is shared by all functions of a given module need not be restored.
There are no arguments.

@cindex @code{exception_receiver} instruction pattern
@item @samp{exception_receiver}
This pattern, if defined, contains code needed at the site of an
exception handler that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored after control flow is branched to the handler of
an exception.  There are no arguments.

@cindex @code{builtin_setjmp_setup} instruction pattern
@item @samp{builtin_setjmp_setup}
This pattern, if defined, contains additional code needed to initialize
the @code{jmp_buf}.  You will not normally need to define this pattern.
A typical reason why you might need this pattern is if some value, such
as a pointer to a global table, must be restored.  Though it is
preferred that the pointer value be recalculated if possible (given the
address of a label for instance).  The single argument is a pointer to
the @code{jmp_buf}.  Note that the buffer is five words long and that
the first three are normally used by the generic mechanism.

@cindex @code{builtin_setjmp_receiver} instruction pattern
@item @samp{builtin_setjmp_receiver}
This pattern, if defined, contains code needed at the site of a
built-in setjmp that isn't needed at the site of a nonlocal goto.  You
will not normally need to define this pattern.  A typical reason why you
might need this pattern is if some value, such as a pointer to a global
table, must be restored.  It takes one argument, which is the label
to which builtin_longjmp transferred control; this pattern may be emitted
at a small offset from that label.

@cindex @code{builtin_longjmp} instruction pattern
@item @samp{builtin_longjmp}
This pattern, if defined, performs the entire action of the longjmp.
You will not normally need to define this pattern unless you also define
@code{builtin_setjmp_setup}.  The single argument is a pointer to the
@code{jmp_buf}.

@cindex @code{eh_return} instruction pattern
@item @samp{eh_return}
This pattern, if defined, affects the way @code{__builtin_eh_return},
and thence the call frame exception handling library routines, are
built.  It is intended to handle non-trivial actions needed along
the abnormal return path.

The address of the exception handler to which the function should return
is passed as operand to this pattern.  It will normally need to copied by
the pattern to some special register or memory location.
If the pattern needs to determine the location of the target call
frame in order to do so, it may use @code{EH_RETURN_STACKADJ_RTX},
if defined; it will have already been assigned.

If this pattern is not defined, the default action will be to simply
copy the return address to @code{EH_RETURN_HANDLER_RTX}.  Either
that macro or this pattern needs to be defined if call frame exception
handling is to be used.

@cindex @code{prologue} instruction pattern
@anchor{prologue instruction pattern}
@item @samp{prologue}
This pattern, if defined, emits RTL for entry to a function.  The function
entry is responsible for setting up the stack frame, initializing the frame
pointer register, saving callee saved registers, etc.

Using a prologue pattern is generally preferred over defining
@code{TARGET_ASM_FUNCTION_PROLOGUE} to emit assembly code for the prologue.

The @code{prologue} pattern is particularly useful for targets which perform
instruction scheduling.

@cindex @code{window_save} instruction pattern
@anchor{window_save instruction pattern}
@item @samp{window_save}
This pattern, if defined, emits RTL for a register window save.  It should
be defined if the target machine has register windows but the window events
are decoupled from calls to subroutines.  The canonical example is the SPARC
architecture.

@cindex @code{epilogue} instruction pattern
@anchor{epilogue instruction pattern}
@item @samp{epilogue}
This pattern emits RTL for exit from a function.  The function
exit is responsible for deallocating the stack frame, restoring callee saved
registers and emitting the return instruction.

Using an epilogue pattern is generally preferred over defining
@code{TARGET_ASM_FUNCTION_EPILOGUE} to emit assembly code for the epilogue.

The @code{epilogue} pattern is particularly useful for targets which perform
instruction scheduling or which have delay slots for their return instruction.

@cindex @code{sibcall_epilogue} instruction pattern
@item @samp{sibcall_epilogue}
This pattern, if defined, emits RTL for exit from a function without the final
branch back to the calling function.  This pattern will be emitted before any
sibling call (aka tail call) sites.

The @code{sibcall_epilogue} pattern must not clobber any arguments used for
parameter passing or any stack slots for arguments passed to the current
function.

@cindex @code{trap} instruction pattern
@item @samp{trap}
This pattern, if defined, signals an error, typically by causing some
kind of signal to be raised.  Among other places, it is used by the Java
front end to signal `invalid array index' exceptions.

@cindex @code{ctrap@var{MM}4} instruction pattern
@item @samp{ctrap@var{MM}4}
Conditional trap instruction.  Operand 0 is a piece of RTL which
performs a comparison, and operands 1 and 2 are the arms of the
comparison.  Operand 3 is the trap code, an integer.

A typical @code{ctrap} pattern looks like

@smallexample
(define_insn "ctrapsi4"
  [(trap_if (match_operator 0 "trap_operator"
             [(match_operand 1 "register_operand")
              (match_operand 2 "immediate_operand")])
            (match_operand 3 "const_int_operand" "i"))]
  ""
  "@dots{}")
@end smallexample

@cindex @code{prefetch} instruction pattern
@item @samp{prefetch}
This pattern, if defined, emits code for a non-faulting data prefetch
instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1
is a constant 1 if the prefetch is preparing for a write to the memory
address, or a constant 0 otherwise.  Operand 2 is the expected degree of
temporal locality of the data and is a value between 0 and 3, inclusive; 0
means that the data has no temporal locality, so it need not be left in the
cache after the access; 3 means that the data has a high degree of temporal
locality and should be left in all levels of cache possible;  1 and 2 mean,
respectively, a low or moderate degree of temporal locality.

Targets that do not support write prefetches or locality hints can ignore
the values of operands 1 and 2.

@cindex @code{blockage} instruction pattern
@item @samp{blockage}
This pattern defines a pseudo insn that prevents the instruction
scheduler and other passes from moving instructions and using register
equivalences across the boundary defined by the blockage insn.
This needs to be an UNSPEC_VOLATILE pattern or a volatile ASM.

@cindex @code{memory_barrier} instruction pattern
@item @samp{memory_barrier}
If the target memory model is not fully synchronous, then this pattern
should be defined to an instruction that orders both loads and stores
before the instruction with respect to loads and stores after the instruction.
This pattern has no operands.

@cindex @code{sync_compare_and_swap@var{mode}} instruction pattern
@item @samp{sync_compare_and_swap@var{mode}}
This pattern, if defined, emits code for an atomic compare-and-swap
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the ``old'' value to be compared against the
current contents of the memory location.  Operand 3 is the ``new'' value
to store in the memory if the compare succeeds.  Operand 0 is the result
of the operation; it should contain the contents of the memory
before the operation.  If the compare succeeds, this should obviously be
a copy of operand 2.

This pattern must show that both operand 0 and operand 1 are modified.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

For targets where the success or failure of the compare-and-swap
operation is available via the status flags, it is possible to
avoid a separate compare operation and issue the subsequent
branch or store-flag operation immediately after the compare-and-swap.
To this end, GCC will look for a @code{MODE_CC} set in the
output of @code{sync_compare_and_swap@var{mode}}; if the machine
description includes such a set, the target should also define special
@code{cbranchcc4} and/or @code{cstorecc4} instructions.  GCC will then
be able to take the destination of the @code{MODE_CC} set and pass it
to the @code{cbranchcc4} or @code{cstorecc4} pattern as the first
operand of the comparison (the second will be @code{(const_int 0)}).

For targets where the operating system may provide support for this
operation via library calls, the @code{sync_compare_and_swap_optab}
may be initialized to a function with the same interface as the
@code{__sync_val_compare_and_swap_@var{n}} built-in.  If the entire
set of @var{__sync} builtins are supported via library calls, the
target can initialize all of the optabs at once with
@code{init_sync_libfuncs}.
For the purposes of C++11 @code{std::atomic::is_lock_free}, it is
assumed that these library calls do @emph{not} use any kind of
interruptable locking.

@cindex @code{sync_add@var{mode}} instruction pattern
@cindex @code{sync_sub@var{mode}} instruction pattern
@cindex @code{sync_ior@var{mode}} instruction pattern
@cindex @code{sync_and@var{mode}} instruction pattern
@cindex @code{sync_xor@var{mode}} instruction pattern
@cindex @code{sync_nand@var{mode}} instruction pattern
@item @samp{sync_add@var{mode}}, @samp{sync_sub@var{mode}}
@itemx @samp{sync_ior@var{mode}}, @samp{sync_and@var{mode}}
@itemx @samp{sync_xor@var{mode}}, @samp{sync_nand@var{mode}}
These patterns emit code for an atomic operation on memory.
Operand 0 is the memory on which the atomic operation is performed.
Operand 1 is the second operand to the binary operator.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

@cindex @code{sync_old_add@var{mode}} instruction pattern
@cindex @code{sync_old_sub@var{mode}} instruction pattern
@cindex @code{sync_old_ior@var{mode}} instruction pattern
@cindex @code{sync_old_and@var{mode}} instruction pattern
@cindex @code{sync_old_xor@var{mode}} instruction pattern
@cindex @code{sync_old_nand@var{mode}} instruction pattern
@item @samp{sync_old_add@var{mode}}, @samp{sync_old_sub@var{mode}}
@itemx @samp{sync_old_ior@var{mode}}, @samp{sync_old_and@var{mode}}
@itemx @samp{sync_old_xor@var{mode}}, @samp{sync_old_nand@var{mode}}
These patterns emit code for an atomic operation on memory,
and return the value that the memory contained before the operation.
Operand 0 is the result value, operand 1 is the memory on which the
atomic operation is performed, and operand 2 is the second operand
to the binary operator.

This pattern must issue any memory barrier instructions such that all
memory operations before the atomic operation occur before the atomic
operation and all memory operations after the atomic operation occur
after the atomic operation.

If these patterns are not defined, the operation will be constructed
from a compare-and-swap operation, if defined.

@cindex @code{sync_new_add@var{mode}} instruction pattern
@cindex @code{sync_new_sub@var{mode}} instruction pattern
@cindex @code{sync_new_ior@var{mode}} instruction pattern
@cindex @code{sync_new_and@var{mode}} instruction pattern
@cindex @code{sync_new_xor@var{mode}} instruction pattern
@cindex @code{sync_new_nand@var{mode}} instruction pattern
@item @samp{sync_new_add@var{mode}}, @samp{sync_new_sub@var{mode}}
@itemx @samp{sync_new_ior@var{mode}}, @samp{sync_new_and@var{mode}}
@itemx @samp{sync_new_xor@var{mode}}, @samp{sync_new_nand@var{mode}}
These patterns are like their @code{sync_old_@var{op}} counterparts,
except that they return the value that exists in the memory location
after the operation, rather than before the operation.

@cindex @code{sync_lock_test_and_set@var{mode}} instruction pattern
@item @samp{sync_lock_test_and_set@var{mode}}
This pattern takes two forms, based on the capabilities of the target.
In either case, operand 0 is the result of the operand, operand 1 is
the memory on which the atomic operation is performed, and operand 2
is the value to set in the lock.

In the ideal case, this operation is an atomic exchange operation, in
which the previous value in memory operand is copied into the result
operand, and the value operand is stored in the memory operand.

For less capable targets, any value operand that is not the constant 1
should be rejected with @code{FAIL}.  In this case the target may use
an atomic test-and-set bit operation.  The result operand should contain
1 if the bit was previously set and 0 if the bit was previously clear.
The true contents of the memory operand are implementation defined.

This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as an acquire barrier, that is all memory
operations after the pattern do not occur until the lock is acquired.

If this pattern is not defined, the operation will be constructed from
a compare-and-swap operation, if defined.

@cindex @code{sync_lock_release@var{mode}} instruction pattern
@item @samp{sync_lock_release@var{mode}}
This pattern, if defined, releases a lock set by
@code{sync_lock_test_and_set@var{mode}}.  Operand 0 is the memory
that contains the lock; operand 1 is the value to store in the lock.

If the target doesn't implement full semantics for
@code{sync_lock_test_and_set@var{mode}}, any value operand which is not
the constant 0 should be rejected with @code{FAIL}, and the true contents
of the memory operand are implementation defined.

This pattern must issue any memory barrier instructions such that the
pattern as a whole acts as a release barrier, that is the lock is
released only after all previous memory operations have completed.

If this pattern is not defined, then a @code{memory_barrier} pattern
will be emitted, followed by a store of the value to the memory operand.

@cindex @code{atomic_compare_and_swap@var{mode}} instruction pattern
@item @samp{atomic_compare_and_swap@var{mode}} 
This pattern, if defined, emits code for an atomic compare-and-swap
operation with memory model semantics.  Operand 2 is the memory on which
the atomic operation is performed.  Operand 0 is an output operand which
is set to true or false based on whether the operation succeeded.  Operand
1 is an output operand which is set to the contents of the memory before
the operation was attempted.  Operand 3 is the value that is expected to
be in memory.  Operand 4 is the value to put in memory if the expected
value is found there.  Operand 5 is set to 1 if this compare and swap is to
be treated as a weak operation.  Operand 6 is the memory model to be used
if the operation is a success.  Operand 7 is the memory model to be used
if the operation fails.

If memory referred to in operand 2 contains the value in operand 3, then
operand 4 is stored in memory pointed to by operand 2 and fencing based on
the memory model in operand 6 is issued.  

If memory referred to in operand 2 does not contain the value in operand 3,
then fencing based on the memory model in operand 7 is issued.

If a target does not support weak compare-and-swap operations, or the port
elects not to implement weak operations, the argument in operand 5 can be
ignored.  Note a strong implementation must be provided.

If this pattern is not provided, the @code{__atomic_compare_exchange}
built-in functions will utilize the legacy @code{sync_compare_and_swap}
pattern with an @code{__ATOMIC_SEQ_CST} memory model.

@cindex @code{atomic_load@var{mode}} instruction pattern
@item @samp{atomic_load@var{mode}}
This pattern implements an atomic load operation with memory model
semantics.  Operand 1 is the memory address being loaded from.  Operand 0
is the result of the load.  Operand 2 is the memory model to be used for
the load operation.

If not present, the @code{__atomic_load} built-in function will either
resort to a normal load with memory barriers, or a compare-and-swap
operation if a normal load would not be atomic.

@cindex @code{atomic_store@var{mode}} instruction pattern
@item @samp{atomic_store@var{mode}}
This pattern implements an atomic store operation with memory model
semantics.  Operand 0 is the memory address being stored to.  Operand 1
is the value to be written.  Operand 2 is the memory model to be used for
the operation.

If not present, the @code{__atomic_store} built-in function will attempt to
perform a normal store and surround it with any required memory fences.  If
the store would not be atomic, then an @code{__atomic_exchange} is
attempted with the result being ignored.

@cindex @code{atomic_exchange@var{mode}} instruction pattern
@item @samp{atomic_exchange@var{mode}}
This pattern implements an atomic exchange operation with memory model
semantics.  Operand 1 is the memory location the operation is performed on.
Operand 0 is an output operand which is set to the original value contained
in the memory pointed to by operand 1.  Operand 2 is the value to be
stored.  Operand 3 is the memory model to be used.

If this pattern is not present, the built-in function
@code{__atomic_exchange} will attempt to preform the operation with a
compare and swap loop.

@cindex @code{atomic_add@var{mode}} instruction pattern
@cindex @code{atomic_sub@var{mode}} instruction pattern
@cindex @code{atomic_or@var{mode}} instruction pattern
@cindex @code{atomic_and@var{mode}} instruction pattern
@cindex @code{atomic_xor@var{mode}} instruction pattern
@cindex @code{atomic_nand@var{mode}} instruction pattern
@item @samp{atomic_add@var{mode}}, @samp{atomic_sub@var{mode}}
@itemx @samp{atomic_or@var{mode}}, @samp{atomic_and@var{mode}}
@itemx @samp{atomic_xor@var{mode}}, @samp{atomic_nand@var{mode}}
These patterns emit code for an atomic operation on memory with memory
model semantics. Operand 0 is the memory on which the atomic operation is
performed.  Operand 1 is the second operand to the binary operator.
Operand 2 is the memory model to be used by the operation.

If these patterns are not defined, attempts will be made to use legacy
@code{sync} patterns, or equivalent patterns which return a result.  If
none of these are available a compare-and-swap loop will be used.

@cindex @code{atomic_fetch_add@var{mode}} instruction pattern
@cindex @code{atomic_fetch_sub@var{mode}} instruction pattern
@cindex @code{atomic_fetch_or@var{mode}} instruction pattern
@cindex @code{atomic_fetch_and@var{mode}} instruction pattern
@cindex @code{atomic_fetch_xor@var{mode}} instruction pattern
@cindex @code{atomic_fetch_nand@var{mode}} instruction pattern
@item @samp{atomic_fetch_add@var{mode}}, @samp{atomic_fetch_sub@var{mode}}
@itemx @samp{atomic_fetch_or@var{mode}}, @samp{atomic_fetch_and@var{mode}}
@itemx @samp{atomic_fetch_xor@var{mode}}, @samp{atomic_fetch_nand@var{mode}}
These patterns emit code for an atomic operation on memory with memory
model semantics, and return the original value. Operand 0 is an output 
operand which contains the value of the memory location before the 
operation was performed.  Operand 1 is the memory on which the atomic 
operation is performed.  Operand 2 is the second operand to the binary
operator.  Operand 3 is the memory model to be used by the operation.

If these patterns are not defined, attempts will be made to use legacy
@code{sync} patterns.  If none of these are available a compare-and-swap
loop will be used.

@cindex @code{atomic_add_fetch@var{mode}} instruction pattern
@cindex @code{atomic_sub_fetch@var{mode}} instruction pattern
@cindex @code{atomic_or_fetch@var{mode}} instruction pattern
@cindex @code{atomic_and_fetch@var{mode}} instruction pattern
@cindex @code{atomic_xor_fetch@var{mode}} instruction pattern
@cindex @code{atomic_nand_fetch@var{mode}} instruction pattern
@item @samp{atomic_add_fetch@var{mode}}, @samp{atomic_sub_fetch@var{mode}}
@itemx @samp{atomic_or_fetch@var{mode}}, @samp{atomic_and_fetch@var{mode}}
@itemx @samp{atomic_xor_fetch@var{mode}}, @samp{atomic_nand_fetch@var{mode}}
These patterns emit code for an atomic operation on memory with memory
model semantics and return the result after the operation is performed.
Operand 0 is an output operand which contains the value after the
operation.  Operand 1 is the memory on which the atomic operation is
performed.  Operand 2 is the second operand to the binary operator.
Operand 3 is the memory model to be used by the operation.

If these patterns are not defined, attempts will be made to use legacy
@code{sync} patterns, or equivalent patterns which return the result before
the operation followed by the arithmetic operation required to produce the
result.  If none of these are available a compare-and-swap loop will be
used.

@cindex @code{atomic_test_and_set} instruction pattern
@item @samp{atomic_test_and_set}
This pattern emits code for @code{__builtin_atomic_test_and_set}.
Operand 0 is an output operand which is set to true if the previous
previous contents of the byte was "set", and false otherwise.  Operand 1
is the @code{QImode} memory to be modified.  Operand 2 is the memory
model to be used.

The specific value that defines "set" is implementation defined, and
is normally based on what is performed by the native atomic test and set
instruction.

@cindex @code{mem_thread_fence@var{mode}} instruction pattern
@item @samp{mem_thread_fence@var{mode}}
This pattern emits code required to implement a thread fence with
memory model semantics.  Operand 0 is the memory model to be used.

If this pattern is not specified, all memory models except
@code{__ATOMIC_RELAXED} will result in issuing a @code{sync_synchronize}
barrier pattern.

@cindex @code{mem_signal_fence@var{mode}} instruction pattern
@item @samp{mem_signal_fence@var{mode}}
This pattern emits code required to implement a signal fence with
memory model semantics.  Operand 0 is the memory model to be used.

This pattern should impact the compiler optimizers the same way that
mem_signal_fence does, but it does not need to issue any barrier
instructions.

If this pattern is not specified, all memory models except
@code{__ATOMIC_RELAXED} will result in issuing a @code{sync_synchronize}
barrier pattern.

@cindex @code{get_thread_pointer@var{mode}} instruction pattern
@cindex @code{set_thread_pointer@var{mode}} instruction pattern
@item @samp{get_thread_pointer@var{mode}}
@itemx @samp{set_thread_pointer@var{mode}}
These patterns emit code that reads/sets the TLS thread pointer. Currently,
these are only needed if the target needs to support the
@code{__builtin_thread_pointer} and @code{__builtin_set_thread_pointer}
builtins.

The get/set patterns have a single output/input operand respectively,
with @var{mode} intended to be @code{Pmode}.

@cindex @code{stack_protect_set} instruction pattern
@item @samp{stack_protect_set}
This pattern, if defined, moves a @code{ptr_mode} value from the memory
in operand 1 to the memory in operand 0 without leaving the value in
a register afterward.  This is to avoid leaking the value some place
that an attacker might use to rewrite the stack guard slot after
having clobbered it.

If this pattern is not defined, then a plain move pattern is generated.

@cindex @code{stack_protect_test} instruction pattern
@item @samp{stack_protect_test}
This pattern, if defined, compares a @code{ptr_mode} value from the
memory in operand 1 with the memory in operand 0 without leaving the
value in a register afterward and branches to operand 2 if the values
were equal.

If this pattern is not defined, then a plain compare pattern and
conditional branch pattern is used.

@cindex @code{clear_cache} instruction pattern
@item @samp{clear_cache}
This pattern, if defined, flushes the instruction cache for a region of
memory.  The region is bounded to by the Pmode pointers in operand 0
inclusive and operand 1 exclusive.

If this pattern is not defined, a call to the library function
@code{__clear_cache} is used.

@end table

@end ifset
@c Each of the following nodes are wrapped in separate
@c "@ifset INTERNALS" to work around memory limits for the default
@c configuration in older tetex distributions.  Known to not work:
@c tetex-1.0.7, known to work: tetex-2.0.2.
@ifset INTERNALS
@node Pattern Ordering
@section When the Order of Patterns Matters
@cindex Pattern Ordering
@cindex Ordering of Patterns

ある insn が複数の命令パターンにマッチ可能なことが時々ある。
その時は、マシン記述に最初に現れるパターンが使われる。
このため、より限定されるパターン(マッチするものがより少ないパターン)や
より高速のパターン(マッチしたときにより良いコードを生成するパターン)を
通常はマシン記述で先に置くべきである。

場合によっては、パターンの順番の効果を使って、有効でないパターンを
隠すこともできる。
例えば、68000 は、フルワードを浮動小数点に変換する命令と
もう一つ別のバイトを浮動小数点に変換する命令を持っている。
整数を浮動小数点に変換する命令はどちらにもマッチし得る。
我々は、フルワードを変換するパターンを先において、バイトを変換する
パターンではなくてフルワードを変換する方が使われることを保証している。
(そうしないと、大きな整数が一バイトの即値量として生成されてしまい、
動作しなくなる。)
このパターンの順序を使う代わりに、バイトを変換するパターンを
任意の定数値を適切に扱えるように賢いものにすることも可能である。

@end ifset
@ifset INTERNALS
@node Dependent Patterns
@section Interdependence of Patterns
@cindex Dependent Patterns
@cindex Interdependence of Patterns

どのマシン記述でも、条件分岐名 @samp{b@var{cond}} のそれぞれに
ついて名前付きパターンがなければならない。
この場合、許されるテンプレートは常に以下の形でなければならない。

@example
(set (pc)
     (if_then_else (@var{cond} (cc0) (const_int 0))
                   (label_ref (match_operand 0 "" ""))
                   (pc)))
@end example

@noindent
さらに、どのマシン記述でも、条件を逆にした分岐毎に名無しのパターンが
なければならない。
テンプレートは以下の形となる。

@example
(set (pc)
     (if_then_else (@var{cond} (cc0) (const_int 0))
                   (pc)
                   (label_ref (match_operand 0 "" ""))))
@end example

@noindent
これらが必要なのは、ジャンプ最適化で順条件分岐が逆条件分岐に
変換されることがあるためである。

@code{match_operator} を使って、分岐に対し指定しなければならない
パターンの数を押さえるということを良く行なう。
例えば、以下のようにする。

@smallexample
(define_insn ""
  [(set (pc)
        (if_then_else (match_operator 0 "comparison_operator"
                                      [(cc0) (const_int 0)])
                      (pc)
                      (label_ref (match_operand 1 "" ""))))]
  "@var{condition}"
  "@dots{}")
@end smallexample

場合によっては、一個以上のオペランドのマシンモードを除けば同じになる命令を
サポートしている機種がある。例えば、
``sign-extend halfword'' と ``sign-extend byte'' という命令があり、
そのパターンは以下のようになる。

@smallexample
(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:HI 1 @dots{})))

(set (match_operand:SI 0 @dots{})
     (extend:SI (match_operand:QI 1 @dots{})))
@end smallexample

@noindent
整数定数はマシンモードを指定しないので、定数値を拡張する命令は
どちらのパターンにもマッチし得る。
実際にマッチするパターンは、ファイルで先に現れたものになる。
正しい結果を得るためには、先に置くのは最も幅の広いモード(ここでは 
@code{HImode}) のものでなければならない。
パターンが @code{QImode} の命令にマッチした場合、
定数値がこのモードに実際に収まらない場合は正しくない結果になる。

定数を拡張するような命令は最適化の際になくなるので、滅多に生成される
ことはないが、最適化をしないコンパイルでは時々出てくる。

あるパターンのある制約が定数を許すなら、再ロードパスが、いくつかのケースの
制約で許されているなら、レジスタを定数で置き換える可能性がある。
メモリ参照についても同様である。
この置き換えがあるので、インクリメントとデクリメント命令に別々の
パターンを与えるべきではない。
代わりに、同一のパターンから生成されるようにする必要がある。
このパターンは、オペランドを調べて適切な機械命令を生成するような
レジスタ同士の加算 insn をサポートする必要がある。

@end ifset
@ifset INTERNALS
@node Jump Patterns
@section Defining Jump Instruction Patterns
@cindex jump instruction patterns
@cindex defining jump instruction patterns

ほとんどの機種について、GNU CC は、その機種に条件コードがあることを
想定している。比較 insn が条件コードを設定し、与えられたオペランドに
ついての、符号付き比較と符号なし比較の両方の結果を記録する。
それとは別の分岐 insn が、条件コードをテストし、その値にしたがって
分岐したり、しなかったりする。
分岐 insn は、符号付きと符号無しでは違ってくる。
良く知られた機種、例えば、Vax や 68000、32000 等はこのように
動作する。

機種によっては、符号付きと符号なしで別の比較命令を持っているが、
条件分岐命令は、どちらか一方向けのセットしかないというものがある。
こういう機種を扱うのに一番簡単な方法は、アセンブリコードが書き出される
最後の段階までは、それ以外の機種と全く同じように扱うことである。
この最後の段階で、比較命令用のコードを出力するときに、
@code{next_cc0_user (insn)} を使って後続の分岐を先読みするのである。
(変数 @code{insn} は、ある命令パターンの出力を書き出すコードの中では、
出力中の insn を参照している。)
その RTL を見て、符号なし分岐であれば、符号なし比較を出力し、
さもなければ符号付き比較を出力する。その分岐自体を出力するときは、
符号付き分岐と符号なし分岐を全く同一に扱うことができる。

こんなことが可能なのは、GNU CC が連続する RTL insn の対を生成するからである。
間に @code{note} insn が入ってもよい。この対の一つは、条件コードを
設定し、もう一つがそれをテストする。GNU CC は、この対を最後まで
いじらないようにする。

この方法を取るには、マシン記述マクロ @code{NOTICE_UPDATE_CC} を
@code{CC_STATUS_INIT} を実行するように定義しなければならない。
言い換えると、余計な比較命令はない。

機種によっては比較-分岐命令はあるが、条件コードはないというものがある。
こういう機種についても同様の方法が使える。
比較命令を「出力」すべき時が来たら、そのオペランドを二つの静的変数に
記録する。次に続く「条件コードにより分岐」命令を出力するときは、
実際には記録したオペランドを使う、比較-分岐命令を出力する。

比較-分岐命令向けにパターンを定義するのでも良い。
最適化ありのコンパイルでは、比較命令と分岐命令の組をこのパターンに
従って組み合わせる。だが、これは最適化を要求しない場合は
行なわれない。このため、読者が定義するなんらかの特別なパターンに加えて、
上記の解決策の一つを取る必要がある。

RISC 機種の多くでは、条件コードに影響する命令はほとんどなく、
独立した条件コードレジスタさえないこともある。
こういう機種では、条件コードの定義と使用は連続した insn でなければ
ならないという制限は必要ないし、重要な最適化を妨げてしまう。
例えば、IBM RS/6000 では、条件コードレジスタが条件分岐の
三つ前の命令で設定されていない限り、成立した分岐に対して遅延が
生じる。
条件コードレジスタの定義と使い方を分離することが許されていないと、
命令スケジューラは、この最適化を行なうことができない。

こういう機種では、@code{(cc0)} を使わず、代わりに
条件コードを表すレジスタを使うこと。専用の条件コードレジスタが
存在する場合には、ハードレジスタを使うこと。
条件コードや比較の結果をどの汎用レジスタにでも置くことが出来るのなら、
あるいは条件コードレジスタが複数あるなら、疑似レジスタを使うこと。

@findex prev_cc0_setter
@findex next_cc0_user
機種によっては、生成される分岐命令のタイプは条件コードの生成のされ方に
依存する。例えば、68k と SPARC では、加算命令や減算命令で
直接的に条件コードを設定すると、テスト命令が行なうような、オーバフロー
ビットのクリアを行なわないので、ある種の条件分岐に対しては
異なる分岐命令を使う必要がある。@code{(cc0)} を使う機種では、
条件コードの設定と使用は、連続して置かなければならず(間に
置いて良いのは @code{note} insn だけ)、@code{cc_status} 中のフラグを
使えるようにしなければならない。(@xref{Condition Code}。)
また、比較 insn と分岐 insn は、関数 @code{prev_cc0_setter} と
@code{next_cc0_user} によってお互いを見つけることができる。

だが、@code{(cc0)} を使わない機種ではこの事は正しくない。
@code{(cc0)} を使わない機種では、比較 insn と分岐 insn が連続しているという
仮定を置くことは出来ず、上記の方法は使えない。
代わりに、条件コードレジスタのマシンモードを使って、条件コードレジスタの
異なる形式を記録するようにする。

条件コードの値をストアするのに使うレジスタのモードは、クラス @code{MODE_CC}
のモードでなければならない。普通は、@code{CCmode} になる。
他にモードが必要になる場合は(上で述べた、Sparc の add の例について言えば)、
マクロ @code{EXTRA_CC_MODES} を
定義して、追加で必要なモードを列挙する(@pxref{Condition Code})。
また、@code{EXTRA_CC_NAMES} を定義して、追加するモードの名前を列挙し、
@code{SELECT_CC_MODE} を定義して、比較のオペランドに与えられたモードを
選択するようにする。

RTL 生成の間、異なるモードが必要な事が判っている場合
(例えば、IBM のほとんどのプロセッサのように、符号付きと符号なしで
別々の比較命令を持っている機種の場合である)、RTL 生成時に
指定することができる。

異なるモードが要求されるのが、命令組合せにより発生する場合は、
マクロ @code{SELECT_CC_MODE} が比較の結果に対してどのマシンモードを
使うべきかを決定する。そのパターンはこのモードを使って書く必要がある。
上で議論した SPARC での加算の場合を考えると、パターンを以下のように
する必要がある。

@smallexample
(define_insn ""
  [(set (reg:CC_NOOV 0)
        (compare:CC_NOOV
          (plus:SI (match_operand:SI 0 "register_operand" "%r")
                   (match_operand:SI 1 "arith_operand" "rI"))
          (const_int 0)))]
  ""
  "@dots{}")
@end smallexample

SPARC での @code{SELECT_CC_MODE} マクロは、引数が @code{plus} である
比較に対しては @code{CC_NOOVmode} を返す。

@end ifset
@ifset INTERNALS
@node Insn Canonicalizations
@section Canonicalization of Instructions
@cindex canonicalization of instructions
@cindex insn canonicalization

複数の RTL 式がある一個の機械命令で実行される演算を表す場合が良くある。
これは、論理命令、分岐命令、積和命令で良くあることである。
そういう場合、コンパイラは複数の RTL 式を一個の正規形に変換して、
必要とする insn パターンの数を減らそうとする。

代数的な単純化に加えて、以下の正規化が行なわれる。

@itemize @bullet
@item
交換可能な比較演算の場合、定数は常に第二オペランドとなる。
定数を第二オペランドでしか使えない機種では、第二オペランドに定数が
くるパターンだけを提供すれば良い。

@cindex @code{neg}, canonicalization of
@cindex @code{not}, canonicalization of
@cindex @code{mult}, canonicalization of
@cindex @code{plus}, canonicalization of
@cindex @code{minus}, canonicalization of
以下の演算については、一方のオペランドだけが @code{neg}、@code{not}、
@code{mult}、@code{plus}、@code{minus} 式の場合、それは第一の
オペランドになる。

@cindex @code{compare}, canonicalization of
@item
@code{compare} 演算子の場合、@code{cc0} が使われる機種(@pxref{Jump Patterns})
では、定数は常に第二オペランドになる。それ以外の機種では、定数を
第一オペランドとする @code{compare} をコンパイラが作ろうとする
場合が希にある。だが、そういう場合は、実際にそういう機械命令が
ない限り、第一オペランドとして定数にマッチするパターンを用意する
価値があるほど多くはない。

@code{neg}、@code{not}、@code{mult}、@code{plus}、
@code{minus} のオペランドは、上と同じ条件下で第一オペランドになる。

@item
@code{(minus @var{x} (const_int @var{n}))} は
@code{(plus @var{x} (const_int @var{-n}))} に変換される。

@item
アドレスの計算の中で(すなわち、@code{mem} の中で)、左シフトは
適当な 2 の冪乗の乗算に変換される。

@cindex @code{ior}, canonicalization of
@cindex @code{and}, canonicalization of
@cindex De Morgan's law
@item
ド・モルガンの法則を使って、ビット毎の論理積や論理和の中にある
ビット毎の否定を移動する。この結果、一個のオペランドだけが
@code{not} 式になった場合、それが先頭のオペランドになる。

一つのオペランドと、もう一方のオペランドのビット毎の否定のビット毎の論理積を
実行する命令がある機種では、その命令用のパターンは以下のように指定すべき
である。

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (and:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (match_operand:@var{m} 2 @dots{})))]
  "@dots{}"
  "@dots{}")
@end smallexample

@noindent
同様に、``NAND'' 命令用のパターンは以下のように書くべきである。

@smallexample
(define_insn ""
  [(set (match_operand:@var{m} 0 @dots{})
        (ior:@var{m} (not:@var{m} (match_operand:@var{m} 1 @dots{}))
                     (not:@var{m} (match_operand:@var{m} 2 @dots{}))))]
  "@dots{}"
  "@dots{}")
@end smallexample

どちらの場合にも、たくさんある論理的に等価な RTL 式に対するパターンを
含める必要はない。

@cindex @code{xor}, canonicalization of
@item
ビット毎の排他的論理和とビット毎の否定を両方含む RTL 式で
可能なものは、@code{(xor:@var{m} @var{x} @var{y})} と
@code{(not:@var{m} (xor:@var{m} @var{x} @var{y}))}
だけである。@refill

@item
三項の和で、その一つが定数であるものは、次の形にしか現れない。

@smallexample
(plus:@var{m} (plus:@var{m} @var{x} @var{y}) @var{constant})
@end smallexample

@item
@code{cc0} を使わない機種では、@code{(compare @var{x} (const_int 0))} は
@var{x} に変換される。@refill

@cindex @code{zero_extract}, canonicalization of
@cindex @code{sign_extract}, canonicalization of
@item
あるグループのビット(普通は一個のビット)がゼロに等しいかどうかの
比較は、等価な @code{and} や @code{sign_extract} 演算ではなくて、
@code{zero_extract} を使って書かれる。

@end itemize
@end ifset
@ifset INTERNALS
@node Expander Definitions
@section Defining RTL Sequences for Code Generation
@cindex expander definitions
@cindex code generation RTL sequences
@cindex defining RTL sequences for code generation

機種によっては、RTL 生成用の標準のパターン名を一個の insn では
扱えないが、RTL insn の列なら表現できるという場合がある。
そのようなターゲット機種の場合は、@code{define_expand} を
書くことでその RTL 列を生成する方法を指定することができる。

@findex define_expand
@code{define_expand} は、ある一個の RTL 式であり、
ほぼ @code{define_insn} と同じである。
しかし、@code{define_expand} は、@code{define_insn} と違って、
RTL 生成にのみ使われ、一個以上の RTL insn を生成することができる。

@code{define_expand} RTX にはオペランドが4つある。

@itemize @bullet
@item
名前。各 @code{define_expand} には名前がなければならない。
何故なら、名前で参照するのが唯一の使い方だからである。

@findex define_peephole
@item
RTL テンプレート。これは、ちょうど @code{define_peephole} の
RTL テンプレートと同じであり、それぞれが一個の insn である
RTL 式のベクトルになっている。

@item
条件。C の式を一個含む一個の文字列である。
この式を使って、このパターンの利用可能性がどのようにターゲット機種の
サブクラスに依存するかを表す。このサブクラスは、GNU CC の実行時に
コマンド行オプションにより選択されるものである。
これは、標準名を持つ @code{define_insn} の条件と同じである。
このため、条件がもしあるなら、一致する insn 中のデータに
依存してはならない。ターゲット機種タイプのフラグにしか依存しては
ならないのである。GNU CC は、初期化を行なっている際にこれらの
条件をテストする必要がある。これは、コンパイラの一回実行する毎に、
名前付き命令で利用可能なものはどれかを正確に知る必要があるからである。

@item
準備文。一個の文字列であり、ゼロ個以上の C の文を含む。
これらの文は、RTL テンプレートから RTL コードが生成される前に
実行される。

普通これらの文は、RTL テンプレート中の内部的なオペランドとして
使われる一時レジスタを用意するが、@code{emit_insn} 等のルーチンを
呼び出すことで RTL insn を直接生成することもできる。
そうやって生成した insn は、RTL テンプレートから来る insn の前に
置かなければならない。
@end itemize

@code{define_expand} により生成されるRTL insn はどれも、マシン記述中の
@code{define_insn} のどれかにマッチしなければならない。
どれにもマッチしない場合、その insn 用のコードを生成しようとしたり、
最適化しようとしたときに異常終了してしまう。

RTL テンプレートは、RTL insn の生成を制御することに加えて、
このパターンが使われるときに指定する必要があるオペランドをも
記述する。
特に、各オペランドに述語を与える。

真のオペランドは、パターンから RTL を生成するために指定する必要があり、
RTL テンプレートの先頭に現れる @code{match_operand} で記述する
必要がある。これにより、オペランドの述語についての情報が、その手の情報を
記録する表に入力される。GNU CC はこの情報を使って、正しい RTL コードとして
必要なら、オペランドをレジスタに事前ロードする。
このオペランドが複数回参照されているなら、それ以降で参照するときは
@code{match_dup} を使う必要がある。

RTL テンプレートは、内部「オペランド」も参照する。
内部オペランドとは、一時レジスタやラベルであり、@code{define_expand} で
作られる列の中でしか使われない。内部オペランドは、@code{match_dup} に
より RTL テンプレートに代入される。@code{match_operand} で代入される
ことはない。内部オペランドの値は、GNU CC がこのパターンを使う必要が
あるときに引数として渡されることはない。代わりに、
準備文により、パターン内で計算が行なわれる。準備文は、
値を計算し、@code{operands} の適切な要素に格納するので、
@code{match_dup} がそれを見つけられるようになる。

準備文の中で使う特別なマクロが二つ定義されている。
@code{DONE} と @code{FAIL} である。これらは後ろにセミコロンを付けて
文として使うこと。

@table @code

@findex DONE
@item DONE
マクロ @code{DONE} を使って、このパターンに対する RTL 生成を終了させる。
この時にパターンから作られる RTL insn は、準備文の中で @code{emit_insn}
を明示的に呼び出すことによって既に出力済みのものだけになる。
RTL テンプレートは生成されない。

@findex FAIL
@item FAIL
パターンに対する照合を失敗させる。あるパターンが照合に失敗すると、
そのパターンが利用できないことを意味する。
GNU CC の呼びだし側ルーチンは、他のパターンを使って、コード生成の
別の戦略を試す。

失敗は、現在、二項演算(加算、乗算、シフト等)とビットフィールド演算
(@code{extv}、@code{extzv}、@code{insv})でのみ使える。
@end table

次の例は、SPUR チップの左シフトの定義である。

@smallexample
@group
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashift:SI
@end group
@group
          (match_operand:SI 1 "register_operand" "")
          (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "
@end group
@end smallexample

@smallexample
@group
@{
  if (GET_CODE (operands[2]) != CONST_INT
      || (unsigned) INTVAL (operands[2]) > 3)
    FAIL;
@}")
@end group
@end smallexample

@noindent
この例では、@code{define_expand} を使って、
シフト量がサポート範囲の 0 から 3 の間に収まっていればシフトを行なう
RTL insn を生成することができるようにしているが、機械命令が使えない
ようなそれ以外の場合には失敗するようにしている。
失敗した場合には、別のパターン(例えば、ライブラリ呼びだしなど)を使った
別の戦略を試みる。

GNU CC が、名前付きパターンの自明でない条件文字列を扱うことが
出来たなら、@code{define_insn} をその場合に使うことができる。
以下に、@code{define_expand} の威力をさらに利用する別の例(68000 での
ゼロ拡張である)を示す。

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "general_operand" "")
        (const_int 0))
   (set (strict_low_part
          (subreg:HI
            (match_dup 0)
            0))
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "operands[1] = make_safe_from (operands[1], operands[0]);")
@end smallexample

@noindent
@findex make_safe_from
ここでは二つの RTL insn が生成される。一つは出力オペランド全体を
クリアし、もう一つは入力オペランドを出力オペランドの下位半分に
コピーする。この insn 列は、入力オペランドが出力オペランド(の
古い値)を参照している場合は、正しくなくなる。
そのため、準備文でそうならないことを保証している。
関数 @code{make_safe_from} は、@code{operands[1]} が
@code{operands[0]} を参照していれば、@code{operands[1]} を
一時レジスタにコピーする。そのコピーは、もう一つの RTL insn を
生成することにより行なう。

最後に、三番目の例で内部オペランドの使い方を説明する。
SPUR チップのゼロ拡張は、結果を半語のマスクとの @code{and} を取ることで
行なわれる。
だが、このマスクは、定数値としては、この機種で正しいものになるには大きすぎて、
@code{const_int} では表現できない。このため、@code{force_reg} で
レジスタにコピーして、そのレジスタを @code{and} の中で使わなければ
ならない。

@smallexample
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
        (and:SI (subreg:SI
                  (match_operand:HI 1 "register_operand" "")
                  0)
                (match_dup 2)))]
  ""
  "operands[2]
     = force_reg (SImode, GEN_INT (65535)); ")
@end smallexample

@strong{注意:} @code{define_expand} を標準的な二項演算や単項演算、
あるいはビットフィールド演算に使うときは、それが最後に生成する insn は、
@code{code_label} や @code{barrier} や @code{note} であってはならない。
@code{insn} か @code{jump_insn} か @code{call_insn} でなくてはならない。
最後に実際の insn を置く必要がなければ、演算の結果を自分自身にコピーする
insn を生成する。そういう insn はコードはなんら生成しないが、
GCC に問題が起きるのを回避する。

@end ifset
@ifset INTERNALS
@node Insn Splitting
@section Defining How to Split Instructions
@cindex insn splitting
@cindex instruction splitting
@cindex splitting instructions

あるパターンを複数の insn に分割する方法を指定しなければならない場合が
二つある。遅延スロット(@pxref{Delay Slots})を必要とする命令や
出力が複数サイクルの間利用できない命令(@pxref{Function Units})を
持つ機種では、これらのケースを最適化するコンパイラフェーズでは、
insn を一つの命令の遅延スロットに移動できる必要がある。しかし、
insn の中には複数の機械命令を生成するものもある。そういう insn は
遅延スロットに置くことはできない。

一個の insn を個々の insn のリストに書き直せることが多い。
この場合、個々の insn はそれぞれ一個の機械命令に対応する。
こうすると不利な点は、コンパイルが遅くなり、必要とするメモリスペースが
多くなることである。書き換え後の insn が複雑過ぎると、そのために
いくつかの最適化を妨げることにもなる。命令スケジューリングまたは
遅延スロットスケジューリングが改善されると信じる根拠がある場合は、
コンパイラは insn を分割する。

insn の組合せフェーズでは、交換可能な insn の分割も行なう。
三つの insn が複雑な式の一つの insn に統合されたものの、
なんらかの @code{define_insn} パターンにマッチすることが
不可能になった場合、組合せフェーズは複雑なパターンを認識できる
二つの insn に分割しようとする。普通は、複雑なパターンを
いくつかの部分式に分割することで二つのパターンに分ける。
だが、場合によっては、RISC 機種で、ある大きな定数の加算を二つの insn で
行なうような場合、その加算を二つの insn に分割する方法は
機種依存である。

@cindex define_split
@code{define_split} の定義で、GNU CC に対し、複雑な insn をいくつかの
もっと単純な insn に分割する方法を指定する。

@smallexample
(define_split
  [@var{insn-pattern}]
  "@var{condition}"
  [@var{new-insn-pattern-1}
   @var{new-insn-pattern-2}
   @dots{}]
  "@var{preparation statements}")
@end smallexample

@var{insn-pattern} は、分割する必要のあるパターンであり、
@var{condtion} は @code{define_insn} の場合と同様、
最後にテストされる条件である。@var{insn-pattern} にマッチし、
@var{condition} を満たす insn が見つかると、
その insn は、insn のリストの中で、@var{new-insn-pattern-1}、
@var{new-insn-pattern-2} 等で与えられるinsn に置き換えられる。

@var{preparation statements} は、@code{define_expand} (
@pxref{Expander Definitions})で指定される文と同様のもので、
生成されるコードの準備をしたり、パターンが固定していない insn を
いくつか生成したりするために、新しい RTL が生成される前に実行される。
ただし、@code{define_expand} にあるものと違って、これらの文は
疑似レジスタを新たに生成してはならない。
また、再ロードが一度完了したら、スタックフレームからスペースを
割り当ててはならない。

パターンが @var{insn-pattern} とマッチするのには、二つの異なる状況がある。
ある insn が遅延スロットスケジューリングや命令スケジューリング向けに
分割する必要がある場合は、その insn は有効であることが既に知られている。
この事は、何かの @code{define_insn} にマッチしていなければならず、
@code{reload_completed} がゼロでなければ、その @code{define_insn} の
制約を満たすことが知られているということを意味する。その場合、
新しい insn パターンも何かの @code{define_insn} にマッチしなければならず、
@code{reload_completed} がゼロでなければ、その定義の制約を満たさなければ
ならない。

この @code{define_split} の使い方の例として、@file{a29k.md} から
取った以下の例を考えてみる。この例では、@code{HImode} から @code{SImode}
への @code{sign_extend} を二つのシフト insn の対に分割している。

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
  ""
  [(set (match_dup 0)
        (ashift:SI (match_dup 1)
                   (const_int 16)))
   (set (match_dup 0)
        (ashiftrt:SI (match_dup 0)
                     (const_int 16)))]
  "
@{ operands[1] = gen_lowpart (SImode, operands[1]); @}")
@end smallexample

命令組合せ過程が insn パターンを分割しようとするのは、いつでも、
そのパターンがどの @code{define_insn} にもマッチ@emph{しない}場合
である。組合せ過程は、最初に一個の @code{set} 式を分割しようとし、
次に @code{parallel} の中にあるが、スクラッチレジスタとして使うための
疑似レジスタの @code{clobber} が後ろに続くような、同じ @code{set} 式を
分割する。
これらの場合、組合せ過程は、新しい insn パターンがちょうど二つ
生成されることを想定する。組合せ過程がこれらのパターンが
なんらかの @code{define_insn} による定義にマッチするかどうかを
検査するので、読者が自分で @code{define_split} の中でこの検査を
行なう必要はない(当たり前だが、マッチする insn を決して
生成しないように @code{define_split} を書くのは意味がない)。

以下に @code{define_split} のこの使い方の例を示す。@file{rs6000.md}
から取ったものである。

@smallexample
(define_split
  [(set (match_operand:SI 0 "gen_reg_operand" "")
        (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                 (match_operand:SI 2 "non_add_cint_operand" "")))]
  ""
  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
"
@{
  int low = INTVAL (operands[2]) & 0xffff;
  int high = (unsigned) INTVAL (operands[2]) >> 16;

  if (low & 0x8000)
    high++, low |= 0xffff0000;

  operands[3] = GEN_INT (high << 16);
  operands[4] = GEN_INT (low);
@}")
@end smallexample

ここで述語 @code{non_add_cint_operand} は、一個の加算 insn の有効な
オペランド@emph{ではない} @code{const_int} にマッチする。
小さな変位付きの加算は、次の演算のアドレスに代入できるように
書かれる。

同じファイルから、スクラッチレジスタの使い方の例を見てみる。
この例では、レジスタと大きな定数の等値性比較を生成している。

@smallexample
(define_split
  [(set (match_operand:CC 0 "cc_reg_operand" "")
        (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                    (match_operand:SI 2 "non_short_cint_operand" "")))
   (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
  "find_single_use (operands[0], insn, 0)
   && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
       || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
  [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
   (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
  "
@{
  /* @r{Get the constant we are comparing against, C, and see what it
     looks like sign-extended to 16 bits.  Then see what constant
     could be XOR'ed with C to get the sign-extended value.}  */

  int c = INTVAL (operands[2]);
  int sextc = (c << 16) >> 16;
  int xorv = c ^ sextc;

  operands[4] = GEN_INT (xorv);
  operands[5] = GEN_INT (sextc);
@}")
@end smallexample

混乱を避けるために、一個の @code{define_split} を、ある @code{define_insn}
にマッチする insn とマッチしない insn を同じように受け付けるように
書いてはならない。代わりに、二つの @code{define_split} を
別々に書いて、一つを有効な insn 用とし他方を有効でない insn 用とすること。

@end ifset
@ifset INTERNALS
@node Peephole Definitions
@section Machine-Specific Peephole Optimizers
@cindex peephole optimizer definitions
@cindex defining peephole optimizers

命令パターンに加えて、ファイル @file{md} には、
機種固有の覗き穴最適化の定義を書いても良い。

組合せフェーズが、特定の覗き穴最適化に気付かないときがある。
それはどういう時かというと、プログラムのデータの流れを見ても、
その覗き穴最適化を試すべきであるということが判らない時である。
例えば、二つの連続する insn の目的が関係している場合は、
二番目の insn が最初の insn で計算したレジスタを使わないように
見える場合でも、組合せが行なえることがある。
機種固有の覗き穴最適化器はそのような機会を検出する。

@need 1000
A definition looks like this:

@smallexample
(define_peephole
  [@var{insn-pattern-1}
   @var{insn-pattern-2}
   @dots{}]
  "@var{condition}"
  "@var{template}"
  "@var{optional-insn-attributes}")
@end smallexample

@noindent
最後の文字列オペランドは、マシン記述で機種固有の情報をなんら使っていない
のなら、省略可能である。省略しない場合は、@code{define_insn} と
同じ規則に従わなければならない。

このスケルトンでは、@var{insn-pattern-1} 等は連続する insn のマッチすべき
パターンである。@var{insn-pattern-1} が insn 列の先頭のものに、
@var{insn-pattern-2} がその次に、という具合にマッチするなら、
その insn 列に最適化が適用される。

覗き穴によりマッチする各 insn は @code{define_insn} にもマッチしなければ
ならない。覗き穴はコード生成の直前の最終段階でしか検査されない。
このため、覗き穴にはマッチするものの @code{define_insn} にはマッチしない
insn は、最適化を行なわないコンパイルの場合のコード生成で、あるいは
色々な最適化の段階で、異常終了を引き起こす。

insn のオペランドは、通常同様、@code{match_operands} や
 @code{match_operator}、@code{match_dup} にマッチする。
通常と違うのは、オペランド番号が定義の中にある全ての insn パターンに
適用されるという点である。このため、二つの insn にある同じオペランドを
検査するのに、片方の insn では @code{match_operand} を、もう一方では
@code{match_dup} を使うことができる。

@code{match_operand} パターンで使われるオペランド制約は、
覗き穴が適用されるかどうかについては、なんら直接的な効果は持たない。
だが、後で検証されるので、この制約は、覗き穴がマッチするときは
いつでも適用できるぐらい一般的なものになっていることを確認して欲しい。
覗き穴にはマッチするが、制約が満たされない場合は、コンパイラが落ちるだろう。

覗き穴最適化の場合は、全てのオペランドの制約を省略しても安全である。
あるいは、制約を書いて、既にテスト済みの規準を二重に検査することにしても
良い。

ある insn の列がそのパターンに一度一致すると、@var{condition} が
検査される。@var{condition} は一個の C の式であり、この最適化を
実行するかどうかを最終的に決定する(この式がゼロでなければ最適化を
行なう)。@var{condition} が指定されていないと(言い換えると、文字列が
空の場合)、この最適化はそのパターンに一致する、あらゆる insn の列に
適用される。

定義された覗き穴最適化はレジスタ割当が完了した後に適用される。
このため、このため、覗き穴最適化の定義では、どのオペランドが最終的に
どの種類のレジスタに割り当てられたかを、単にそのオペランドを見ることで
調べることができる。

@findex prev_active_insn
@var{condition} でオペランドを参照するには、オペランド番号が @var{i}
なら @code{operands[@var{i}]} と書く(@code{(match_operand @var{i} @dots{})}
によりマッチする)。マッチしつつある insn 群の最後のものを参照するには
変数 @code{insn} を使う。先行する insn 群を見つけるには
@code{prev_active_insn} を使う。

@findex dead_or_set_p
中間結果の計算を最適化するときは、@var{condition} を使って、
その中間結果が他の場所で使われない時にのみ一致させることができる。
C の式 @code{dead_or_set_p (@var{insn}, @var{op})} を使うこと。
ここで、@var{insn} は、最後に使われると想定している値が入っている insn
である(@code{insn} の値から、@code{prev_nonnote_insn} を組み合わせて
得られる)。@var{op} は、中間結果である(@code{operands[@var{i}]} から
得られる)。@refill

最適化を適用するということは、insn 列を一個の新たな insn で
置き換えるということを意味する。@var{template} が、この組み合わされた
insn のアセンブラコードの最終的な出力を制御する。
@var{template} は、@code{define_insn} のテンプレートと全く同じように
動作する。このテンプレートのオペランド番号は、元の insn 列とマッチするのに
使われたのと同じ番号である。

定義した覗き穴最適化の結果は、マシン記述の insn パターンのどれにも
マッチする必要はない。実は一致する機会すらないのである。
覗き穴最適化の定義は、それ自身が insn がどのように出力されるかを
制御する insn のパターンとして働く。

定義された覗き穴最適化はアセンブラコードが出力されるときに
実行されるので、生成される insn はどんな方法でも組み合わされたり、
並べ替えられたりすることはない。

以下の例は、68000 のマシン記述から取ったものである。

@smallexample
(define_peephole
  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
   (set (match_operand:DF 0 "register_operand" "=f")
        (match_operand:DF 1 "register_operand" "ad"))]
  "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
  "*
@{
  rtx xoperands[2];
  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);
#ifdef MOTOROLA
  output_asm_insn (\"move.l %1,(sp)\", xoperands);
  output_asm_insn (\"move.l %1,-(sp)\", operands);
  return \"fmove.d (sp)+,%0\";
#else
  output_asm_insn (\"movel %1,sp@@\", xoperands);
  output_asm_insn (\"movel %1,sp@@-\", operands);
  return \"fmoved sp@@+,%0\";
#endif
@}
")
@end smallexample

@need 1000
この最適化により

@smallexample
@group
jbsr _foobar
addql #4,sp
movel d1,sp@@-
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@noindent
が、以下のようになる。

@smallexample
@group
jbsr _foobar
movel d1,sp@@
movel d0,sp@@-
fmoved sp@@+,fp0
@end group
@end smallexample

@ignore
@findex CC_REVERSED
If a peephole matches a sequence including one or more jump insns, you must
take account of the flags such as @code{CC_REVERSED} which specify that the
condition codes are represented in an unusual manner.  The compiler
automatically alters any ordinary conditional jumps which occur in such
situations, but the compiler cannot alter jumps which have been replaced by
peephole optimizations.  So it is up to you to alter the assembler code
that the peephole produces.  Supply C code to write the assembler output,
and in this C code check the condition code status flags and change the
assembler code as appropriate.
@end ignore

@var{insn-pattern-1} 等は、@emph{ほぼ} @code{define_insn} の
第二オペランドに同じである。重要な違いが一つある。
@code{define_insn} の第二オペランドは、鍵括弧で囲まれた一つ以上の
RTX からなる。普通は一つだけである。その場合、
同じ動作を @code{define_peephole} の要素として書くことができる。
しかし、@code{define_insn} に複数の動作があるときは、暗黙のうちに
@code{parallel} で囲まれる。その場合、@code{define_peephole} では、
@code{parallel} とその中に鍵括弧を明示的に書かなければならない。
こうして、ある insn パターンが

@smallexample
(define_insn "divmodsi4"
  [(set (match_operand:SI 0 "general_operand" "=d")
        (div:SI (match_operand:SI 1 "general_operand" "0")
                (match_operand:SI 2 "general_operand" "dmsK")))
   (set (match_operand:SI 3 "general_operand" "=d")
        (mod:SI (match_dup 1) (match_dup 2)))]
  "TARGET_68020"
  "divsl%.l %2,%3:%0")
@end smallexample

@noindent
のようになていたとすると、この insn を覗き穴に書くには以下のようにする。

@smallexample
(define_peephole
  [@dots{}
   (parallel
    [(set (match_operand:SI 0 "general_operand" "=d")
          (div:SI (match_operand:SI 1 "general_operand" "0")
                  (match_operand:SI 2 "general_operand" "dmsK")))
     (set (match_operand:SI 3 "general_operand" "=d")
          (mod:SI (match_dup 1) (match_dup 2)))])
   @dots{}]
  @dots{})
@end smallexample

@end ifset
@ifset INTERNALS
@node Insn Attributes
@section Instruction Attributes
@cindex insn attributes
@cindex instruction attributes

ターゲット機種でサポートされている命令の記述に加えて、
@file{md} ファイルでは、@dfn{属性} のグループとそれぞれの属性の値を
定義することも出来る。生成される各 insn には、属性毎に一つの値が
割り当てられる。取る得る属性の一つとしては、insn がその機種の条件コード
について持つ効果がある。
そして、この属性を使って @code{NOTICE_UPDATE_CC} が条件コードを
追跡することができる。

@menu
* Defining Attributes:: Specifying attributes and their values.
* Expressions::         Valid expressions for attribute values.
* Tagging Insns::       Assigning attribute values to insns.
* Attr Example::        An example of assigning attributes.
* Insn Lengths::        Computing the length of insns.
* Constant Attributes:: Defining attributes that are constant.
* Mnemonic Attribute::  Obtain the instruction mnemonic as attribute value.
* Delay Slots::         Defining delay slots required for a machine.
* Processor pipeline description:: Specifying information for insn scheduling.
@end menu

@end ifset
@ifset INTERNALS
@node Defining Attributes
@subsection Defining Attributes and their Values
@cindex defining attributes and their values
@cindex attributes, defining

@findex define_attr
@code{define_attr} 式を使って、ターゲットマシンで必要とされる
各属性を定義する。以下のような形式になる。

@smallexample
(define_attr @var{name} @var{list-of-values} @var{default})
@end smallexample

@var{name} は、定義しようとしている属性の名前を指定する文字列である。

@var{list-of-values} は、属性に割り当てられる、コンマで区切った値のリスト
を指定する文字列か、その属性が数値を取ることを示すヌル文字列のどちらかである。

@var{default} は、ある属性式であり、この属性に対する明示的な値を
含まない定義を持つパターンにマッチする insn のこの属性の値を与える。
デフォルトの扱いについてのもっと詳細な情報は、@xref{Attr Example}。
特定の insn に依存しない属性についての情報は、@xref{Constant Attributes}。

@findex insn-attr.h
定義されている各属性毎に、たくさんの定義がファイル @file{insn-attr.h} に
書き込まれる。属性に対して明示的な値の組が指定されている場合は、
以下のように定義されている。

@itemize @bullet
@item
@samp{#define} が、シンボル @samp{HAVE_ATTR_@var{name}} に対して
書かれている。

@item
ある列挙型クラスが @samp{attr_@var{name}} に対して定義される。
この列挙型の要素は、@samp{@var{upper-name}_@var{upper-value}} という
形になり、属性名と属性値はまず大文字に変換される。

@item
関数 @samp{get_attr_@var{name}} が定義されており、
この関数は insn を一つ受取、その insn の属性値を返す。
@end itemize

例えば、@file{md} ファイルに以下のように書いてあったとすると、

@smallexample
(define_attr "type" "branch,fp,load,store,arith" @dots{})
@end smallexample

@noindent
ファイル @file{insn-attr.h} には以下のように出力される。

@smallexample
#define HAVE_ATTR_type
enum attr_type @{TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                 TYPE_STORE, TYPE_ARITH@};
extern enum attr_type get_attr_type ();
@end smallexample

属性が数値を取るなら、@code{enum} 型は定義されず、属性値を取得する
関数は @code{int} を返す。

@end ifset
@ifset INTERNALS
@node Expressions
@subsection Attribute Expressions
@cindex attribute expressions

属性を定義するのに使われる RTL 式は、前出のコードに加えて、
以下で議論する、属性定義に固有のコードを幾つか使っている。
属性値式は、以下の形のどれか一つでなければならない。

@table @code
@cindex @code{const_int} and attributes
@item (const_int @var{i})
整数 @var{i} が、数値属性の値を指定する。
@var{i} は非負でなければならない。

数値属性の値は、@code{const_int} か、@code{const_string} で文字列で
表現した整数、@code{eq_attr}(以下参照)、@code{attr}、
@code{symbol_ref}、単純算術式のどれかで指定することができ、
@code{set_attr} は特定の命令を上書きする(@pxref{Tagging Insns})。

@cindex @code{const_string} and attributes
@item (const_string @var{value})
文字列 @var{value} は、定数属性値を指定する。
@var{value} が @samp{"*"} として指定されると、
その属性のデフォルト値が、この式を含む insn に対して使われることを意味する。
@samp{"*"} は、明らかに、@code{define_attr} の @var{default} 式で使うことは
できない。@refill

値が指定されている属性が数値的なら、@var{value} は非負の整数
(この場合、普通 @code{const_int})を含む文字列でなければならない。
数値的でなければ、その属性に対して有効な値の一つを含んでいなければならない。

@cindex @code{if_then_else} and attributes
@item (if_then_else @var{test} @var{true-value} @var{false-value})
@var{test} は属性テストを指定する。その形式は以下で定義される。
この式の値は、@var{test} が真であれば @var{true-value} であり、
真でなければ @var{false-value} となる。

@cindex @code{cond} and attributes
@item (cond [@var{test1} @var{value1} @dots{}] @var{default})
この式の第一オペランドはあるベクトルであり、偶数個の式をもち、
@var{test} 式と @var{value} 式の対からなる。@code{cond} 式の値は
最初の真である @var{test} 式に対応する値のものである。真となる @var{test}
式がない場合は、@code{cond} 式の値は @var{default} 式の値である。
@end table

@var{test} 式は、以下の形のうちの一つを取る。

@table @code
@cindex @code{const_int} and attribute tests
@item (const_int @var{i})
このテストは、@var{i} がゼロでなければ真になり、さもなければ
偽になる。

@cindex @code{not} and attributes
@cindex @code{ior} and attributes
@cindex @code{and} and attributes
@item (not @var{test})
@itemx (ior @var{test1} @var{test2})
@itemx (and @var{test1} @var{test2})
これらのテストは、指定された論理関数が真になれば、真である。

@cindex @code{match_operand} and attributes
@item (match_operand:@var{m} @var{n} @var{pred} @var{constraints})
このテストは、属性値が決定されようとしている insn のオペランド
@var{n} のモードが @var{m} であり(テストのこの部分は、@var{m} が
@code{VOIDmode} なら無視される)、かつ文字列 @var{pred} で指定される
関数が、オペランド @var{n} とモード @var{m} を渡したときに
ゼロでない値を返したときに、真になる(テストのこの部分は、
@var{pred} がヌル文字列なら無視される)。

オペランド @var{constraints} は無視されるので、ヌル文字列とすべきである。

@cindex @code{le} and attributes
@cindex @code{leu} and attributes
@cindex @code{lt} and attributes
@cindex @code{gt} and attributes
@cindex @code{gtu} and attributes
@cindex @code{ge} and attributes
@cindex @code{geu} and attributes
@cindex @code{ne} and attributes
@cindex @code{eq} and attributes
@cindex @code{plus} and attributes
@cindex @code{minus} and attributes
@cindex @code{mult} and attributes
@cindex @code{div} and attributes
@cindex @code{mod} and attributes
@cindex @code{abs} and attributes
@cindex @code{neg} and attributes
@cindex @code{ashift} and attributes
@cindex @code{lshiftrt} and attributes
@cindex @code{ashiftrt} and attributes
@item (le @var{arith1} @var{arith2})
@itemx (leu @var{arith1} @var{arith2})
@itemx (lt @var{arith1} @var{arith2})
@itemx (ltu @var{arith1} @var{arith2})
@itemx (gt @var{arith1} @var{arith2})
@itemx (gtu @var{arith1} @var{arith2})
@itemx (ge @var{arith1} @var{arith2})
@itemx (geu @var{arith1} @var{arith2})
@itemx (ne @var{arith1} @var{arith2})
@itemx (eq @var{arith1} @var{arith2})
これらのテストは、二つの算術式について指定された比較の結果が真になれば、
真となる。算術式は、
@code{plus}、@code{minus}、@code{mult}、@code{div}、@code{mod}、
@code{abs}、@code{neg}、@code{and}、@code{ior}、@code{xor}、@code{not}、
@code{ashift}、@code{lshiftrt}、@code{ashiftrt} といった式から
構成される。@refill

@findex get_attr
@code{const_int} と @code{symbol_ref} は常に有効な項である
(追加の形式については @pxref{Insn Lengths})。
@code{symbol_ref} は一個の文字列であり、一個の C の式を示す。
この式は、@samp{get_attr_@dots{}} ルーチン
で評価されたときに @code{int} を生じる。普通はグローバル変数に
ならないといけない。@refill

@findex eq_attr
@item (eq_attr @var{name} @var{value})
@var{name} は、属性名を指定する文字列である。

@var{value} は文字列であり、属性 @var{name} の有効な値であるか、
幾つかの値をカンマで区切ったリストか、あるいは @samp{!} の後に
一個の値か値のリストを続けたものである。
@var{value} が @samp{!} で始まっていなければ、このテストは、現在の insn の
属性 @var{name} の値が @var{value} で指定されたリストの中に
入っていれば、真となる。@var{value} が @samp{!} で始まっていると、
このテストは属性値が指定されたリストに入って@emph{いない}時に真となる。

例えば

@smallexample
(eq_attr "type" "load,store")
@end smallexample

@noindent
は、次の式に等価である。

@smallexample
(ior (eq_attr "type" "load") (eq_attr "type" "store"))
@end smallexample

@var{name} が @samp{alternative} の属性を指定するものなら、それは
GNU CC の変数 @code{which_alternative} の値を参照し
(@pxref{Output Statement})、その値は小さな整数でなくてはならない。
例えば、@refill

@smallexample
(eq_attr "alternative" "2,3")
@end smallexample

@noindent
は、次の式に等価である。

@smallexample
(ior (eq (symbol_ref "which_alternative") (const_int 2))
     (eq (symbol_ref "which_alternative") (const_int 3)))
@end smallexample

ほとんどの属性に対して、テスト @code{eq_attr} は、
テストされる属性の値が、ある特定のパターンにマッチする全ての insn に
対して知られているなら、簡略化される。これは非常に良くあるケースである。@refill

@findex attr_flag
@item (attr_flag @var{name})
@code{attr_flag} 式の値は、@var{name} で指定されたフラグが
現在スケジューリング中の @code{insn} に対して真になるなら、真となる。

@var{name} はある文字列であり、テストすべきフラグの固定したセットを
一つ指定する。フラグ @code{forward} と @code{backward} を
テストして、条件分岐の方向を決定する。フラグ @code{very_likery}、
@code{likely}、@code{very_unlikely}、@code{unlikely} をテストして、
条件分岐が成立すると予想されるかどうかを決定する。

フラグ @code{very_likely} が真なら、フラグ @code{likely} もまた
真になる。@code{very_unlikely} と @code{unlikely} についても同様である。

この例では、条件分岐の遅延スロットを記述している。
このスロットは、分岐が成立する前方への分岐(真の無効化)か
分岐が成立しない場合の後方への分岐(偽の無効化)が無効化される。


@smallexample
(define_delay (eq_attr "type" "cbranch")
  [(eq_attr "in_branch_delay" "true")
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "forward"))
   (and (eq_attr "in_branch_delay" "true")
        (attr_flag "backward"))])
@end smallexample

フラグ @code{forward} と @code{backward} は、現在スケジュールされつつある
@code{insn} が条件分岐でなければ、偽になる。

フラグ @code{very_likely} と @code{likely} は、スケジュールされつつある
@code{insn} が条件分岐でなければ、真になる。
フラグ @code{very_unlikely} と @code{unlikely} は、スケジュールされつつある
@code{insn} が条件分岐でなければ、偽になる。

@code{attr_flag} は、遅延スロットスケジューリングの間でだけ使われ、
他のパスには何の意味も持たない。

@findex attr
@item (attr @var{name})
別の属性の値を返す。数値属性に対して最も役に立つが、
同様に、非数値属性にたいしても @code{eq_attr} と @code{attr_flag} が
より効率の良いコードを生成する助けとなる。
@end table

@end ifset
@ifset INTERNALS
@node Tagging Insns
@subsection Assigning Attribute Values to Insns
@cindex tagging insns
@cindex assigning attribute values to insns

ある insn のある属性に割り当てられる値は、主に、その insn により照合される
(あるいは @code{define_peephole} が生成する)パターンにより決定される。
各 @code{define_insn} と @code{define_peephole} は、オプションの最後の
引数を持つことができ、一致する insn の属性値を指定することができる。
ある特定の insn において指定されていない属性値は全て、その属性の
デフォルト値に設定される。このデフォルト値は、その属性の @code{define_attr} で
指定される。属性のデフォルト値を多用すると、ほとんどの insn パターンの
定義で一つか二つの属性値を指定するだけで済む。次の節の例を参照のこと。

@code{define_insn} と @code{define_peephole} の最後のオプションの引数は、
式のベクトルであり、それぞれの式がある一個の属性の値を定義する。
属性値を割り当てる最も一般的な方法は、@code{set} 式を使い、その第一
オペランドを設定する属性名を与える @code{attr} 式とすることである。
この @code{set} 式の第二のオペランドは属性式(@pxref{Expressions})であり、
属性の値を与える。@refill

属性値が属性 @samp{alternaitve} に依存するとき(すなわち、それが、
その insn の制約にある利用可能な選択肢である)は、
@code{set_attr_alternative} 式を使うことができる。
これは属性式のベクトルを指定することを許す。ベクトルの中の
それぞれの式が各属性を表す。

@findex set_attr
任意の属性式ほど一般的な機能が必要ない場合、もっと簡単な 
@code{set_attr} 式を使うことができる。この式を使うと、
一個の文字列を指定することで、一個の属性値か、あるいは各選択肢毎に
一個の属性値を与えるリストを表すことができる。

上記の指定方法をそれぞれ以下に示す。
どちらの場合も、@var{name} は、設定すべき属性を指定する文字列である。

@table @code
@item (set_attr @var{name} @var{value-string})
@var{value-string} は、希望の属性値を与える文字列か、あるいは
一連の属性値をカンマで区切ったリストを表す文字列である。
この要素数は、insn パターンの制約の選択肢数と一致しなければならない。

選択肢のどれかに @samp{*} を指定することができる。
その場合、属性値は、その選択肢にマッチする insn のデフォルト値になる。

@findex set_attr_alternative
@item (set_attr_alternative @var{name} [@var{value1} @var{value2} @dots{}])
insn の選択肢により、この値は指定された値のうちの一つになる。
これは、属性 @samp{alternative} の @code{cond} を使ってのテストの
省略形である。

@findex attr
@item (set (attr @var{name}) @var{value})
この @code{set} の第一オペランドは、特別な RTL 式 である @code{attr} 式で
なければならない。この式の唯一のオペランドは、設定する属性の名前を
指定する文字列である。@var{value} は、その属性の値である。
@end table

以下に同じ属性値の指定を表す、三つの異なる方法を示す。

@smallexample
(set_attr "type" "load,store,arith")

(set_attr_alternative "type"
                      [(const_string "load") (const_string "store")
                       (const_string "arith")])

(set (attr "type")
     (cond [(eq_attr "alternative" "1") (const_string "load")
            (eq_attr "alternative" "2") (const_string "store")]
           (const_string "arith")))
@end smallexample

@need 1000
@findex define_asm_attributes
@code{define_asm_attributes} 式は、@code{asm} 文から生成された
insn に割り当てられた属性を指定する方法を提供する。
次の形を取る。

@smallexample
(define_asm_attributes [@var{attr-sets}])
@end smallexample

@noindent
ここで、@var{atr-sets} は、@code{define_insn} や @code{define_peephole} 式
両方に指定するのと同じものである。

これらの値は、普通はその属性値の「最悪の場合」になる。
例えば、条件コードが破壊されることを示したりする。

@code{length} 属性の指定は特別に扱われる。
一個の @code{asm} insn の長さを計算するには、
式 @code{define_asm_attributes} で指定された長さに、
@code{asm} 文に指定されている機械命令の数を掛けたものになる。
@code{asm} 文中の機械命令数は、命令文字列中のセミコロンと改行の
数で決まる。このため、@code{define_asm_attributes} で指定される
@code{length} 属性の値は、一個の機械命令の可能な最大長にしなくては
ならない

@end ifset
@ifset INTERNALS
@node Attr Example
@subsection Example of Attribute Specifications
@cindex attribute specifications example
@cindex attribute specifications

デフォルトをうまく使うのが、insn の属性を効率良く使うには重要である。
通常、insn は @dfn{types} と、@code{type} と呼ばれている属性に分けられる。
@code{type} は、このデフォルト値を表すのに使われる。
この属性は、普通は他の属性のデフォルト値を定義するのにしか使われない。
例を使ってこの属性の使い方を説明する。

ある RISC マシンを考えよう。このマシンには条件コードがあり、
レジスタで実行されるのは全語の演算だけである。
全ての命令をロード、ストア、(整数)算術演算、浮動小数点演算、分岐に
分割できるとしよう。

ここでは、ある insn の条件コードに対する効果を決定することに
注意を集中することにし、さらに可能な効果として次のものに限定する。
条件コードは、予測できない形で設定され得る(破壊される)、
変更されない、演算結果に一致するように設定される、
以前に条件コードに設定した項目が修正されたときにのみ
変更される。

そういう機種用の @file{md} ファイルの例の一部を示す

@smallexample
(define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))

(define_attr "cc" "clobber,unchanged,set,change0"
             (cond [(eq_attr "type" "load")
                        (const_string "change0")
                    (eq_attr "type" "store,branch")
                        (const_string "unchanged")
                    (eq_attr "type" "arith")
                        (if_then_else (match_operand:SI 0 "" "")
                                      (const_string "set")
                                      (const_string "clobber"))]
                   (const_string "clobber")))

(define_insn ""
  [(set (match_operand:SI 0 "general_operand" "=r,r,m")
        (match_operand:SI 1 "general_operand" "r,m,r"))]
  ""
  "@@
   move %0,%1
   load %0,%1
   store %0,%1"
  [(set_attr "type" "arith,load,store")])
@end smallexample

上の例で我々は、マシンワードより小さな量について算術演算を実行すると、
それにより条件コードに全ワードの結果に対応する値を設定するので、
条件コードが破壊されると仮定していることに注意。

@end ifset
@ifset INTERNALS
@node Insn Lengths
@subsection Computing the Length of an Insn
@cindex insn lengths, computing
@cindex computing the length of an insn

多くの機種では、複数のタイプの分岐命令が提供されており、
それぞれ分岐の変位の長さが異なる。
大部分の場合は、アセンブラが正しい命令を選ぶ。
だが、アセンブラが不可能な場合は、特別な属性、@samp{length} 属性が
定義されているときは GCC が行なうことができる。
この属性は、@code{define_attr} でヌル文字列を指定することで
数値を持つように定義しなければならない。

@samp{length} 属性の場合は、さらに算術項の二つの形式があり、
テスト式で使うことができる。

@table @code
@cindex @code{match_dup} and attributes
@item (match_dup @var{n})
これは、現在の insn のオペランド @var{n} のアドレスを参照している。
このアドレスは @code{label_ref} でなければならない。

@cindex @code{pc} and attributes
@item (pc)
@emph{現在の} insn のアドレスを参照する。
これを@emph{次の} insn のアドレスとする使い方の方がより一貫性が
保てるのだろうが、そうすると現在の insn の長さを計算するときに
混乱する可能性がある。
@end table

@cindex @code{addr_vec}, length of
@cindex @code{addr_diff_vec}, length of
通常の insn については、長さは @samp{length} 属性の値により
決まる。@code{addr_vec} と @code{addr_diff_vec} の insn パターンの
場合は、長さはベクトル数に各ベクトルの大きさを掛けたものとして
計算される。

長さは、アドレス可能な記憶域の単位(バイト)で測る。

以下のマクロを使って長さの計算を洗練されたものにすることができる。

@table @code
@findex FIRST_INSN_ADDRESS
@item FIRST_INSN_ADDRESS
insn の @code{length} 属性が使われているとき、このマクロは
ある関数の先頭の insn のアドレスに代入されるべき値を指定する。
これが指定されていないと、0 が使われる。

@findex ADJUST_INSN_LENGTH
@item ADJUST_INSN_LENGTH (@var{insn}, @var{length})
定義されていると、命令 @var{insn} に、それが使われている文脈の
関数として割り当てられている長さを修正する。
@var{length} は左辺値であり、最初に計算した insn の長さが入っている。
これは、その insn の正しい長さに更新する必要がある。

このマクロは通常は必要とされない。
必要となる場合の一つは、ROMP である。
この機種では、@code{addr_vec} insn の大きさは、アラインメントが
必要とされるかも知れないという事実を補償するために、2 づつ増加しなければ
ならない。
@end table

@findex get_attr_length
@code{get_attr_length}(@code{length} 属性の値)を返すルーチンを
出力ルーチンの中で使うと、以下の例が示すように、
書き出すべき分岐命令の形を決めることができる。

可変長分岐の指定の例として、IBM 360 を考える。
あるレジスタに、ある関数の開始アドレスが設定されるという規約を採用したと
すると、その開始点から 4k バイト以内のラベルには一個の 4 バイト命令で
ジャンプすることが出来る。それ以外の場合は、6バイトの命令列を使って、
メモリからアドレスをロードし、次にそのアドレスに分岐する必要がある。

こういう機種では、分岐命令のパターンは以下のような指定になる。

@smallexample
(define_insn "jump"
  [(set (pc)
        (label_ref (match_operand 0 "" "")))]
  ""
  "*
@{
   return (get_attr_length (insn) == 4
           ? \"b %l0\" : \"l r15,=a(%l0); br r15\");
@}"
  [(set (attr "length") (if_then_else (lt (match_dup 0) (const_int 4096))
                                      (const_int 4)
                                      (const_int 6)))])
@end smallexample

@end ifset
@ifset INTERNALS
@node Constant Attributes
@subsection Constant Attributes
@cindex constant attributes

@code{define_attr} の特別な形式、つまり、デフォルト値の式が @code{const} 式
の場合、ある特定のコンパイラの実行については定数である属性を示す。
定数属性は、どの種類のプロセッサが使われるかを指定するのに使われる。
例えば、以下のようになる。

@smallexample
(define_attr "cpu" "m88100,m88110,m88000"
 (const
  (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
         (symbol_ref "TARGET_88110") (const_string "m88110")]
        (const_string "m88000"))))

(define_attr "memory" "fast,slow"
 (const
  (if_then_else (symbol_ref "TARGET_FAST_MEM")
                (const_string "fast")
                (const_string "slow"))))
@end smallexample

定数属性用に生成されたルーチンには、どの特定の insn にも依存しないので、
パラメータはない。定数属性の値を定義するのに使われる RTL 式は、
@code{symbol_ref} 形式を使っても良いが、insn の属性を含む、
@code{match_operand} 形式や @code{eq_attr} 形式は使ってならない。

@end ifset
@ifset INTERNALS
@node Delay Slots
@subsection Delay Slot Scheduling
@cindex delay slots, defining

insn の属性の機構を使うと、ターゲットマシンに遅延スロットがもしあれば、
遅延スロットを必要であると指定することができる。
ある命令は、物理的にその直後に置かれている命令群が、その命令の前に
置かれているかのように実行されるとき、@dfn{遅延スロット}を必要とする
と言われる。
古典的な例では、分岐命令と呼び出し命令が該当し、
分岐や呼び出しが実行される前に後続の命令を実行することがある。

機種によっては、条件分岐命令が、遅延スロットに置かれている
命令を選択的に@dfn{無効化}することができる。
これは、遅延スロットにある命令が、分岐の結果によっては実行されないという
ことを意味する。
分岐が真のときに無効化を行なう命令と分岐が偽の時に無効化を行なう命令の
両方がサポートされている。

遅延スロット空けジューリングが命令スケジューリングと異なるのは、
ある命令が遅延スロットを必要とするかどうかを決めるには、生成される
命令の型にだけ依存し、命令間のデータ流には依存しないという点にある。
データ依存の命令スケジューリングに関する議論については次の節を
参照のこと。

@findex define_delay
ある insn が一個以上の遅延スロットを必要とするという要件は、
@code{define_delay} 式により指示される。
@code{define_delay} 式は以下の形式を取る。

@smallexample
(define_delay @var{test}
              [@var{delay-1} @var{annul-true-1} @var{annul-false-1}
               @var{delay-2} @var{annul-true-2} @var{annul-false-2}
               @dots{}])
@end smallexample

@var{test} は、属性のテストであり、この @code{define_delay} がある特定の
insn に適用されるかどうかを指示する。
もし適用されるのであれば、必要な遅延スロットの数が
二番目の引数として指定されるベクターの長さにより決定される。
遅延スロット @var{n} に置かれている insn は、属性テスト @var{delay-n} を
満足しなければならない。@var{annul-true-n} は属性テストであり、
分岐が真の時にどの insn が無効化されるかを指定する。
同様に、@var{annul-false-n} は分岐が偽の時に、
遅延スロットにあるうちのどの insn が無効化されるかを指定する。
遅延スロットの無効化がサポートされていないなら、@code{(nil)} を
指定すること。@refill

例えば、良くある場合として分岐 insn と呼び出し insn が一個の遅延スロット
を必要とし、そのスロットには分岐あるいは呼び出し以外の任意の insn を
置くことができる場合、以下のコードを @file{md} ファイルに置くことになる。

@smallexample
(define_delay (eq_attr "type" "branch,call")
              [(eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample

@code{define_delay} 式は複数指定することができる。
その場合、各 @code{define_delay} 式は、別々の遅延スロット要件を
指定し、二つの @code{define_delay} 式のテストで両方真になる insn が
あってはならない。

例えば、分岐には一個の遅延スロットを必要とするが、呼び出しには二つ
の遅延スロットが必要で、遅延スロットには分岐 insn も呼び出し insn も
置くことができず、分岐用の遅延スロットに有効な任意の insn が
分岐が真の場合には無効化可能であるという機種では、以下のように表現する。

@smallexample
(define_delay (eq_attr "type" "branch")
   [(eq_attr "type" "!branch,call")
    (eq_attr "type" "!branch,call")
    (nil)])

(define_delay (eq_attr "type" "call")
              [(eq_attr "type" "!branch,call") (nil) (nil)
               (eq_attr "type" "!branch,call") (nil) (nil)])
@end smallexample
@c the above is *still* too long.  --mew 4feb93

@end ifset

@node Function Units,  , Delay Slots, Insn Attributes
@subsection Specifying Function Units
@cindex function units, for scheduling

多くの RISC マシンでは、特定のサイクル数またないとその結果が得られない
ような命令が存在する。良く見られるのは、メモリからデータをロード
する命令である。多くのマシンでは、ロード命令の後、あまり早くロード
されるデータを参照すると、パイプラインがストールする。

さらに、最近の多くのマイクロプロセッサは、複数の機能ユニット、普通は
一個の整数向けのユニットと一個の浮動小数点ユニットを持っており、
そのため、必要とされる結果が用意できていないときに良くパイプラインが
ストールする。

この節では、ある命令の実行から、その結果が使えるようになるまでにどれだけの
時間が経過する必要があるかを指定する方法を説明する。
また、ある命令の実行することにより、機能ユニットの競合にのために、
同種の命令の実行を遅らせることがあるのはどういう場合かを指定する方法に
ついても説明する。

この節で説明する指定方法のために、マシンを機能ユニットに分割し、
各機能ユニットは特定の種類の命令を first-in-first-out 順に
実行するものとする。
各サイクル毎に一つの命令を受付、続く命令でその結果が利用できる
(フォワーディングによることが多い)機能ユニットについては、
指定を行う必要がない。
古典的な RISC マイクロプロセッサは、通常機能ユニットは一つしかなく、
それを@samp{メモリ} と呼ぶことが出来る。最近のスーパースカラ・プロセッサ
は、浮動小数点演算用の機能ユニットを複数持つことが多い。少なくとも、
一個の浮動小数点加算器と乗算器を持つのが普通である。

@findex define_function_unit
ある insn のクラスによるある機能ユニットの使用方法は、
@code{define_function_unit} 式で指定される。それは以下のようになる。

@smallexample
(define_function_unit @var{name} @var{multiplicity} @var{simultaneity}
                      @var{test} @var{ready-delay} @var{issue-delay}
                     [@var{conflict-list}])
@end smallexample

@var{name} は、機能ユニット名を指定する文字列である。

@var{multiplicity} は整数であり、プロセッサの持つ同等のユニット数を
指定する。二個以上のユニットが指定された場合は、各ユニットは
独立にスケジュールされる。
本当に独立なユニット数を指定すべきである。パイプライン化されたユニットは
一個のユニットとして指定すべきである。(一個の命令クラスに対し
複数の機能ユニットがあり、それらが真に独立しており、パイプライン化
されていない機種の良く知られている例としては、CDC 6600 の二つの
乗算ユニットと二つの増分ユニットがあるのみである。)

@var{simultaneity} は、各機能ユニットの実態で同時に実行できる命令の
最大数か、機能ユニットがパイプライン化されていて制限がないのであれば
ゼロを指定する。

機能ユニット @var{name} を参照している、全ての
 @code{define_function_unit} の定義は、@var{multiplicity} と
@var{simultaneity} について同じ名前と値を持たなければならない。

@var{test} は属性テストであり、この定義において記述しようとしている
insn を選択する。一個の insn は、複数の機能ユニットを使っても良く、
一個の機能ユニットは複数の @code{define_function_unit} で指定されて
いても良いということに注意して欲しい。

@var{ready-delay} はある整数であり、ストールなしで命令の結果が
使えるようになるまでのサイクル数を指定する。

@var{issue-delay} はある整数であり、@var{test} 式に一致した命令が
この機能ユニットを使い始めてから、後続の命令が使い始められるまでの
サイクル数を指定する。コストが @var{N} だと @var{N-1} サイクルの遅延を
表す。後続の命令は、以前の命令がより大きな値の @var{ready-delay} を
持っている場合にも遅延する可能性がある。このブロックの効果は、
@var{simultaneity}、@var{ready-delay}、@var{issue-delay}、
@var{conflict-list} といった項から計算される。
普通のパイプライン化されていない機能ユニットについては、
@var{simultaneity} は 1 であり、このユニットは、実行している命令の
@var{ready-delay} サイクルの間ブロックされる。より小さな値の
@var{issue-delay} は無視される。

@var{conflict-list} はオプションのリストであり、この機能ユニットの
衝突の詳細なコストを与える。指定されていると、条件のテスト式の
リストになっており、その式は、@var{name} で実行されるように選ばれた
insn に適用される。その insn の後に、既に @var{name} で実行中の
@var{test} にマッチする特定の insn が続く。
リストのそれぞれの insn に対し、@var{issue-delay} が
衝突のコストを指定する。リストに無い insn については、コストはゼロである。
指定されていない場合は、@var{conflict-list} は、
機能ユニットを使う全ての命令がデフォルトになる。

このベクトルが使われる典型的な場合としては、
浮動小数点機能ユニットが単精度演算か倍精度演算のどちらかは
パイプライン化できるが両方は出来ない場合や、メモリユニットが
ロード命令はパイプライン化できるがストア命令はできない場合等がある。

例として古典的な RISC マシンを考えてみよう。ロード命令の結果は
二サイクルの間利用できず(一個の「遅延」命令が必要)、ロード命令は
同時には一個しか実行できないとする。これは以下のように指定できる。

@smallexample
(define_function_unit "memory" 1 1 (eq_attr "type" "load") 2 0)
@end smallexample

浮動小数点機能ユニットが単精度か倍精度のどちらかはパイプライン処理できるが、
両方はできないという場合、以下のように指定することができる。

@smallexample
(define_function_unit
   "fp" 1 0 (eq_attr "type" "sp_fp") 4 4 [(eq_attr "type" "dp_fp")])
(define_function_unit
   "fp" 1 0 (eq_attr "type" "dp_fp") 4 4 [(eq_attr "type" "sp_fp")])
@end smallexample

@strong{注意:} スケジューラは、機能ユニットの衝突を避け、
@code{define_function_unit} の全ての指定を使おうとする。
我々は最近、これらの指定では、
複数のパイプラインユニットを使う命令を持つ、いくつかの新しめの
「スーパスカラ」プロセッサをモデル化できないということに気が付いた。
これらの命令は、第二の機能ユニットがそれらの命令を実行するのに使われている
間に潜在的な衝突を起こす可能性があり、その衝突を表現する方法がないのである。
このようなプロセッサの機能ユニットの衝突の仕組みの例や、その表現方法に
ついて提案があれば、知らせて欲しい。

